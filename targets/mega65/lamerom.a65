.SETCPU "4510"


.IFDEF ROM
	.ORG	$E000
.ELSE
	LOAD_ADDR = $801
	.WORD	LOAD_ADDR
	.ORG	LOAD_ADDR

	.SCOPE
		.WORD	lastline, $FFFF
		.BYTE	$9E	; "SYS" basic token
		.BYTE	" "
		.BYTE	$30+.LOBYTE((main .MOD 10000)/ 1000)
		.BYTE	$30+.LOBYTE((main .MOD  1000)/  100)
		.BYTE	$30+.LOBYTE((main .MOD   100)/   10)
		.BYTE	$30+.LOBYTE( main .MOD    10)
		.BYTE	0
	lastline:
		.WORD	0
	.ENDSCOPE
.ENDIF


scroll_table_lo_bytes = $2000
scroll_table_hi_bytes = $2100


main:
	; Disable interrupts
	SEI
	; Z is zero!!! Till it's not, later ;)
	LDZ	#0
	; Knock for VIC-IV mode
        LDA	#$47
        STA	$D02F
        LDA	#$53
        STA	$D02F

	; Be sure about CPU speed
	LDA	#65
	STA	0

	; Some VIC init stuff
.IF 0
	LDA	#0
	TAX
:	CPX	#$2F
	BEQ	:+
	STA	$D000,X
:	INX
	BPL	:--
.ENDIF


	LDA	#$80
	TSB	$D06F	; NTSC; I prefer PAL, but somehow it looks better in NTSC. Well, it's an emulator, so it does make too much difference to stick with NTSC or PAL
	TSB	$D05D	; make sure hot registers are enabled

	LDA	#3	; set legacy VIC bank
	TSB	$DD00

	STZ	$D015	; disables sprites (just in case)

	LDA	#$1B
	STA	$D011	; Screen control register #1
	LDA	#$C8
	STA	$D016	; Screen control register #2
	LDA	#39
	STA	$D018	; memory ptrs
	LDA	#4
	STA	$D030	; enable Palette-ROM
	LDA	#$80
	STA	$D031	; H640

	LDA	#3
	STA	$D062	; VIC-IV precise address of screen, highest byte
	STZ	$D061	; middle byte
	STZ	$D060	; lowest byte
	STZ	$D065	; VIC-IV precise colour addr, hi byte
	STZ	$D064	; low byte



.IFDEF ROM
	; Execute DMA ...
	LDA	#2
	STA	$D702	; very high byte
	LDA	#.HIBYTE(dma_list)
	STA	$D701	; middle byte
	LDA	#.LOBYTE(dma_list)
	STA	$D705	; trigger DMA with MEGA65 specific enhanced mode DMA (thus not $D700 is written but $D705)
.ENDIF

	; Create our scroll stuff table.
	TZA
	TAX
	TAY
@make_tab:
	STA	scroll_table_lo_bytes,X
	STY	scroll_table_hi_bytes,X
	INX
	BEQ	@end_tab
	CLC
	ADC	#80
	BCC	@make_tab
	INY
	BRA	@make_tab
@end_tab:



	; set background and border to colour index $FF, since we'll modify that colour for our raster effect
	LDA	#$FF
	STA	$D020
	STA	$D021
	STA	$D3FF
	; Set red and green component of palette index $FF
	STZ	$D1FF
	STZ	$D2FF



	; Delay the raster effect by approx 1 sec
	LDA	$D7FA
	ADC	#60	; exact value not so important, so who cares the carry
:	CMP	$D7FA
	BNE	:-




	; Some "nice" raster (but not IRQ) based colour gradient
	; No need to be fancy, just to have something. Infinite loop.



	STZ	2
	TZA
	TAX
	TAY
@new_frame_on_scroll:
	TYA
	CLC
	ADC	2
	CMP	#$FF
	BEQ	@new_frame
	CMP	#40
	BEQ	@new_frame
	STA	2
	TAY
	LDA	scroll_table_lo_bytes,Y
	STA	$D060	; VIC-IV precise address of screen, low byte
	STA	$D064	; VIC-IV colour ram base addr
	LDA	scroll_table_hi_bytes,Y
	STA	$D061
	STA	$D065
@new_frame:
	LDY	$D7FA	; frame counter
@raster_loop:
	LDA	pal_sine,X
	STA	$D3FF
	INX
	; wait for next raster
	LDA	$D012
:	CMP	$D012
	BEQ	:-
	; Still the same frame?
	CPY	$D7FA
	BEQ	@raster_loop
	INZ
	TZA
	TAX
	LDA	$D610		; any key?
	BEQ	@new_frame	; no key is pressed
	STA	$D610		; write something to pull that from the "queue"
	LDY	#$FF
	CMP	#'u'
	BEQ	@new_frame_on_scroll
	LDY	#$01
	CMP	#'d'
	BEQ	@new_frame_on_scroll
	BRA	@new_frame







pal_sine:
	.BYTE $00,$30,$60,$90,$C0,$F0,$21,$51,$81,$C1,$F1,$22,$52,$82,$B2,$E2
	.BYTE $13,$43,$73,$A3,$D3,$04,$44,$74,$A4,$D4,$F4,$25,$55,$85,$B5,$E5
	.BYTE $16,$46,$76,$A6,$D6,$F6,$27,$57,$87,$A7,$D7,$08,$38,$58,$88,$B8
	.BYTE $D8,$09,$29,$59,$79,$A9,$C9,$F9,$1A,$4A,$6A,$8A,$BA,$DA,$FA,$2B
	.BYTE $4B,$6B,$8B,$AB,$CB,$FB,$1C,$3C,$5C,$7C,$9C,$AC,$CC,$EC,$0D,$2D
	.BYTE $4D,$5D,$7D,$9D,$AD,$CD,$DD,$FD,$0E,$2E,$3E,$5E,$6E,$7E,$9E,$AE
	.BYTE $BE,$CE,$DE,$FE,$0F,$1F,$2F,$3F,$4F,$4F,$5F,$6F,$7F,$8F,$8F,$9F
	.BYTE $AF,$AF,$BF,$BF,$CF,$CF,$DF,$DF,$DF,$EF,$EF,$EF,$EF,$EF,$EF,$EF
	.BYTE $FF,$EF,$EF,$EF,$EF,$EF,$EF,$EF,$DF,$DF,$DF,$CF,$CF,$BF,$BF,$AF
	.BYTE $AF,$9F,$8F,$8F,$7F,$6F,$5F,$4F,$4F,$3F,$2F,$1F,$0F,$FE,$DE,$CE
	.BYTE $BE,$AE,$9E,$7E,$6E,$5E,$3E,$2E,$0E,$FD,$DD,$CD,$AD,$9D,$7D,$5D
	.BYTE $4D,$2D,$0D,$EC,$CC,$AC,$9C,$7C,$5C,$3C,$1C,$FB,$CB,$AB,$8B,$6B
	.BYTE $4B,$2B,$FA,$DA,$BA,$8A,$6A,$4A,$1A,$F9,$C9,$A9,$79,$59,$29,$09
	.BYTE $D8,$B8,$88,$58,$38,$08,$D7,$A7,$87,$57,$27,$F6,$D6,$A6,$76,$46
	.BYTE $16,$E5,$B5,$85,$55,$25,$F4,$D4,$A4,$74,$44,$04,$D3,$A3,$73,$43
	.BYTE $13,$E2,$B2,$82,$52,$22,$F1,$C1,$81,$51,$21,$F0,$C0,$90,$60,$30


.IFDEF ROM


dma_list:
	; --- copy colour data into the colour RAM
	.BYTE	$0A	; MEGA65 enhanced mode list: F018A style DMA list (shorter)
	.BYTE	$81,$FF	; target megabyte slice option to $FF
	.BYTE	$00	; end of enhanced option list.
	.BYTE	0	; command byte: 0 = copy ( no chain)
	.WORD	$8000	; DMA length, 32K
	.WORD	$8000	; DMA source addr 16 bits
	.BYTE	3	; DMA source addr high bits+others
	.WORD	0	; DMA target addr 16 bits
	.BYTE	8	; DMA target addr high bits+others
	; MISSING MODULO WORD! Do not do this ever, only maybe at the LAST entry, if modulo was NOT used!!

.ENDIF



