
; ******** Source: src/hyppo/main.asm
     1                            ;; ------------------------------------------------------------------- 
     2                            ;;   MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                            ;;   Paul Gardner-Stephen, 2014-2019.
     4                            ;;   -------------------------------------------------------------------
     5                            ;;   Purpose:
     6                            ;;   1. Verify checksum of ROM area of slow RAM.
     7                            ;;   2. If checksum fails, load complete ROM from SD card.
     8                            ;;   3. Select default disk image for F011 emulation.
     9                          
    10                            ;;   The hyppo ROM is 16KB in length, and maps at $8000-$BFFF
    11                            ;;   in hypervisor mode.
    12                          
    13                            ;;   Hyppo modifies RAM from $0000-$07FFF (ZP, stack, 40-column
    14                            ;;   screen, 16-bit text mode) during normal boot.
    15                          
    16                            ;;   BG: is the below true still, I dont think so.
    17                            ;;   If Hyppo needs to load the ROM from SD card, then it may
    18                            ;;   modify the first 64KB of fast ram.
    19                          
    20                            ;;   We will use the convention of C=0 means failure, ie CLC/RTS,
    21                            ;;                             and C=1 means success, ie SEC/RTS.
    22                          
    23                          
    24                            ;;   This included file defines many of the alias used throughout
    25                            ;;   it also suggests some memory-map definitions
    26                            ;;   ---------------------------------------------------------------- 
    27                          

; ******** Source: constants.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                   os_version = $0102
     7                                   dos_version = $0102
     8                                   constant_partition_type_fat32_chs = $0b
     9                                   constant_partition_type_fat32_lba = $0c
    10                                   constant_partition_type_megea65_sys = $41
    11                          
    12                                  ;; DOS error codes
    13                                  ;;
    14                                   dos_errorcode_partition_not_interesting = $01
    15                                   dos_errorcode_bad_signature = $02
    16                                   dos_errorcode_is_small_fat = $03
    17                                   dos_errorcode_too_many_reserved_clusters = $04
    18                                   dos_errorcode_not_two_fats = $05
    19                                   dos_errorcode_too_few_clusters = $06
    20                                   dos_errorcode_read_timeout = $07
    21                                   dos_errorcode_partition_error = $08
    22                                   dos_errorcode_invalid_address = $10
    23                                   dos_errorcode_illegal_value = $11
    24                                   dos_errorcode_read_error = $20
    25                                   dos_errorcode_write_error = $21
    26                                   dos_errorcode_no_such_disk = $80
    27                                   dos_errorcode_name_too_long = $81
    28                                   dos_errorcode_not_implemented = $82
    29                                   dos_errorcode_file_too_long = $83
    30                                   dos_errorcode_too_many_open_files = $84
    31                                   dos_errorcode_invalid_cluster = $85
    32                                   dos_errorcode_is_a_directory = $86
    33                                   dos_errorcode_not_a_directory = $87
    34                                   dos_errorcode_file_not_found = $88
    35                                   dos_errorcode_invalid_file_descriptor = $89
    36                                   dos_errorcode_image_wrong_length = $8A
    37                                   dos_errorcode_image_fragmented = $8B
    38                                   dos_errorcode_no_space = $8C
    39                                   dos_errorcode_file_exists = $8D
    40                                   dos_errorcode_directory_full = $8E
    41                                   dos_errorcode_eof = $FF
    42                          
    43                                  ;; FAT directory entry constants
    44                                  ;;
    45                                  ;; these seem to be offsets into the STANDARD FAT32 header (DO NOT CHANGE)
    46                                  ;;
    47                                   fs_fat32_dirent_offset_attributes = 11
    48                                   fs_fat32_dirent_offset_shortname = 0
    49                                   fs_fat32_dirent_offset_create_tenthsofseconds = 13
    50                                   fs_fat32_dirent_offset_create_time = 14
    51                                   fs_fat32_dirent_offset_create_date = 16
    52                                   fs_fat32_dirent_offset_access_date = 18
    53                                   fs_fat32_dirent_offset_clusters_high = 20
    54                                   fs_fat32_dirent_offset_modify_time = 22
    55                                   fs_fat32_dirent_offset_modify_date = 24
    56                                   fs_fat32_dirent_offset_clusters_low = 26
    57                                   fs_fat32_dirent_offset_file_length = 28
    58                          
    59                                  ;; VFAT long file name entry constants
    60                                  ;;
    61                                  ;; These are the offsets of the various fields in a directory entry, when
    62                                  ;; used to store a long-file-name fragment.
    63                                  ;;
    64                                   fs_fat32_dirent_offset_lfn_part_number = 0
    65                                   fs_fat32_dirent_offset_lfn_type = 12
    66                                   fs_fat32_dirent_offset_lfn_checksum = 13
    67                                   fs_fat32_dirent_offset_lfn_part1_chars = 5
    68                                   fs_fat32_dirent_offset_lfn_part1_start = 1
    69                                   fs_fat32_dirent_offset_lfn_part2_chars = 6
    70                                   fs_fat32_dirent_offset_lfn_part2_start = 14
    71                                   fs_fat32_dirent_offset_lfn_part3_chars = 2
    72                                   fs_fat32_dirent_offset_lfn_part3_start = 28
    73                          
    74                                   fs_fat32_attribute_isreadonly = $01
    75                                   fs_fat32_attribute_ishidden = $02
    76                                   fs_fat32_attribute_issystem = $04
    77                                   fs_fat32_attribute_isvolumelabel = $08
    78                                   fs_fat32_attribute_isdirectory = $10
    79                                   fs_fat32_attribute_archiveset = $20
    80                          
    81                                  ;; Possible file modes
    82                                  ;;
    83                                   dos_filemode_directoryaccess = $80
    84                                   dos_filemode_end_of_directory = $81
    85                                   dos_filemode_readonly = 0
    86                                   dos_filemode_readwrite = 1
    87                          
    88                                  ;; 256-byte fixed size records for REL emulaton
    89                                  ;;
    90                                   dos_filemode_relative = 2
    91                          
    92                                  ;; Each disk entry consists of;
    93                                  ;;
    94                                  ;; Offset $00 - starting sector (4 bytes)
    95                                   fs_start_sector = $00
    96                          
    97                                  ;; Offset $04 - sector count (4 bytes)
    98                                   fs_sector_count = $04
    99                          
   100                                  ;; Offset $08 - Filesystem type & media source ($0x = FAT32, $xF = SD card, others reserved for now)
   101                                   fs_type_and_source = $08
   102                          
   103                                  ;; Remaining bytes are filesystem dependent:
   104                                  ;; For FAT32:
   105                                  ;;
   106                                  ;; Offset $09 - length of fat (4 bytes) (FAT starts at fs_fat32_system_sectors)
   107                                   fs_fat32_length_of_fat = $09
   108                          
   109                                  ;; Offset $0D - system sectors (2 bytes)
   110                                   fs_fat32_system_sectors = $0D
   111                          
   112                                  ;; Offset $0F - reserved clusters (1 byte)
   113                                   fs_fat32_reserved_clusters = $0F
   114                          
   115                                  ;; Offset $10 - root dir cluster (2 bytes)
   116                                   fs_fat32_root_dir_cluster = $10
   117                          
   118                                  ;; Offset $12 - cluster count (4 bytes)
   119                                   fs_fat32_cluster_count = $12
   120                          
   121                                  ;; Offset $16 - sectors per cluster
   122                                   fs_fat32_sectors_per_cluster = $16
   123                          
   124                                  ;; Offset $17 - copies of FAT
   125                                   fs_fat32_fat_copies = $17
   126                          
   127                                  ;; Offset $18 - first sector of cluster zero (4 bytes)
   128                                   fs_fat32_cluster0_sector = $18
   129                          
   130                                  ;; Offset $1C - Four spare bytes.
   131                          
   132                                   freeze_prep_none = 0
   133                                   freeze_prep_palette0 = 2
   134                                   freeze_prep_palette1 = 4
   135                                   freeze_prep_palette2 = 6
   136                                   freeze_prep_palette3 = 8
   137                                   freeze_prep_stash_sd_buffer_and_regs = 10
   138                                   freeze_prep_thumbnail = 12
   139                                   freeze_prep_viciv = 14
   140                           	 freeze_prep_hyperregs = 16
   141                          
   142                                   d81_image_max_namelen = 32
   143                                   d81_image_flag_mounted = 1
   144                                   d81_image_flag_write_en = 4
   145                          
   146                                   syspart_error_readerror = $01
   147                                   syspart_error_badslotnum = $02
   148                                   syspart_error_badmagic = $42
   149                                   syspart_error_nosyspart = $ff

; ******** Source: src/hyppo/main.asm

; ******** Source: macros.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          
     7                          // Convenient macro for checkpoints. Uncomment the body to activate it
     8                          !macro Checkpoint .text {
     9                                  ;; jsr checkpoint
    10                                  ;; .byte 0
    11                                  ;; !ascii(.text)
    12                                  ;; .byte 0
    13                          }
    14                          
    15                          

; ******** Source: src/hyppo/main.asm

; ******** Source: machine.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          !addr reset_vector = $fffc
     7                          !addr irq_vector = $fffe
     8                          !addr nmi_vector = $fffa
     9                          
    10                                  ;; UART IO block (contains many other peripherals)
    11                          !addr uart65_irq_flag = $d606
    12                          !addr ascii_key_in = $d610
    13                          !addr buckykey_status = $d611
    14                          !addr mouse_detect_ctrl = $d61b
    15                          
    16                                  ;; Hypervisor regisger block $d640-$d67f
    17                          !addr hypervisor_a = $d640
    18                          !addr hypervisor_x = $d641
    19                          !addr hypervisor_y = $d642
    20                          !addr hypervisor_z = $d643
    21                          !addr hypervisor_b = $d644
    22                          !addr hypervisor_spl = $d645
    23                          !addr hypervisor_sph = $d646
    24                          !addr hypervisor_flags = $d647
    25                          !addr hypervisor_pcl = $d648
    26                          !addr hypervisor_pch = $d649
    27                          !addr hypervisor_maplolo = $d64a
    28                          !addr hypervisor_maplohi = $d64b
    29                          !addr hypervisor_maphilo = $d64c
    30                          !addr hypervisor_maphihi = $d64d
    31                          !addr hypervisor_maplomb = $d64e
    32                          !addr hypervisor_maphimb = $d64f
    33                          !addr hypervisor_cpuport00 = $d650
    34                          !addr hypervisor_cpuport01 = $d651
    35                          !addr hypervisor_iomode = $d652
    36                          !addr hypervisor_dmagic_srcmb = $d653
    37                          !addr hypervisor_dmagic_dstmb = $d654
    38                          !addr hypervisor_dmagic_list0 = $d655
    39                          !addr hypervisor_dmagic_list1 = $d656
    40                          !addr hypervisor_dmagic_list2 = $d657
    41                          !addr hypervisor_dmagic_list3 = $d658
    42                          !addr hypervisor_hardware_virtualisation = $d659
    43                          
    44                                  ;; d65a
    45                                  ;; d65b
    46                                  ;; d65c
    47                          
    48                          !addr hypervisor_vm_currentpage_lo = $d65d
    49                          !addr hypervisor_vm_currentpage_mid = $d65e
    50                          !addr hypervisor_vm_currentpage_hi = $d65f
    51                          
    52                          !addr hypervisor_vm_pagetable = $d660
    53                          !addr hypervisor_vm_pagetable0_logicalpage_lo = $d660
    54                          !addr hypervisor_vm_pagetable0_logicalpage_hi = $d661
    55                          !addr hypervisor_vm_pagetable0_physicalpage_lo = $d662
    56                          !addr hypervisor_vm_pagetable0_physicalpage_hi = $d663
    57                          !addr hypervisor_vm_pagetable1_logicalpage_lo = $d664
    58                          !addr hypervisor_vm_pagetable1_logicalpage_hi = $d665
    59                          !addr hypervisor_vm_pagetable1_physicalpage_lo = $d666
    60                          !addr hypervisor_vm_pagetable1_physicalpage_hi = $d667
    61                          !addr hypervisor_vm_pagetable2_logicalpage_lo = $d668
    62                          !addr hypervisor_vm_pagetable2_logicalpage_hi = $d669
    63                          !addr hypervisor_vm_pagetable2_physicalpage_lo = $d66a
    64                          !addr hypervisor_vm_pagetable2_physicalpage_hi = $d66b
    65                          !addr hypervisor_vm_pagetable3_logicalpage_lo = $d66c
    66                          !addr hypervisor_vm_pagetable3_logicalpage_hi = $d66d
    67                          !addr hypervisor_vm_pagetable3_physicalpage_lo = $d66e
    68                          !addr hypervisor_vm_pagetable3_physicalpage_hi = $d66f
    69                          
    70                          !addr hypervisor_georam_base_mb = $d670
    71                          !addr hypervsior_georam_block_mask = $d671
    72                          
    73                                  ;; d672 110 010
    74                          !addr hypervisor_secure_mode_flags = $d672
    75                          
    76                                  ;; d673
    77                                  ;; d674
    78                                  ;; d675
    79                                  ;; d676
    80                                  ;; d677
    81                                  ;; d678
    82                                  ;; d679
    83                                  ;; d67a
    84                                  ;; d67b
    85                          
    86                          !addr hypervisor_write_char_to_serial_monitor = $d67c
    87                          
    88                          !addr hypervisor_feature_enables = $d67d
    89                          !addr hypervisor_hickedup_flag = $d67e
    90                          !addr hypervisor_cartridge_flags = $d67e
    91                          !addr hypervisor_enterexit_trigger = $d67f
    92                          
    93                                  ;; Where sector buffer maps (over $DE00-$DFFF IO expansion space)
    94                          !addr sd_sectorbuffer = $DE00
    95                          !addr sd_ctrl = $d680
    96                          !addr sd_address_byte0 = $D681
    97                          !addr sd_address_byte1 = $D682
    98                          !addr sd_address_byte2 = $D683
    99                          !addr sd_address_byte3 = $D684
   100                          !addr sd_buffer_ctrl = $d689
   101                          !addr sd_f011_en = $d68b
   102                          !addr sd_fdc_select = $d6a1
   103                          !addr fdc_mfm_speed = $d6a2
   104                          !addr f011_flag_stomp  = $d6af
   105                          
   106                          !addr fpga_switches_low = $d6dc
   107                          !addr fpga_switches_high = $d6dd
   108                          
   109                                  ;; $D6Ex - Ethernet controller
   110                          !addr mac_addr_0 = $d6e9
   111                          !addr mac_addr_1 = $d6ea
   112                          !addr mac_addr_2 = $d6eb
   113                          !addr mac_addr_3 = $d6ec
   114                          !addr mac_addr_4 = $d6ed
   115                          !addr mac_addr_5 = $d6ee
   116                          
   117                                  ;; $D6Fx - mostly audio interfaces
   118                          !addr audiomix_addr = $d6f4
   119                          !addr audiomix_data = $d6f5
   120                          !addr audioamp_ctl = $d6fe
   121                          
   122                                  ;; Hardware 25(d) x 18(e) multiplier
   123                          !addr mult48_d0 = $d770
   124                          !addr mult48_d1 = $d771
   125                          !addr mult48_d2 = $d772
   126                          !addr mult48_d3 = $d773
   127                          !addr mult48_e0 = $d774
   128                          !addr mult48_e1 = $d775
   129                          !addr mult48_e2 = $d776
   130                          !addr mult48_e3 = $d777
   131                          !addr mult48_result0 = $d778
   132                          !addr mult48_result1 = $d779
   133                          !addr mult48_result2 = $d77a
   134                          !addr mult48_result3 = $d77b
   135                          !addr mult48_result4 = $d77c
   136                          !addr mult48_result5 = $d77d
   137                          !addr mult48_result6 = $d77e
   138                          !addr mult48_result7 = $d77f
   139                          
   140                          !addr viciv_magic = $d02f

; ******** Source: src/hyppo/main.asm
    31                          
    32                          !addr TrapEntryPoints_Start        = $8000
    33                          !addr RelocatedCPUVectors_Start    = $81f8
    34                          !addr Traps_Start                  = $8200
    35                          !addr DOSDiskTable_Start           = $bb00
    36                          !addr SysPartStructure_Start       = $bbc0
    37                          !addr DOSWorkArea_Start            = $bc00
    38                          !addr ProcessDescriptors_Start     = $bd00
    39                          !addr HyppoStack_Start             = $be00
    40                          !addr HyppoZP_Start                = $bf00
    41                          !addr Hyppo_End                    = $bfff
    42                          
    43                          ;; .file [name="../../bin/HICKUP.M65", type="bin", segments="TrapEntryPoints,RelocatedCPUVectors,Traps,DOSDiskTable,SysPartStructure,DOSWorkArea,ProcessDescriptors,HyppoStack,HyppoZP"] 
    44                          	!to "bin/HICKUP.M65", plain
    45                          
    46                          ;; .segmentdef TrapEntryPoints        [min=TrapEntryPoints_Start,     max=RelocatedCPUVectors_Start-1                         ]
    47                          ;; .segmentdef RelocatedCPUVectors    [min=RelocatedCPUVectors_Start, max=Traps_Start-1                                       ]
    48                          ;; .segmentdef Traps                  [min=Traps_Start,               max=DOSDiskTable_Start-1                                ]
    49                          ;; .segmentdef DOSDiskTable           [min=DOSDiskTable_Start,        max=SysPartStructure_Start-1,                           ]
    50                          ;; .segmentdef SysPartStructure       [min=SysPartStructure_Start,    max=DOSWorkArea_Start-1                                 ]
    51                          ;; .segmentdef DOSWorkArea            [min=DOSWorkArea_Start,         max=ProcessDescriptors_Start-1                          ]
    52                          ;; .segmentdef ProcessDescriptors     [min=ProcessDescriptors_Start,  max=HyppoStack_Start-1                                  ]
    53                          ;; .segmentdef HyppoStack             [min=HyppoStack_Start,          max=HyppoZP_Start-1,            fill, fillByte=$3e      ]
    54                          ;; .segmentdef HyppoZP                [min=HyppoZP_Start,             max=Hyppo_End,                  fill, fillByte=$3f      ]
    55                          ;; .segmentdef Data                   [min=Data_Start,                max=$ffff                                               ]
    56                          
    57                          ;;         .segment TrapEntryPoints
    58                                  * = TrapEntryPoints_Start
    59                          
    60                          ;; /*  -------------------------------------------------------------------
    61                          ;;     CPU Hypervisor Trap entry points.
    62                          ;;     64 x 4 byte entries for user-land traps.
    63                          ;;     some more x 4 byte entries for system traps (reset, page fault etc)
    64                          ;;     ---------------------------------------------------------------- */
    65                          
    66                          trap_entry_points:
    67                          
    68                                  ;; Traps $00-$07 (user callable)
    69                                  ;;
    70  8000 4c7b8b                     jmp dos_and_process_trap                ;; Trap #$00 (unsure what to call it)
    71  8003 ea                         eom                                     ;; refer: hyppo_dos.asm
    72  8004 4cd79c                     jmp memory_trap                         ;; Trap #$01
    73  8007 ea                         eom                                     ;; refer: hyppo_mem.asm
    74  8008 4cca85                     jmp syspart_trap                        ;; Trap #$02
    75  800b ea                         eom                                     ;; refer: hyppo_syspart.asm
    76  800c 4c64ad                     jmp serialwrite                         ;; Trap #$03
    77  800f ea                         eom                                     ;; refer serialwrite in this file
    78  8010 4c0082                     jmp nosuchtrap
    79  8013 ea                         eom
    80  8014 4c0082                     jmp nosuchtrap
    81  8017 ea                         eom
    82  8018 4c0082                     jmp nosuchtrap
    83  801b ea                         eom
    84  801c 4c0082                     jmp nosuchtrap
    85  801f ea                         eom
    86                          
    87                                  ;; Traps $08-$0F (user callable)
    88                                  ;;
    89  8020 4c0082                     jmp nosuchtrap
    90  8023 ea                         eom
    91  8024 4c0082                     jmp nosuchtrap
    92  8027 ea                         eom
    93  8028 4c0082                     jmp nosuchtrap
    94  802b ea                         eom
    95  802c 4c0082                     jmp nosuchtrap
    96  802f ea                         eom
    97  8030 4c0082                     jmp nosuchtrap
    98  8033 ea                         eom
    99  8034 4c0082                     jmp nosuchtrap
   100  8037 ea                         eom
   101  8038 4c0082                     jmp nosuchtrap
   102  803b ea                         eom
   103  803c 4c0082                     jmp nosuchtrap
   104  803f ea                         eom
   105                          
   106                                  ;; Traps $10-$17 (user callable)
   107                                  ;;
   108  8040 4c0082                     jmp nosuchtrap
   109  8043 ea                         eom
   110  8044 4ce09e                     jmp securemode_trap
   111  8047 ea                         eom
   112  8048 4ced9e                     jmp leave_securemode_trap
   113  804b ea                         eom
   114  804c 4c0082                     jmp nosuchtrap
   115  804f ea                         eom
   116  8050 4c0082                     jmp nosuchtrap
   117  8053 ea                         eom
   118  8054 4c0082                     jmp nosuchtrap
   119  8057 ea                         eom
   120  8058 4c0082                     jmp nosuchtrap
   121  805b ea                         eom
   122  805c 4c0082                     jmp nosuchtrap
   123  805f ea                         eom
   124                          
   125                                  ;; Traps $18-$1F (user callable)
   126                                  ;;
   127  8060 4c0082                     jmp nosuchtrap
   128  8063 ea                         eom
   129  8064 4c0082                     jmp nosuchtrap
   130  8067 ea                         eom
   131  8068 4c0082                     jmp nosuchtrap
   132  806b ea                         eom
   133  806c 4c0082                     jmp nosuchtrap
   134  806f ea                         eom
   135  8070 4c0082                     jmp nosuchtrap
   136  8073 ea                         eom
   137  8074 4c0082                     jmp nosuchtrap
   138  8077 ea                         eom
   139  8078 4c0082                     jmp nosuchtrap
   140  807b ea                         eom
   141  807c 4c0082                     jmp nosuchtrap
   142  807f ea                         eom
   143                          
   144                                  ;; Traps $20-$27 (user callable)
   145                                  ;;
   146  8080 4c0082                     jmp nosuchtrap
   147  8083 ea                         eom
   148  8084 4c0082                     jmp nosuchtrap
   149  8087 ea                         eom
   150  8088 4c0082                     jmp nosuchtrap
   151  808b ea                         eom
   152  808c 4c0082                     jmp nosuchtrap
   153  808f ea                         eom
   154  8090 4c0082                     jmp nosuchtrap
   155  8093 ea                         eom
   156  8094 4c0082                     jmp nosuchtrap
   157  8097 ea                         eom
   158  8098 4c0082                     jmp nosuchtrap
   159  809b ea                         eom
   160  809c 4c0082                     jmp nosuchtrap
   161  809f ea                         eom
   162                          
   163                                  ;; Traps $28-$2F (user callable)
   164                                  ;;
   165  80a0 4c0082                     jmp nosuchtrap
   166  80a3 ea                         eom
   167  80a4 4c0082                     jmp nosuchtrap
   168  80a7 ea                         eom
   169  80a8 4c0082                     jmp nosuchtrap
   170  80ab ea                         eom
   171  80ac 4c0082                     jmp nosuchtrap
   172  80af ea                         eom
   173  80b0 4c0082                     jmp nosuchtrap
   174  80b3 ea                         eom
   175  80b4 4c0082                     jmp nosuchtrap
   176  80b7 ea                         eom
   177  80b8 4c0082                     jmp nosuchtrap
   178  80bb ea                         eom
   179  80bc 4c0082                     jmp nosuchtrap
   180  80bf ea                         eom
   181                          
   182                                  ;; Traps $30-$37
   183                                  ;;
   184  80c0 4c0082                     jmp nosuchtrap
   185  80c3 ea                         eom
   186  80c4 4c0082                     jmp nosuchtrap
   187  80c7 ea                         eom
   188                          
   189  80c8 4ccc9e                     jmp protected_hardware_config           ;; Trap #$32 (Protected Hardware Configuration)
   190  80cb ea                         eom                                     ;; refer: hyppo_task
   191                          
   192                          
   193  80cc 4c0082                     jmp nosuchtrap
   194  80cf ea                         eom
   195  80d0 4c0082                     jmp nosuchtrap
   196  80d3 ea                         eom
   197  80d4 4c0082                     jmp nosuchtrap
   198  80d7 ea                         eom
   199  80d8 4c0082                     jmp nosuchtrap
   200  80db ea                         eom
   201  80dc 4c0082                     jmp nosuchtrap
   202  80df ea                         eom
   203                          
   204                                  ;; Traps $38-$3F (user callable)
   205                                  ;;
   206  80e0 4c0082                     jmp nosuchtrap
   207  80e3 ea                         eom
   208  80e4 4c0082                     jmp nosuchtrap
   209  80e7 ea                         eom
   210  80e8 4c0082                     jmp nosuchtrap
   211  80eb ea                         eom
   212  80ec 4c0082                     jmp nosuchtrap
   213  80ef ea                         eom
   214  80f0 4c0082                     jmp nosuchtrap
   215  80f3 ea                         eom
   216  80f4 4c0082                     jmp nosuchtrap
   217  80f7 ea                         eom
   218  80f8 4c0082                     jmp nosuchtrap
   219  80fb ea                         eom
   220                          	;; Writing to $D67F shall trap to freezer, as though user had triggered it.
   221  80fc 4c439e                     jmp restore_press_trap
   222  80ff ea                         eom
   223                          
   224                                  ;; Traps $40-$4F (reset, page fault and other system-generated traps)
   225  8100 4ccfa2                     jmp reset_entry                         ;; Trap #$40 (power on / reset)
   226  8103 ea                         eom                                     ;; refer: below in this file
   227                          
   228  8104 4c7f9c                     jmp page_fault                          ;; Trap #$41 (page fault)
   229  8107 ea                         eom                                     ;; refer: hyppo_mem
   230                          
   231  8108 4c439e                     jmp restore_press_trap                  ;; Trap #$42 (press RESTORE for 0.5 - 1.99 seconds)
   232  810b ea                         eom                                     ;; refer: hyppo_task "1000010" x"42"
   233                          
   234  810c 4cd59e                     jmp matrix_mode_toggle                  ;; Trap #$43 (C= + TAB combination)
   235  810f ea                         eom                                     ;; refer: hyppo_task
   236                          
   237  8110 4c37a0                     jmp f011_virtual_read                   ;; Trap #$44 (virtualised F011 sector read)
   238  8113 ea                         eom
   239                          
   240  8114 4c7aa0                     jmp f011_virtual_write                  ;; Trap #$45 (virtualised F011 sector write)
   241  8117 ea                         eom
   242                          
   243  8118 4c439e                     jmp unstable_illegal_opcode_trap        ;; Trap #$46 (6502 unstable illegal opcode)
   244  811b ea                         eom                                     
   245  811c 4c439e                     jmp kill_opcode_trap                    ;; Trap #$47 (6502 KIL instruction)
   246  811f ea                         eom
   247  8120 4c0082                     jmp nosuchtrap
   248  8123 ea                         eom
   249  8124 4c0082                     jmp nosuchtrap
   250  8127 ea                         eom
   251  8128 4c0082                     jmp nosuchtrap
   252  812b ea                         eom
   253  812c 4c0082                     jmp nosuchtrap
   254  812f ea                         eom
   255  8130 4c0082                     jmp nosuchtrap
   256  8133 ea                         eom
   257  8134 4c0082                     jmp nosuchtrap
   258  8137 ea                         eom
   259  8138 4c0082                     jmp nosuchtrap
   260  813b ea                         eom
   261  813c 4c0082                     jmp nosuchtrap
   262  813f ea                         eom
   263                          
   264                                  ;; Leave room for relocated cpu vectors below
   265                                  ;;
   266                                  ;; .segment RelocatedCPUVectors
   267                                  * = RelocatedCPUVectors_Start
   268                          
   269                                  ;; Then we have relocated CPU vectors at $81F8-$81FF
   270                                  ;; (which are 2-byte vectors for interrupts, not 4-byte
   271                                  ;; trap addresses).
   272                                  ;; These are used to catch interrupts in hypervisor mode
   273                                  ;; (although the need for them may have since been removed)
   274  81f8 cfa2                       !16 reset_entry    ;; unused vector
   275  81fa 0cab                       !16 hypervisor_nmi ;; NMI
   276  81fc cfa2                       !16 reset_entry    ;; RESET
   277  81fe 0cab                       !16 hypervisor_irq ;; IRQ
   278                          
   279                          	
   280                                  ;; .segment Traps
   281                                  * = Traps_Start
   282                          
   283                          ;; /*  -------------------------------------------------------------------
   284                          ;;     Hypervisor traps
   285                          ;;     ---------------------------------------------------------------- */
   286                          
   287                          ;; /*  -------------------------------------------------------------------
   288                          ;;     Illegal trap / trap sub-function handlers
   289                          
   290                          ;;     Traps are triggered by writing to $D640-$D67F
   291                          ;;     and trap to $8000+((address & $3F)*4) in the hypervisor
   292                          
   293                          ;;     Routine for unimplemented/reserved traps
   294                          ;;     (Consider replacing with trap to hypervisor error screen with option
   295                          ;;     to return?)
   296                          ;;     ---------------------------------------------------------------- */
   297                          nosuchtrap:
   298                          
   299                                  ;; Clear C flag for caller to indicate failure
   300                                  ;;
   301  8200 ad47d6                     lda hypervisor_flags
   302  8203 29fe                       and #$FE   ;; C flag is bit 0
   303  8205 8d47d6                     sta hypervisor_flags
   304                          
   305                                  ;; set A to $FF
   306                                  ;;
   307  8208 a9ff                       lda #$ff
   308  820a 8d40d6                     sta hypervisor_a
   309                          
   310                                  ;; return from hypervisor
   311                                  ;;
   312  820d 8d7fd6                     sta hypervisor_enterexit_trigger
   313                          
   314                          ;;         ========================
   315                          
   316                          return_from_trap_with_success:
   317                          
   318                                  ;; Return from trap with C flag clear to indicate success
   319                          
   320  8210 20db9f                     jsr sd_unmap_sectorbuffer
   321                          
   322                                  ;; set C flag for caller to indicate success
   323                                  ;;
   324  8213 ad47d6                     lda hypervisor_flags
   325  8216 0901                       ora #$01   ;; C flag is bit 0
   326  8218 8d47d6                     sta hypervisor_flags
   327                          
   328                                  +Checkpoint "return_from_trap_with_success"
   329                          
   330                          	;; DO NOT Clear A on return
   331                                  ;; (else traps can't return anything in A register)
   332                          	
   333                                  ;; return from hypervisor
   334  821b 8d7fd6                     sta hypervisor_enterexit_trigger
   335                          
   336                          ;;         ========================
   337                          
   338                          return_from_trap_with_failure:
   339                          
   340  821e 20db9f                     jsr sd_unmap_sectorbuffer
   341                          
   342                                  ;; report error in A
   343                                  ;;
   344  8221 8d40d6                     sta hypervisor_a
   345  8224 ad47d6                     lda hypervisor_flags
   346  8227 29fe                       and #$fe   ;; C flag is bit 0 (ie clear bit-0)
   347  8229 8d47d6                     sta hypervisor_flags
   348                          
   349                                  +Checkpoint "return_from_trap_with_failure"
   350                          
   351                                  ;; return from hypervisor
   352  822c 8d7fd6                     sta hypervisor_enterexit_trigger
   353                          
   354                          ;;         ========================
   355                          
   356                          invalid_subfunction:
   357                          
   358  822f 4c0082                     jmp nosuchtrap
   359                          
   360                          ;;         ========================
   361                          
   362                          ;; /*  -------------------------------------------------------------------
   363                          ;;     System Partition functions
   364                          ;;     ---------------------------------------------------------------- */
   365                          

; ******** Source: syspart.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          
     5                          ;;    MEGA65 System Partition functions
     6                          
     7                          ;;     The system partition (type = $41 = 65) holds several major data
     8                          ;;     areas:
     9                          
    10                          ;;     1. Header, that identifies the version and structure of the system
    11                          ;;        partition.
    12                          
    13                          ;;     2. Frozen programs for task switching.
    14                          ;;        (Some of which may be reserved by the operating system, e.g., for
    15                          ;;         alarms and other special purposes.)
    16                          
    17                          ;;     3. Installed services that can be requested via the Hypervisor.
    18                          ;;        These are internally just frozen programs with a valid service
    19                          ;;        description header.
    20                          
    21                          ;;     HEADER - First sector of partition
    22                          
    23                          ;;     $000-$00A "MEGA65SYS00" - Magic string and version indication
    24                          ;;     $010-$017 Start and size (in sectors) of frozen program area
    25                          ;;     $018-$01b Size of each frozen program slot
    26                          ;;     $01c-$01d Number of frozen program slots
    27                          ;;     $01e-$01f Number of sectors used for frozen program directory
    28                          ;;     $020-$027 Start and size (in sectors) or installed services
    29                          ;;     $028-$02b Size of each installed service slot
    30                          ;;     $02c-$02d Number of service slots
    31                          ;;     $02e-$02f Number of sectors used for slot directory
    32                          ;;     $030-$1ff RESERVED
    33                          
    34                          ;;     Basically we have two main areas in the system partition for frozen
    35                          ;;     programs, and for each we have a directory that allows for quick
    36                          ;;     scanning of the lists. Thee goal is to reduce the number of random
    37                          ;;     seeks (which still have a cost on SD cards, because commencing a
    38                          ;;     read is much slower than continuing one), and also the amount of
    39                          ;;     data required. To this end the directory entries consist of a 64
    40                          ;;     byte name field and a 64 byte reserved field, so that each is 128
    41                          ;;     bytes in total, allowing 4 per 512 byte sector.
    42                          
    43                          ;;     If the first byte of a directory is $00, then the entry is assumed
    44                          ;;     to be free.
    45                          ;;     ---------------------------------------------------------------- */
    46                          
    47                          onboarding_dmalist:	
    48                                  ;; MEGA65 Enhanced DMA options
    49  8232 0a                         !8 $0A      ;; Request format is F018A
    50  8233 8000                       !8 $80,$00  ;; Copy from $00xxxxx
    51  8235 8100                       !8 $81,$00  ;; Copy to $00xxxxx
    52                          
    53                          	;; Copy program down
    54  8237 00                         !8 $00 ;; no more options
    55                          	;; F018A DMA list
    56  8238 00                         !8 $00 ;; copy + not chained request
    57  8239 ff77                       !16 $77FF ;; size of copy 
    58  823b 0000                       !16 $0000 ;; starting addr 
    59  823d 04                         !8 $04   ;; of bank $5
    60  823e ff07                       !16 $07FF ;; destination address is $0801 - 2
    61  8240 00                         !8 $00   ;; of bank $0
    62  8241 0000                       !16 $0000 ;; modulo (unused)
    63                          
    64                          
    65                          	
    66                          launch_onboarding:
    67                          
    68                          	;; DMA copy the onboarding utility into place
    69  8243 a9ff                       lda #$ff
    70  8245 8d02d7                     sta $d702
    71                                  ;; lda #$ff
    72  8248 8d04d7                     sta $d704  ;; dma list is in top MB of address space
    73  824b a982                       lda #>onboarding_dmalist
    74  824d 8d01d7                     sta $d701
    75                                  ;; Trigger enhanced DMA
    76  8250 a932                       lda #<onboarding_dmalist
    77  8252 8d05d7                     sta $d705	
    78                          	
    79                          	;; Run util from in hypervisor context, similarly to how we run the flash menu
    80                          	;; this means the whole thing must be less than ~29KB in size, to not run over
    81                          	;; $8000-$BFFF where the hypervisor is mapped
    82  8255 4c2dac             	jmp run_util_in_hypervisor_context
    83                          	
    84                          syspart_open:
    85                                  ;; Open a system partition.
    86                                  ;; At this point, only syspart_start_sector and
    87                                  ;; syspart_size_in_sectors have been initialised.
    88                          
    89                                  ;; Read First sector of system partition
    90  8258 a203                       ldx #$03
    91  825a bdc0bb             spo1:   lda syspart_start_sector,x
    92  825d 9d81d6                     sta $d681,x
    93  8260 ca                         dex
    94  8261 10f7                       bpl spo1
    95                          
    96  8263 a901                       lda #syspart_error_readerror
    97  8265 8dfbbc                     sta syspart_error_code
    98  8268 20e49f                     jsr sd_readsector
    99  826b 907f                       bcc syspart_openerror
   100                          
   101                                  ;; Got First sector of system partition.
   102                          
   103                                  ;; Check magic string
   104  826d a942                       lda #syspart_error_badmagic
   105  826f 8dfbbc                     sta syspart_error_code
   106  8272 a20a                       ldx #10
   107  8274 bd00de             spo2:	lda $de00,x
   108  8277 dd3385                     cmp syspart_magic,x
   109  827a d070                       bne syspart_openerror
   110  827c ca                         dex
   111  827d 10f5                       bpl spo2
   112                          
   113  827f a900                       lda #$00
   114  8281 8dfbbc                     sta syspart_error_code
   115                          
   116                                  ;; Copy bytes from offset $10 - $2F into syspart_structure
   117                                  ;; XXX It is assumed that these fields are aligned with each other
   118  8284 a210                       ldx #$10
   119  8286 bd00de             spo3:	lda $de00,x
   120  8289 9dc0bb                     sta syspart_structure,x
   121  828c e8                         inx
   122  828d e030                       cpx #$30
   123  828f d0f5                       bne spo3
   124                          
   125                                  ;; Display info about # of freeze and service slots
   126  8291 a276                       ldx #<msg_syspart_info
   127  8293 a085                       ldy #>msg_syspart_info
   128  8295 2074a8                     jsr printmessage
   129  8298 a000                       ldy #$00
   130  829a abddbb                     ldz syspart_freeze_slot_count+1
   131  829d 20eda8                     jsr printhex
   132  82a0 abdcbb                     ldz syspart_freeze_slot_count+0
   133  82a3 20eda8                     jsr printhex
   134  82a6 abedbb                     ldz syspart_service_slot_count+1
   135  82a9 20eda8                     jsr printhex
   136  82ac abecbb                     ldz syspart_service_slot_count+0
   137  82af 20eda8                     jsr printhex
   138                          
   139                                  ;; Show size of freeze slots
   140  82b2 abdbbb                     ldz syspart_freeze_slot_size_in_sectors+3 
   141  82b5 20eda8                     jsr printhex
   142  82b8 abdabb                     ldz syspart_freeze_slot_size_in_sectors+2
   143  82bb 20eda8                     jsr printhex
   144  82be abd9bb                     ldz syspart_freeze_slot_size_in_sectors+1
   145  82c1 20eda8                     jsr printhex
   146  82c4 abd8bb                     ldz syspart_freeze_slot_size_in_sectors+0
   147  82c7 20eda8                     jsr printhex
   148                          
   149  82ca a901                       lda #$01
   150  82cc 8dfcbc                     sta syspart_present
   151                          
   152  82cf a262                       ldx #<msg_syspart_ok
   153  82d1 a085                       ldy #>msg_syspart_ok
   154  82d3 2074a8                     jsr printmessage
   155                          
   156  82d6 20f283                     jsr syspart_configsector_read
   157  82d9 ad0ede             	lda $de0e
   158  82dc 1021               	bpl do_launch_onboarding
   159                          no_onboarding:	
   160  82de 200284                     jsr syspart_configsector_apply
   161  82e1 b007                       bcs spo4
   162                          
   163  82e3 a29a                       ldx #<msg_syspart_config_invalid
   164  82e5 a085                       ldy #>msg_syspart_config_invalid
   165  82e7 2074a8                     jsr printmessage
   166                          
   167  82ea 38                 spo4:	sec
   168  82eb 60                         rts
   169                          	
   170                          syspart_openerror:
   171                          
   172                                  ;; Report error opening system partition
   173  82ec a23e                       ldx #<msg_syspart_open_error
   174  82ee a085                       ldy #>msg_syspart_open_error
   175  82f0 2074a8                     jsr printmessage
   176  82f3 a000                       ldy #$00
   177  82f5 abfbbc                     ldz syspart_error_code
   178  82f8 20eda8                     jsr printhex
   179  82fb a300                       ldz #$00
   180                          
   181  82fd 18                         clc
   182  82fe 60                         rts
   183                          
   184                          do_launch_onboarding:
   185                          	;; Only try onboarding on first boot
   186  82ff ad19a3             	lda first_boot_flag_instruction
   187  8302 c94c               	cmp #$4c
   188  8304 f0d8               	beq no_onboarding
   189  8306 4c4382             	jmp launch_onboarding
   190                          	
   191                                  ;; XXX These should return success/failure indication
   192                          syspart_configsector_read_trap:
   193  8309 20f283                     jsr syspart_configsector_read
   194  830c 8d7fd6                     sta hypervisor_enterexit_trigger
   195                          
   196                          syspart_configsector_write_trap:
   197  830f 20f883                     jsr syspart_configsector_write
   198  8312 8d7fd6                     sta hypervisor_enterexit_trigger
   199                          
   200                          syspart_configsector_set_trap:
   201  8315 20e583                     jsr syspart_configsector_set
   202  8318 8d7fd6                     sta hypervisor_enterexit_trigger
   203                          
   204                          syspart_configsector_apply_trap:
   205  831b 200284                     jsr syspart_configsector_apply
   206  831e 8d7fd6                     sta hypervisor_enterexit_trigger
   207                          
   208                          syspart_unfreeze_from_slot_trap:
   209  8321 ae41d6                     ldx hypervisor_x
   210  8324 205283                     jsr syspart_locate_freezeslot
   211  8327 207386                     jsr unfreeze_load_from_sdcard_immediate
   212                          	;;  Make sure we resume a frozen program on the same raster line as
   213                          	;; it entered the freezer.  This might need a bit of tuning to get
   214                          	;; perfect, but it should already be accurate to within one raster line.
   215                          
   216                          	
   217  832a a9ff               	lda #$ff
   218                          @unfreezesyncwait:
   219  832c cd12d0             	cmp $d012
   220  832f d0fb               	bne @unfreezesyncwait
   221                          	;; Clear any pending raster interrupt, to avoid problems.
   222  8331 ce19d0             	dec $d019 
   223  8334 8d7fd6                     sta hypervisor_enterexit_trigger
   224                          
   225                          syspart_get_slot_count_trap:
   226  8337 aedcbb                     ldx syspart_freeze_slot_count+0
   227  833a 8e41d6                     stx hypervisor_x
   228  833d acddbb                     ldy syspart_freeze_slot_count+1
   229  8340 8c42d6                     sty hypervisor_y
   230  8343 4c1082                     jmp return_from_trap_with_success
   231                          
   232                          syspart_locate_freezeslot_trap:
   233  8346 ae41d6                     ldx hypervisor_x
   234  8349 ac42d6                     ldy hypervisor_y
   235  834c 205283                     jsr syspart_locate_freezeslot
   236  834f 8d7fd6                     sta hypervisor_enterexit_trigger
   237                          
   238                          syspart_locate_freezeslot:
   239                                  ;; Get the first sector of a given freeze slot
   240                                  ;; X = low byte of slot #
   241                                  ;; Y = high byte of slot #
   242                          
   243  8352 da                         phx
   244  8353 5a                         phy
   245                          
   246                                  ;; Check that we have a system partition
   247  8354 adfcbc                     lda syspart_present
   248  8357 d007                       bne splf1
   249  8359 a9ff                       lda #syspart_error_nosyspart
   250  835b 8dfbbc                     sta syspart_error_code
   251  835e 18                         clc
   252  835f 60                         rts
   253                          splf1:
   254                                  ;; Check that freeze slot number is not invalid
   255  8360 ccddbb                     cpy syspart_freeze_slot_count+1
   256  8363 f002                       beq sc1
   257  8365 900e                       bcc slotnumok
   258  8367 ecdcbb             sc1:	cpx syspart_freeze_slot_count+0
   259  836a f002                       beq slotbad
   260  836c 9007                       bcc slotnumok
   261                          slotbad:
   262                                  ;; Report error status for out of bounds slot number
   263  836e a902                       lda #syspart_error_badslotnum
   264  8370 8dfbbc                     sta syspart_error_code
   265  8373 18                         clc
   266  8374 60                         rts
   267                          
   268                          slotnumok:
   269                          
   270  8375 20a783                     jsr syspart_locate_freezeslot_0
   271                                  ;; Now add freeze slot size x (YYXX) bytes
   272                                  ;; Use hardware multiplier to work out slot address
   273                          
   274                                  ;; Set multiplicant inputs to multiplier
   275                          
   276                                  ;; XXX - Works only with SD HC cards!
   277                          
   278                                  ;; SDHC, so unit is sectors, and so is just a case of copying the bytes
   279                                  ;; Start by shifting down by 1 byte = /256
   280  8378 a203                       ldx #$03
   281  837a bdd8bb             splf4b:	lda syspart_freeze_slot_size_in_sectors,x
   282  837d 9d70d7                     sta mult48_d0,x
   283  8380 ca                         dex
   284  8381 10f7                       bpl splf4b
   285                          
   286                          @multiplierSet:
   287                          
   288  8383 fa                         plx
   289  8384 8e74d7                     stx mult48_e0
   290  8387 7a                         ply
   291  8388 8c75d7                     sty mult48_e1
   292  838b a900                       lda #$00
   293  838d 8d76d7                     sta mult48_e2
   294  8390 8d77d7                     sta mult48_e3
   295                          
   296                                  ;; Read out answer, and add it to slot 0 address
   297  8393 a200                       ldx #0
   298  8395 a003                       ldy #3
   299  8397 18                         clc
   300  8398 bd78d7             splf3:	lda mult48_result0,x
   301  839b 7d81d6                     adc $d681,x
   302  839e 9d81d6                     sta $d681,x
   303  83a1 e8                         inx
   304  83a2 88                         dey
   305  83a3 10f3                       bpl splf3
   306                          
   307  83a5 38                         sec
   308  83a6 60                         rts
   309                          
   310                          syspart_locate_freezeslot_0:
   311                                  ;; Freeze slot #0 starts at:
   312                                  ;;   syspart_start_sector + syspart_freeze_area_start
   313                                  ;; + syspart_freeze_directory_sector_count
   314  83a7 adc0bb                     lda syspart_start_sector+0
   315  83aa 18                         clc
   316  83ab 6dd0bb                     adc syspart_freeze_area_start+0
   317  83ae 8d81d6                     sta $d681
   318  83b1 a201                       ldx #1
   319  83b3 bdc0bb             splf2:	lda syspart_start_sector,x
   320  83b6 7dd0bb                     adc syspart_freeze_area_start,x
   321  83b9 9d81d6                     sta $d681,x
   322  83bc e8                         inx
   323  83bd e004                       cpx #4
   324  83bf d0f2                       bne splf2
   325  83c1 ad81d6                     lda $d681
   326  83c4 18                         clc
   327  83c5 6ddebb                     adc syspart_freeze_directory_sector_count+0
   328  83c8 8d81d6                     sta $d681
   329  83cb ad82d6                     lda $d682
   330  83ce 6ddfbb                     adc syspart_freeze_directory_sector_count+1
   331  83d1 8d82d6                     sta $d682
   332  83d4 ad83d6                     lda $d683
   333  83d7 6900                       adc #0
   334  83d9 8d83d6                     sta $d683
   335  83dc ad84d6                     lda $d684
   336  83df 6900                       adc #0
   337  83e1 8d84d6                     sta $d684
   338                          
   339  83e4 60                         rts
   340                          
   341                          
   342                          syspart_configsector_set:
   343                          	;; So, the config sector USED to live in the system partition.
   344                          	;; But that causes a few problems:
   345                          	;; 1. You need a system partition, just to be able to pick PAL or NTSC on start.
   346                          	;; 2. The utility menu now, for good reason, appears before trying to probe any
   347                          	;;    SD cards. This means that the configure programme couldn't work out the
   348                          	;;    correct sector to work on.
   349                          	;; As a result, we now just officially have the config sector live in sector 1.
   350  83e5 a203                       ldx #3
   351  83e7 a900               	lda #0
   352                          spcr1:	;; lda syspart_start_sector,x
   353  83e9 9d81d6                     sta $d681,x
   354  83ec ca                         dex
   355  83ed 10fa                       bpl spcr1
   356  83ef 4c24a0                     jmp sd_inc_sectornumber
   357                          
   358                          syspart_configsector_read:
   359  83f2 20e583                     jsr syspart_configsector_set
   360  83f5 4ce49f                     jmp sd_readsector
   361                          
   362                          syspart_configsector_write:
   363  83f8 20e583                     jsr syspart_configsector_set
   364  83fb 20559f             	jsr write_non_mbr_sector
   365  83fe 38                         sec
   366  83ff 60                         rts
   367                          
   368                          syspart_config_invalid:
   369  8400 18                         clc
   370  8401 60                         rts
   371                          	
   372                          syspart_configsector_apply:
   373                                  ;; Check version
   374  8402 ad00de                     lda $de00
   375  8405 c901                       cmp #$01
   376  8407 d0f7                       bne syspart_config_invalid
   377  8409 ad01de                     lda $de01
   378  840c c901                       cmp #$01
   379  840e d0f0                       bne syspart_config_invalid
   380                          
   381                                  ;; Set DMAgic revision
   382  8410 ad20de                     lda $de20
   383  8413 8d03d7                     sta $d703
   384                          
   385                          	;; Set $D054 options
   386                          	;; (eg scanline emulation ($20) and horizontal blur filter ($08))
   387  8416 a928               	lda #$28
   388  8418 1c54d0             	trb $d054
   389  841b 2d21de             	and $de21
   390  841e 0c54d0             	tsb $d054
   391                          
   392                                  ;; Set PAL/NTSC mode (keeping $D058 value)
   393  8421 ae58d0                     ldx $d058
   394  8424 ad6fd0                     lda $d06f
   395  8427 293f                       and #$3f
   396  8429 8d6fd0                     sta $d06f
   397  842c ad02de                     lda $de02
   398  842f 29c0                       and #$c0
   399  8431 0d6fd0                     ora $d06f
   400  8434 8d6fd0                     sta $d06f
   401                          	;; And also write it into the instruction that sets the display mode on reset
   402  8437 8d98a6             	sta pal_ntsc_minus_1+1
   403  843a 8e58d0                     stx $d058
   404                          	
   405                                  ;; Set audio and related options
   406  843d ad0dde             	lda $de0d
   407  8440 8d1ad6             	sta $d61a
   408                          
   409                          	;; Trigger onboarding menu or not
   410                          	;; (activated elsewhere)
   411                          	// $de0e bit 7
   412                          	
   413                          	;; Super SFX cartridge emulation
   414  8443 ad0cde             	lda $de0c
   415  8446 a300               	ldz #$00
   416  8448 a907               	lda #$07
   417  844a 8d13bf             	sta zptempv32+3
   418  844d a2fe               	ldx #$fe
   419  844f 8e12bf             	stx zptempv32+2
   420  8452 e8                 	inx
   421  8453 8e11bf             	stx zptempv32+1
   422  8456 8e10bf             	stx zptempv32+0
   423  8459 ea9210             	sta [<zptempv32],z	
   424                          
   425                          	;; Audio amplifier control
   426  845c ad03de                     lda $de03
   427  845f 2901                       and #$01
   428  8461 8dfed6                     sta audioamp_ctl
   429                          
   430                          	;; Stereo flags
   431  8464 ad03de                     lda $de03
   432  8467 2940                       and #$40
   433  8469 f006                       beq is_stereo
   434  846b 20eba0                     jsr audio_set_mono
   435  846e 4c8184                     jmp done_audio
   436                          is_stereo:
   437  8471 ad03de                     lda $de03
   438  8474 2920                       and #$20
   439  8476 d006                       bne is_mirrored
   440  8478 2066a1                     jsr audio_set_stereo
   441  847b 4c8184                     jmp done_audio
   442                          is_mirrored:
   443  847e 2070a1                     jsr audio_set_stereomirrored
   444                          done_audio:
   445                          
   446                                  ;; Set F011 to use 3.5 drive or disk images
   447  8481 ad04de                     lda $de04
   448  8484 8da1d6                     sta sd_fdc_select
   449                          
   450                                  ;; Enable/disable Amiga mouse support (emulates 1351 mouse)
   451  8487 ad05de                     lda $de05
   452  848a 8d1bd6                     sta mouse_detect_ctrl
   453                          
   454                          	;; Enable/disable experimental long filename support
   455  848d a94c               	lda #$4c 		; Disable LFN support by default
   456  848f 8da394             	sta disable_lfn_byte
   457  8492 ad0fde             	lda $de0f
   458  8495 1005               	bpl @nolfn
   459                          	;; Diable jump that disables LFN support 
   460  8497 a92c               	lda #$2c 		; BIT $xxxx opcode
   461  8499 8da394             	sta disable_lfn_byte
   462                          @nolfn:
   463                                  ;; Copy MAC address
   464  849c a205                       ldx #$05
   465                          maccopy:
   466  849e bd06de                     lda $de06, x
   467  84a1 9de9d6                     sta mac_addr_0, x
   468  84a4 ca                         dex
   469  84a5 10f7                       bpl maccopy
   470                          
   471                                  ;; Copy default disk image name
   472  84a7 ad10de                     lda $de10
   473  84aa f00b                       beq nodiskname
   474  84ac a20f                       ldx #$0f
   475                          disknamecopy:
   476  84ae bd10de                     lda	$de10, x
   477  84b1 9d9cb2                     sta	txt_MEGA65D81, x
   478  84b4 ca                         dex
   479  84b5 10f7                       bpl	disknamecopy
   480                          nodiskname:
   481  84b7 38                         sec
   482  84b8 60                         rts
   483                          
   484                          syspart_dmagic_autoset_trap:
   485  84b9 20bf84                     jsr syspart_dmagic_autoset
   486  84bc 8d7fd6                     sta hypervisor_enterexit_trigger
   487                          
   488                          syspart_dmagic_autoset:
   489                                  ;; Set DMAgic revision based on ROM version
   490                                  ;; $20017-$2001D = "V9xxxxx" version string.
   491                                  ;; If it is 900000 - 910522, then DMAgic revA, else revB
   492  84bf a916                       lda #$16
   493  84c1 8d10bf                     sta zptempv32
   494  84c4 a900                       lda #$00
   495  84c6 8d11bf                     sta zptempv32+1
   496  84c9 8d13bf                     sta zptempv32+3
   497  84cc a902                       lda #$02
   498  84ce 8d12bf                     sta zptempv32+2
   499  84d1 a300                       ldz #$00
   500  84d3 eab210                     lda [<zptempv32],z
   501  84d6 c956                       cmp #$56
   502  84d8 f001                       beq @hasC65ROMVersion
   503  84da 60                         rts
   504                          @hasC65ROMVersion:
   505                                  ;; Check first digit is 9
   506  84db 1b                         inz
   507  84dc eab210                     lda [<zptempv32],z
   508  84df c939                       cmp #$39
   509  84e1 d034                       bne @useDMAgicRevB
   510                                  ;; check if second digit is 0, if so, revA
   511  84e3 1b                         inz
   512  84e4 eab210                     lda [<zptempv32],z
   513  84e7 c930                       cmp #$30
   514  84e9 f03a                       beq @useDMAgicRevA
   515                                  ;; check if second digit != 1, if so, revB
   516  84eb c931                       cmp #$31
   517  84ed d028                       bne @useDMAgicRevB
   518                                  ;; check 3rd digit is 0, if not, revB
   519  84ef 1b                         inz
   520  84f0 eab210                     lda [<zptempv32],z
   521  84f3 c930                       cmp #$30
   522  84f5 d020                       bne @useDMAgicRevB
   523                                  ;; check 4th digit is >5, if so, revB
   524  84f7 1b                         inz
   525  84f8 eab210                     lda [<zptempv32],z
   526  84fb c936                       cmp #$36
   527  84fd b018                       bcs @useDMAgicRevB
   528                                  ;; check 4th digit is <5, if so, revA
   529  84ff c935                       cmp #$35
   530  8501 9022                       bcc @useDMAgicRevA
   531                                  ;; check 5th digit <=> 2
   532  8503 1b                         inz
   533  8504 eab210                     lda [<zptempv32],z
   534  8507 c932                       cmp #$32
   535  8509 901a                       bcc @useDMAgicRevA
   536  850b c933                       cmp #$33
   537  850d b008                       bcs @useDMAgicRevB
   538                                  ;; check 6th digit <3
   539  850f 1b                         inz
   540  8510 eab210                     lda [<zptempv32],z
   541  8513 c933                       cmp #$33
   542  8515 900e                       bcc @useDMAgicRevA
   543                          @useDMAgicRevB:
   544  8517 a300                       ldz #$00
   545  8519 a901                       lda #$01
   546  851b 0c03d7                     tsb $d703
   547                          
   548  851e a246                       ldx #<msg_dmagicb
   549  8520 a0b2                       ldy #>msg_dmagicb
   550  8522 4c74a8                     jmp printmessage
   551                          
   552                          @useDMAgicRevA:
   553  8525 a300                       ldz #$00
   554  8527 a901                       lda #$01
   555  8529 1c03d7                     trb $d703
   556                          
   557  852c a234                       ldx #<msg_dmagica
   558  852e a0b2                       ldy #>msg_dmagica
   559  8530 4c74a8                     jmp printmessage
   560                          
   561                          
   562                                  ;; Magic string that identifies a MEGA65 system partition
   563                          syspart_magic:
   564  8533 4d45474136355359...        !text "MEGA65SYS00"
   565                          msg_syspart_open_error:
   566  853e 53595354454d2050...        !text "SYSTEM PARTITION ERROR: (ERRNO: $$)"
   567  8561 00                         !8 0
   568                          msg_syspart_ok:
   569  8562 53595354454d2050...        !text "SYSTEM PARTITION OK"
   570  8575 00                         !8 0
   571                          msg_syspart_info:
   572  8576 5359533a20242424...        !text "SYS: $$$$ FRZ + $$$$ SVC X $$$$$$$$"
   573  8599 00                         !8 0
   574                          msg_syspart_config_invalid:
   575  859a 5359535041525420...        !text "SYSPART CONFIG INVALID. PLEASE SET."
   576  85bd 00                         !8 0
   577                          
   578                          txt_ONBOARDM65:
   579  85be 4f4e424f4152442e...	!text "ONBOARD.M65"
   580  85c9 00                 	!8 0
   581                          	
   582                          syspart_trap:
   583  85ca 78                         sei
   584  85cb d8                         cld
   585  85cc 29fe                       and #$fe
   586  85ce aa                         tax
   587  85cf 7cd285                     jmp (syspart_trap_table,x)
   588                          
   589                          syspart_trap_table:
   590                                  ;; $00-$0E
   591  85d2 0983                       !16 syspart_configsector_read_trap
   592  85d4 0f83                       !16 syspart_configsector_write_trap
   593  85d6 1b83                       !16 syspart_configsector_apply_trap
   594  85d8 1583                       !16 syspart_configsector_set_trap
   595  85da b984                       !16 syspart_dmagic_autoset_trap
   596  85dc 2f82                       !16 invalid_subfunction
   597  85de 2f82                       !16 invalid_subfunction
   598  85e0 2f82                       !16 invalid_subfunction
   599                          
   600                                  ;; $10-$1E
   601  85e2 4683                       !16 syspart_locate_freezeslot_trap
   602  85e4 2183                       !16 syspart_unfreeze_from_slot_trap
   603  85e6 c38a                       !16 syspart_read_freeze_region_list_trap
   604  85e8 3783                       !16 syspart_get_slot_count_trap
   605  85ea 2f82                       !16 invalid_subfunction
   606  85ec 2f82                       !16 invalid_subfunction
   607  85ee 2f82                       !16 invalid_subfunction
   608  85f0 2f82                       !16 invalid_subfunction
   609                          
   610                                  ;; $20-$2E
   611  85f2 2f82                       !16 invalid_subfunction
   612  85f4 2f82                       !16 invalid_subfunction
   613  85f6 2f82                       !16 invalid_subfunction
   614  85f8 2f82                       !16 invalid_subfunction
   615  85fa 2f82                       !16 invalid_subfunction
   616  85fc 2f82                       !16 invalid_subfunction
   617  85fe 2f82                       !16 invalid_subfunction
   618  8600 2f82                       !16 invalid_subfunction
   619                          
   620                                  ;; $30-$3E
   621  8602 2f82                       !16 invalid_subfunction
   622  8604 2f82                       !16 invalid_subfunction
   623  8606 2f82                       !16 invalid_subfunction
   624  8608 2f82                       !16 invalid_subfunction
   625  860a 2f82                       !16 invalid_subfunction
   626  860c 2f82                       !16 invalid_subfunction
   627  860e 2f82                       !16 invalid_subfunction
   628  8610 2f82                       !16 invalid_subfunction
   629                          
   630                                  ;; $40-$4E
   631  8612 2f82                       !16 invalid_subfunction
   632  8614 2f82                       !16 invalid_subfunction
   633  8616 2f82                       !16 invalid_subfunction
   634  8618 2f82                       !16 invalid_subfunction
   635  861a 2f82                       !16 invalid_subfunction
   636  861c 2f82                       !16 invalid_subfunction
   637  861e 2f82                       !16 invalid_subfunction
   638  8620 2f82                       !16 invalid_subfunction
   639                          
   640                                  ;; $50-$5E
   641  8622 2f82                       !16 invalid_subfunction
   642  8624 2f82                       !16 invalid_subfunction
   643  8626 2f82                       !16 invalid_subfunction
   644  8628 2f82                       !16 invalid_subfunction
   645  862a 2f82                       !16 invalid_subfunction
   646  862c 2f82                       !16 invalid_subfunction
   647  862e 2f82                       !16 invalid_subfunction
   648  8630 2f82                       !16 invalid_subfunction
   649                          
   650                                  ;; $60-$6E
   651  8632 2f82                       !16 invalid_subfunction
   652  8634 2f82                       !16 invalid_subfunction
   653  8636 2f82                       !16 invalid_subfunction
   654  8638 2f82                       !16 invalid_subfunction
   655  863a 2f82                       !16 invalid_subfunction
   656  863c 2f82                       !16 invalid_subfunction
   657  863e 2f82                       !16 invalid_subfunction
   658  8640 2f82                       !16 invalid_subfunction
   659                          
   660                                  ;; $70-$7E
   661  8642 2f82                       !16 invalid_subfunction
   662  8644 2f82                       !16 invalid_subfunction
   663  8646 2f82                       !16 invalid_subfunction
   664  8648 2f82                       !16 invalid_subfunction
   665  864a 2f82                       !16 invalid_subfunction
   666  864c 2f82                       !16 invalid_subfunction
   667  864e 2f82                       !16 invalid_subfunction
   668  8650 2f82                       !16 invalid_subfunction

; ******** Source: src/hyppo/main.asm
   366                          	
   367                          
   368                          ;; /*  -------------------------------------------------------------------
   369                          ;;     Freeze/Unfreeze functions
   370                          ;;     ---------------------------------------------------------------- */

; ******** Source: freeze.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          freeze_to_slot:
     7                                  ;; Freeze current running process to the specified slot
     8                          
     9                                  ;; Slot in XXYY
    10                          
    11  8652 205283                     jsr syspart_locate_freezeslot
    12  8655 b001                       bcs freeze_save_to_sdcard_immediate
    13  8657 60                         rts
    14                          
    15                          freeze_save_to_sdcard_immediate:
    16                          
    17                                  ;; Save the current process to the SD card. $D681-4 are expected to
    18                                  ;; already be pointing to the first sector of the freeze slot
    19                          
    20                                  ;; Stash SD card registers to scratch area
    21                                  ;; (also stashed $D070 which gets mushed by palette saving)
    22  8658 20558a                     jsr copy_sdcard_regs_to_scratch
    23                          
    24                                  ;; Save current SD card sector buffer contents
    25  865b 201087                     jsr freeze_write_first_sector_and_wait
    26                          
    27                                  ;; Save each region in the list
    28  865e a200                       ldx #$00
    29                          freeze_next_region:
    30  8660 207d87                     jsr freeze_save_region
    31  8663 8a                         txa
    32  8664 18                         clc
    33  8665 6908                       adc #$08
    34  8667 aa                         tax
    35  8668 bde68a                     lda freeze_mem_list+7,x
    36  866b c9ff                       cmp #$ff
    37  866d d0f1                       bne freeze_next_region
    38                          
    39  866f 206c87                     jsr freeze_end_multi_block_write
    40                          
    41  8672 60                         rts
    42                          
    43                          unfreeze_load_from_sdcard_immediate:
    44                          
    45                                  ;; Restore a frozen process from the SD card. $D681-4 are expecxted to
    46                                  ;; already be pointing to the first sector of the freeze slot
    47                          
    48                                  ;; Skip the first sector of the frozen program which is the
    49                                  ;; contents of the SD card sector buffer prior to freezing.
    50                                  ;; (We will load it in as the very last thing)
    51  8673 2024a0                     jsr sd_inc_sectornumber
    52                          
    53                                  ;; Save each region in the list
    54  8676 a200                       ldx #$00
    55                          
    56                          unfreeze_next_region:
    57                          
    58                                  ;; Require SHIFT press and release between every sector for debug
    59                          ;;         jsr wait_on_shift_key
    60                          
    61                                  ;; Not sure why this delay is necessary, but it is.
    62                                  ;; Maybe restoring SD card IO registers causes it to go busy for a while?
    63  8678 206f9f                     jsr sd_wait_for_ready_reset_if_required
    64                          
    65  867b 207388                     jsr unfreeze_load_region
    66                          
    67                                  ;; Re-enable M65 IO in case we wrote over the key register during the region unfreeze
    68  867e a947                       lda #$47
    69  8680 8d2fd0                     sta $d02f
    70  8683 a953                       lda #$53
    71  8685 8d2fd0                     sta $d02f
    72                          
    73  8688 8a                         txa
    74  8689 18                         clc
    75  868a 6908                       adc #$08
    76  868c aa                         tax
    77  868d bde68a                     lda freeze_mem_list+7,x
    78  8690 c9ff                       cmp #$ff
    79  8692 d0e4                       bne unfreeze_next_region
    80                          
    81                                  ;; Fix mounted D81, in case it has moved on the SD card since program was frozen
    82                          
    83                                  ;; 1. Detach
    84  8694 207699                     jsr dos_d81detach
    85                          
    86                                  ;; 2. Copy filename for image 0
    87  8697 ae13bd                     ldx currenttask_d81_image0_namelen
    88  869a f027                       beq noD81Image0ToRemount
    89  869c a200                       ldx #0
    90  869e bd15bd             copy:   lda currenttask_d81_image0_name,x
    91  86a1 9d67bc                     sta dos_requested_filename,x
    92  86a4 e8                         inx
    93  86a5 ec13bd                     cpx currenttask_d81_image0_namelen
    94  86a8 d0f4                       bne copy
    95  86aa a900                       lda #0
    96  86ac 9d67bc                     sta dos_requested_filename,x
    97  86af 8e66bc                     stx dos_requested_filename_len
    98                          
    99                                  ;; 3. Remember write-enable flag
   100  86b2 ad11bd                     lda currenttask_d81_image0_flags
   101  86b5 2904                       and #d81_image_flag_write_en
   102  86b7 48                         pha
   103                          
   104                                  ;; 4. Try to reattach it
   105  86b8 208799                     jsr dos_d81attach0
   106                          
   107                                  ;; 5. Mark write enabled if required
   108  86bb 68                         pla
   109  86bc c900                       cmp #$00
   110  86be f003                       beq noD81Image0ToRemount
   111                          
   112                                  ;; 6. Re-enable write access on the disk image
   113  86c0 20af8f                     jsr dos_d81write_en
   114                          
   115                          noD81Image0ToRemount:
   116                          
   117                                  ;; 2. Copy filename for image 0
   118  86c3 ae14bd                     ldx currenttask_d81_image1_namelen
   119  86c6 f027                       beq noD81Image1ToRemount
   120  86c8 a200                       ldx #0
   121  86ca bd35bd             copy1:  lda currenttask_d81_image1_name,x
   122  86cd 9d67bc                     sta dos_requested_filename,x
   123  86d0 e8                         inx
   124  86d1 ec14bd                     cpx currenttask_d81_image1_namelen
   125  86d4 d0f4                       bne copy1
   126  86d6 a900                       lda #0
   127  86d8 9d67bc                     sta dos_requested_filename,x
   128  86db 8e66bc                     stx dos_requested_filename_len
   129                          
   130                                  ;; 3. Remember write-enable flag
   131  86de ad12bd                     lda currenttask_d81_image1_flags
   132  86e1 2904                       and #d81_image_flag_write_en
   133  86e3 48                         pha
   134                          
   135                                  ;; 4. Try to reattach it
   136  86e4 20ed99                     jsr dos_d81attach1
   137                          
   138                                  ;; 5. Mark write enabled if required
   139  86e7 68                         pla
   140  86e8 c900                       cmp #$00
   141  86ea f003                       beq noD81Image1ToRemount
   142                          
   143                                  ;; 6. Re-enable write access on the disk image
   144  86ec 20af8f                     jsr dos_d81write_en
   145                          
   146                          noD81Image1ToRemount:
   147                          	
   148                                  ;; Turn SID volume registers back on, as those registers
   149                                  ;; cannot be frozen.
   150  86ef a90f                       lda #$0f
   151  86f1 8d18d4                     sta $D418
   152  86f4 8d38d4             	sta $D438
   153  86f7 8d58d4                     sta $D458
   154  86fa 8d78d4             	sta $D478
   155                          
   156  86fd 60                         rts
   157                          
   158                          unfreeze_read_sector_and_wait:
   159                          
   160                          
   161                          ;;         jsr debug_show_sector
   162                          
   163                          @retryRead:
   164  86fe 206f9f                     jsr sd_wait_for_ready_reset_if_required
   165                          
   166  8701 a902                       lda #$02
   167  8703 8d80d6                     sta $d680
   168                          
   169  8706 20669f                     jsr sd_wait_for_ready
   170  8709 90f3                       bcc @retryRead
   171                          
   172                                  ;; Read succeeded, so advance sector number, and return
   173                                  ;; success
   174                          
   175                                  ;; Increment freeze slot sector number
   176  870b 2024a0                     jsr sd_inc_sectornumber
   177                          
   178  870e 38                         sec
   179                          
   180  870f 60                         rts
   181                          
   182                          freeze_write_first_sector_and_wait:
   183                          
   184  8710 ee20d0                     inc $d020
   185                          
   186                                  ;; Require SHIFT press and release between every sector for debug
   187                          ;;         jsr wait_on_shift_key
   188                          
   189  8713 a900                       lda #$00
   190  8715 8d7b87                     sta freeze_write_tries+0
   191  8718 8d7c87                     sta freeze_write_tries+1
   192                          
   193                          @retryWrite1:
   194                          
   195  871b 206f9f                     jsr sd_wait_for_ready_reset_if_required
   196                          
   197                                  ;; Trigger the write of the first sector of a multi-sector write
   198  871e 204f9f             	jsr sd_open_write_gate
   199  8721 a904                       lda #$04
   200  8723 8d80d6                     sta $d680
   201                          
   202  8726 20669f                     jsr sd_wait_for_ready
   203  8729 4c3687                     jmp @wroteOk1
   204                          
   205  872c ee7b87                     inc freeze_write_tries+0
   206  872f d0ea                       bne @retryWrite1
   207  8731 ee7c87                     inc freeze_write_tries+1
   208  8734 d0e5                       bne @retryWrite1
   209                          
   210                          @wroteOk1:
   211  8736 ce20d0                     dec $d020
   212                          
   213                                  ;; Increment freeze slot sector number
   214  8739 2024a0                     jsr sd_inc_sectornumber
   215                          
   216  873c 38                         sec
   217  873d 60                         rts
   218                          
   219                          freeze_write_sector_and_wait:
   220                          
   221  873e ee20d0                     inc $d020
   222                          
   223                                  ;; Require SHIFT press and release between every sector for debug
   224                          ;;         jsr wait_on_shift_key
   225                          
   226  8741 a900                       lda #$00
   227  8743 8d7b87                     sta freeze_write_tries+0
   228  8746 8d7c87                     sta freeze_write_tries+1
   229                          
   230                          @retryWrite:
   231                          
   232  8749 206f9f                     jsr sd_wait_for_ready_reset_if_required
   233                          
   234                                  ;; Trigger the write (subsequent sector of multi-sector write)
   235  874c 204f9f             	jsr sd_open_write_gate
   236  874f a905                       lda #$05
   237  8751 8d80d6                     sta $d680
   238                          
   239  8754 20669f                     jsr sd_wait_for_ready
   240  8757 4c6487                     jmp @wroteOk
   241                          
   242  875a ee7b87                     inc freeze_write_tries+0
   243  875d d0ea                       bne @retryWrite
   244  875f ee7c87                     inc freeze_write_tries+1
   245  8762 d0e5                       bne @retryWrite
   246                          
   247                          @wroteOk:
   248  8764 ce20d0                     dec $d020
   249                          
   250                                  ;; Increment freeze slot sector number
   251  8767 2024a0                     jsr sd_inc_sectornumber
   252                          
   253  876a 38                         sec
   254  876b 60                         rts
   255                          
   256                          freeze_end_multi_block_write:
   257  876c 20669f                     jsr sd_wait_for_ready
   258  876f 204f9f             	jsr sd_open_write_gate
   259  8772 a906                       lda #$06
   260  8774 8d80d6                     sta $d680
   261  8777 20669f                     jsr sd_wait_for_ready
   262  877a 60                         rts
   263                          
   264                          freeze_write_tries:
   265  877b 0000                       !16 $0
   266                          
   267                          freeze_save_region:
   268                                  ;; X = offset into freeze_mem_list
   269                          
   270                                  ;; Check if end of list, if so, do nothing and return
   271  877d bde68a                     lda freeze_mem_list+7,x
   272  8780 c9ff                       cmp #$ff
   273  8782 d001                       bne fsr1
   274  8784 60                         rts
   275                          fsr1:
   276                          
   277                                  ;; Call setup routine to make any special preparations
   278                                  ;; (eg copying data out of non-memory mapped areas, or collecting
   279                                  ;; various groups of data together)
   280  8785 da                         phx
   281  8786 aa                         tax
   282  8787 203389                     jsr dispatch_freeze_prep
   283  878a fa                         plx
   284                          
   285                                  ;; Get address of region
   286  878b bddf8a                     lda freeze_mem_list+0,x
   287  878e 8d888a                     sta freeze_region_dmalist_source_start+0
   288  8791 bde08a                     lda freeze_mem_list+1,x
   289  8794 8d898a                     sta freeze_region_dmalist_source_start+1
   290                          
   291                                  ;; Source address is 32-bit, and we need bits 20-27
   292                                  ;; for the source MB (upper 4 bits are ignored)
   293  8797 bde18a                     lda freeze_mem_list+2,x
   294  879a 4a                         lsr
   295  879b 4a                         lsr
   296  879c 4a                         lsr
   297  879d 4a                         lsr
   298  879e 8d818a                     sta freeze_region_dmalist_source_mb
   299  87a1 bde28a                     lda freeze_mem_list+3,x
   300  87a4 0a                         asl
   301  87a5 0a                         asl
   302  87a6 0a                         asl
   303  87a7 0a                         asl
   304  87a8 0d818a                     ora freeze_region_dmalist_source_mb
   305  87ab 8d818a                     sta freeze_region_dmalist_source_mb
   306                          
   307                                  ;; Bank is a bit fiddly: Lower nybl is bits
   308                                  ;; 16-19 of address.  Then we have to add the IO flag
   309                                  ;; The IO flag is used if the source MB value = $FF.
   310                                  ;; However, because we use 28-bit addresses for everything
   311                                  ;; the IO bit should be zero, as should the other special
   312                                  ;; bits.
   313                          
   314  87ae bde18a                     lda freeze_mem_list+2,X
   315  87b1 290f                       and #$0f
   316  87b3 8d8a8a                     sta freeze_region_dmalist_source_bank
   317                          
   318                                  ;; At this point, we have the DMA list source setup.
   319                          
   320                                  ;; Point the destination to the SD card direct job
   321                                  ;; sector buffer ($FFD6E00).
   322  87b6 a900                       lda #$00
   323  87b8 8d8b8a                     sta freeze_region_dmalist_dest_start+0
   324  87bb a96e                       lda #$6E
   325  87bd 8d8c8a                     sta freeze_region_dmalist_dest_start+1
   326  87c0 a90d                       lda #$0D
   327  87c2 8d8d8a                     sta freeze_region_dmalist_dest_bank
   328  87c5 a9ff                       lda #$ff
   329  87c7 8d838a                     sta freeze_region_dmalist_dest_mb
   330                          
   331                                  ;; Now DMA source and destination addresses have been set
   332                                  ;; We now need to step through the region $200 bytes at a
   333                                  ;; time, until there are no bytes left.
   334                                  ;; If the length is $0000 initially, then it means 64KB.
   335                                  ;; The tricky bit is for regions <$200 bytes long, as we need
   336                                  ;; to make sure we don't copy more than we should (it could
   337                                  ;; be from Hypervisor memory, for example, or to some
   338                                  ;; important IO registers, such as the Hypervisor enter/exit
   339                                  ;; trap).
   340                          
   341                                  ;; Get length of region
   342  87ca bde38a                     lda freeze_mem_list+4,x
   343  87cd 8d778b                     sta freeze_dma_length_remaining+0
   344  87d0 bde48a                     lda freeze_mem_list+5,x
   345  87d3 8d788b                     sta freeze_dma_length_remaining+1
   346  87d6 bde58a                     lda freeze_mem_list+6,x
   347  87d9 297f                       and #$7f                              ;; mask out bottom 7 bits, since bit 7 indicates if a region should be skipped in unfreezing
   348  87db 8d798b                     sta freeze_dma_length_remaining+2
   349                          
   350                          freeze_region_dma_loop:
   351                          
   352  87de 205188                     jsr set_dma_length_based_on_freeze_dma_length_remaining
   353                          
   354                                  ;; Then make sure that there are still bytes to copy.
   355                                  ;; If not, then we are done with this block.
   356  87e1 0d778b                     ora freeze_dma_length_remaining+0
   357  87e4 0d798b                     ora freeze_dma_length_remaining+2
   358  87e7 f03c                       beq freeze_region_dma_done
   359                          
   360                          @freezeExecuteDMA:
   361                          
   362                                  ;; Execute DMA job
   363  87e9 a9ff                       lda #$ff
   364  87eb 8d02d7                     sta $d702
   365  87ee 8d04d7                     sta $d704
   366  87f1 a98a                       lda #>freeze_region_dmalist
   367  87f3 8d01d7                     sta $d701
   368  87f6 a97f                       lda #<freeze_region_dmalist
   369  87f8 8d05d7                     sta $d705
   370                          
   371                                  ;; Write SD-card direct sector buffer to freeze slot
   372                                  ;; Flash a different colour while actually writing sector
   373  87fb ee20d0                     inc $d020
   374                          
   375  87fe 203e87                     jsr freeze_write_sector_and_wait
   376                          
   377  8801 ce20d0                     dec $d020
   378                          
   379                                  ;; Check if remaining length is negative or zero. If so, stop
   380  8804 202688                     jsr is_freeze_dma_length_remaining_zero_or_negative
   381  8807 f01c                       beq freeze_region_dma_done
   382                          
   383                                  ;; DMA count is set, subtract from remaining length
   384  8809 203588                     jsr subtract_freeze_dma_size_from_length_remaining
   385                          
   386  880c 202688                     jsr is_freeze_dma_length_remaining_zero_or_negative
   387  880f f014                       beq freeze_region_dma_done
   388                          
   389                                  ;; advance source address
   390  8811 ad898a                     lda freeze_region_dmalist_source_start+1
   391  8814 18                         clc
   392  8815 6902                       adc #$02
   393  8817 8d898a                     sta freeze_region_dmalist_source_start+1
   394  881a ad8a8a                     lda freeze_region_dmalist_source_bank
   395  881d 6900                       adc #$00
   396  881f 8d8a8a                     sta freeze_region_dmalist_source_bank
   397                          
   398  8822 4cde87                     jmp freeze_region_dma_loop
   399                          
   400                          freeze_region_dma_done:
   401  8825 60                         rts
   402                          
   403                          is_freeze_dma_length_remaining_zero_or_negative:
   404  8826 ad798b                     lda freeze_dma_length_remaining+2
   405  8829 3007                       bmi @negativeSize
   406  882b 0d788b                     ora freeze_dma_length_remaining+1
   407  882e 0d778b                     ora freeze_dma_length_remaining+0
   408  8831 60                         rts
   409                          @negativeSize:
   410  8832 a900                       lda #$00
   411  8834 60                         rts
   412                          
   413                          subtract_freeze_dma_size_from_length_remaining:
   414  8835 38                         sec
   415  8836 ad778b                     lda freeze_dma_length_remaining+0
   416  8839 ed868a                     sbc freeze_region_dmalist_count+0
   417  883c 8d778b                     sta freeze_dma_length_remaining+0
   418  883f ad788b                     lda freeze_dma_length_remaining+1
   419  8842 ed878a                     sbc freeze_region_dmalist_count+1
   420  8845 8d788b                     sta freeze_dma_length_remaining+1
   421  8848 ad798b                     lda freeze_dma_length_remaining+2
   422  884b e900                       sbc #$00
   423  884d 8d798b                     sta freeze_dma_length_remaining+2
   424  8850 60                         rts
   425                          
   426                          set_dma_length_based_on_freeze_dma_length_remaining:
   427  8851 ad788b                     lda freeze_dma_length_remaining+1
   428  8854 29fe                       and #$fe
   429  8856 0d798b                     ora freeze_dma_length_remaining+2
   430  8859 f00b                       beq @isPartialSector
   431                          
   432                                  ;; At least a whole sector remains
   433  885b a900                       lda #$00
   434  885d 8d868a                     sta freeze_region_dmalist_count+0
   435  8860 a902                       lda #$02
   436  8862 8d878a                     sta freeze_region_dmalist_count+1
   437  8865 60                         rts
   438                          
   439                          @isPartialSector:
   440                                  ;; Set DMA size to remaining bytes
   441  8866 ad778b                     lda freeze_dma_length_remaining+0
   442  8869 8d868a                     sta freeze_region_dmalist_count+0
   443  886c ad788b                     lda freeze_dma_length_remaining+1
   444  886f 8d878a                     sta freeze_region_dmalist_count+1
   445  8872 60                         rts
   446                          
   447                          unfreeze_load_region:
   448                                  ;; X = offset into freeze_mem_list
   449                          
   450                                  ;; Check if end of list, if so, do nothing and return
   451  8873 bde68a                     lda freeze_mem_list+7,x
   452  8876 c9ff                       cmp #$ff
   453  8878 f004                       beq @dontUnfreeze
   454                                  ;; If it is the thumbnail, also don't unfreeze, as it doesn't make sense,
   455                                  ;; and the way we freeze the thumbnail means unfreezing would corrupt $1000-$1FFF
   456  887a c50c                       cmp freeze_prep_thumbnail
   457  887c d001                       bne @doUnfreeze
   458                          @dontUnfreeze:
   459  887e 60                         rts
   460                          @doUnfreeze:
   461                          
   462                                  ;; Call setup routine to make any special preparations
   463                                  ;; (eg copying data out of non-memory mapped areas, or collecting
   464                                  ;; various groups of data together)
   465  887f da                         phx
   466  8880 aa                         tax
   467  8881 203689                     jsr dispatch_unfreeze_prep
   468  8884 fa                         plx
   469                          
   470                                  ;; Get address of region
   471  8885 bddf8a                     lda freeze_mem_list+0,x
   472  8888 8d8b8a                     sta freeze_region_dmalist_dest_start+0
   473  888b bde08a                     lda freeze_mem_list+1,x
   474  888e 8d8c8a                     sta freeze_region_dmalist_dest_start+1
   475                          
   476                                  ;; Source address is 32-bit, and we need bits 20-27
   477                                  ;; for the source MB (upper 4 bits are ignored)
   478  8891 bde18a                     lda freeze_mem_list+2,x
   479  8894 4a                         lsr
   480  8895 4a                         lsr
   481  8896 4a                         lsr
   482  8897 4a                         lsr
   483  8898 8d838a                     sta freeze_region_dmalist_dest_mb
   484  889b bde28a                     lda freeze_mem_list+3,x
   485  889e 0a                         asl
   486  889f 0a                         asl
   487  88a0 0a                         asl
   488  88a1 0a                         asl
   489  88a2 0d838a                     ora freeze_region_dmalist_dest_mb
   490  88a5 8d838a                     sta freeze_region_dmalist_dest_mb
   491                          
   492                                  ;; Bank is a bit fiddly: Lower nybl is bits
   493                                  ;; 16-19 of address.  Then we have to add the IO flag
   494                                  ;; The IO flag is used if the source MB value = $FF.
   495                                  ;; However, because we use 28-bit addresses for everything
   496                                  ;; the IO bit should be zero, as should the other special
   497                                  ;; bits.
   498                          
   499  88a8 bde18a                     lda freeze_mem_list+2,X
   500  88ab 290f                       and #$0f
   501  88ad 8d8d8a                     sta freeze_region_dmalist_dest_bank
   502                          
   503                                  ;; At this point, we have the DMA list source setup.
   504                          
   505                                  ;; Point the source to the SD card direct job
   506                                  ;; sector buffer ($FFD6E00).
   507  88b0 a900                       lda #$00
   508  88b2 8d888a                     sta freeze_region_dmalist_source_start+0
   509  88b5 a96e                       lda #$6E
   510  88b7 8d898a                     sta freeze_region_dmalist_source_start+1
   511  88ba a90d                       lda #$0D
   512  88bc 8d8a8a                     sta freeze_region_dmalist_source_bank
   513  88bf a9ff                       lda #$ff
   514  88c1 8d818a                     sta freeze_region_dmalist_source_mb
   515                          
   516                                  ;; Now DMA source and destination addresses have been set
   517                                  ;; We now need to step through the region $200 bytes at a
   518                                  ;; time, until there are no bytes left.
   519                                  ;; If the length is $0000 initially, then it means 64KB.
   520                                  ;; The tricky bit is for regions <$200 bytes long, as we need
   521                                  ;; to make sure we don't copy more than we should (it could
   522                                  ;; be from Hypervisor memory, for example, or to some
   523                                  ;; important IO registers, such as the Hypervisor enter/exit
   524                                  ;; trap).
   525                          
   526                                  ;; Get length of region
   527  88c4 bde38a                     lda freeze_mem_list+4,x
   528  88c7 8d778b                     sta freeze_dma_length_remaining+0
   529  88ca bde48a                     lda freeze_mem_list+5,x
   530  88cd 8d788b                     sta freeze_dma_length_remaining+1
   531  88d0 bde58a                     lda freeze_mem_list+6,x
   532  88d3 8d7a8b                     sta unfreeze_skip
   533  88d6 297f                       and #$7f                              ;; mask out bottom 7 bits, since bit 7 indicates if a region should be skipped in unfreezing
   534  88d8 8d798b                     sta freeze_dma_length_remaining+2
   535                          
   536                          unfreeze_region_dma_loop:
   537                          
   538                                  ;; Write SD-card direct sector buffer to freeze slot
   539                                  ;; Flash a different colour while actually writing sector
   540  88db ee20d0                     inc $d020
   541                          
   542  88de 20fe86                     jsr unfreeze_read_sector_and_wait
   543                          
   544  88e1 ce20d0                     dec $d020
   545                          
   546  88e4 205188                     jsr set_dma_length_based_on_freeze_dma_length_remaining
   547                          
   548                                  ;; Then make sure that there are still bytes to copy.
   549                                  ;; If not, then we are done with this block.
   550  88e7 0d778b                     ora freeze_dma_length_remaining+0
   551  88ea 0d798b                     ora freeze_dma_length_remaining+2
   552  88ed f038                       beq unfreeze_region_dma_done
   553                          
   554  88ef 2c7a8b                     bit unfreeze_skip
   555  88f2 3012                       bmi @skipDMA
   556                          
   557                          @unfreezeExecuteDMA:
   558                                  ;; Execute DMA job
   559  88f4 a9ff                       lda #$ff
   560  88f6 8d02d7                     sta $d702
   561  88f9 8d04d7                     sta $d704
   562  88fc a98a                       lda #>freeze_region_dmalist
   563  88fe 8d01d7                     sta $d701
   564  8901 a97f                       lda #<freeze_region_dmalist
   565  8903 8d05d7                     sta $d705
   566                          
   567                          @skipDMA:
   568                                  ;; Check if remaining length is negative or zero. If so, stop
   569  8906 202688                     jsr is_freeze_dma_length_remaining_zero_or_negative
   570  8909 f01c                       beq unfreeze_region_dma_done
   571                          
   572                                  ;; DMA count is set, subtract from remaining length
   573  890b 203588                     jsr subtract_freeze_dma_size_from_length_remaining
   574                          
   575  890e 202688                     jsr is_freeze_dma_length_remaining_zero_or_negative
   576  8911 f014                       beq unfreeze_region_dma_done
   577                          
   578                                  ;; advance destination address
   579  8913 ad8c8a                     lda freeze_region_dmalist_dest_start+1
   580  8916 18                         clc
   581  8917 6902                       adc #$02
   582  8919 8d8c8a                     sta freeze_region_dmalist_dest_start+1
   583  891c ad8d8a                     lda freeze_region_dmalist_dest_bank
   584  891f 6900                       adc #$00
   585  8921 8d8d8a                     sta freeze_region_dmalist_dest_bank
   586                          
   587  8924 4cdb88                     jmp unfreeze_region_dma_loop
   588                          
   589                          unfreeze_region_dma_done:
   590                          
   591                                  ;; Call postfix routine for the region just loaded
   592  8927 da                         phx
   593  8928 48                 	pha
   594                          	
   595  8929 bde68a                     lda freeze_mem_list+7,x
   596  892c aa                         tax
   597  892d 203989                     jsr dispatch_unfreeze_post
   598                          
   599  8930 68                 	pla
   600  8931 fa                         plx
   601                          	
   602                          
   603  8932 60                         rts
   604                          
   605                          
   606                          dispatch_freeze_prep:
   607                                  ;; X = Freeze prep ID byte
   608                                  ;; (all of which are even, so that we can use an indirect
   609                                  ;; X indexed jump table to efficiently do the dispatch)
   610                          
   611  8933 7c068a                     jmp (freeze_prep_jump_table,x)
   612                          
   613                          dispatch_unfreeze_prep:
   614                                  ;; X = Freeze prep ID byte
   615                                  ;; (all of which are even, so that we can use an indirect
   616                                  ;; X indexed jump table to efficiently do the dispatch)
   617                          
   618  8936 7c168a                     jmp (unfreeze_prep_jump_table,x)
   619                          
   620                          dispatch_unfreeze_post:
   621                                  ;; X = Freeze prep ID byte
   622                                  ;; (all of which are even, so that we can use an indirect
   623                                  ;; X indexed jump table to efficiently do the dispatch)
   624                          
   625  8939 7c288a                     jmp (unfreeze_post_jump_table,x)
   626                          
   627                          do_unfreeze_post_restore_sd_buffer_and_regs:
   628                                  ;; Copy back the registers from $D680 - $D70F *excluding*
   629                                  ;; $D700 and $D705 (which would trigger a DMA)
   630                                  ;; $D680 (which could trigger an SD read or write)
   631                          
   632                                  ;; The data should have been put for us at $FFD6200-$FFD628F
   633                                  ;; The contents of the SD sector buffer for restoration should
   634                                  ;; be at $FFD6000-$FFD61FF
   635                          
   636  893c a900                       lda #<$6200
   637  893e 8500                       sta <dos_scratch_vector+0
   638  8940 a962                       lda #>$6200
   639  8942 8501                       sta <dos_scratch_vector+1
   640  8944 a9fd                       lda #<$0FFD
   641  8946 8502                       sta <dos_scratch_vector+2
   642  8948 a90f                       lda #>$0FFD
   643  894a 8503                       sta <dos_scratch_vector+3
   644                          
   645                                  ;; Copy $D680 - $D70F, which covers both regions of interest
   646  894c a38f                       ldz #$8F
   647  894e 6b                 @zz2:   tza
   648  894f aa                         tax
   649  8950 eab200                     lda [<dos_scratch_vector],z
   650  8953 e000                       cpx #$00  ;; $D680
   651  8955 f00b                       beq @dontWriteHotRegister
   652  8957 e080                       cpx #$80  ;; $D700
   653  8959 f007                       beq @dontWriteHotRegister
   654  895b e085                       cpx #$85  ;; $D705
   655  895d f003                       beq @dontWriteHotRegister
   656                          
   657  895f 9d80d6                     sta $d680,x
   658                          
   659                          @dontWriteHotRegister:
   660  8962 ca                         dex
   661  8963 3b                         dez
   662  8964 c2ff                       cpz #$ff
   663  8966 d0e6                       bne @zz2
   664  8968 a300                       ldz #$00
   665                          
   666                          do_unfreeze_prep_restore_sd_buffer_and_regs:
   667                                  ;; But there is nothing we need to do in preparation to unfreezing
   668                                  ;; such a region, so just tie it to an RTS
   669  896a 60                         rts
   670                          
   671                          do_freeze_prep_thumbnail:
   672                                  ;; Read the 4KB hardware thumbnail from $D640 and write it to $1000-$1FFF
   673                                  ;; We can in principle use a fixed-source DMA to do this.
   674                          
   675                                  ;; set up our pointer for writing
   676  896b a900                       lda #<$1000
   677  896d 8500                       sta <dos_scratch_vector+0
   678  896f a910                       lda #>$1000
   679  8971 8501                       sta <dos_scratch_vector+1
   680  8973 a000                       ldy #$00
   681  8975 a210                       ldx #$10
   682                          
   683                                  ;; Set pointer to $FFD2640 to access thumbnail generator.
   684                                  ;; This is because the thumbnail generator lives at $D640 which overlaps
   685                                  ;; with the hypervisor trap registers when in hypervisor mode.
   686                                  ;; We previously had the thumbnail generator mapped at $D63x, but that
   687                                  ;; was causing CS glitching that was messing up reading from the C65 UART
   688                                  ;; registers.  So now we have moved it to this magic space
   689  8977 a940                       lda #<$2640
   690  8979 8d10bf                     sta zptempv32+0
   691  897c a926                       lda #>$2640
   692  897e 8d11bf                     sta zptempv32+1
   693  8981 a9fd                       lda #<$0FFD
   694  8983 8d12bf                     sta zptempv32+2
   695  8986 a90f                       lda #>$0FFD
   696  8988 8d13bf                     sta zptempv32+3
   697                          
   698                                  ;; First, make sure the read pointer is at the start of the thumbnail
   699  898b a300                       ldz #$00
   700                                  ;; Then advance pointer address to $D641
   701  898d eab210                     lda [<zptempv32],z
   702  8990 a941                       lda #<$2641
   703  8992 8d10bf                     sta zptempv32+0
   704                          
   705                          @thumbfetchloop:
   706  8995 eab210                     lda [<zptempv32],z
   707  8998 9100                       sta (<dos_scratch_vector),y
   708  899a c8                         iny
   709  899b d0f8                       bne @thumbfetchloop
   710  899d e601                       inc <dos_scratch_vector+1
   711  899f ca                         dex
   712  89a0 d0f3                       bne @thumbfetchloop
   713                          
   714  89a2 60                         rts
   715                          
   716                          do_freeze_prep_stash_sd_buffer_and_regs:
   717                                  ;; Stash the SD and DMAgic registers we use to actually save
   718                                  ;; the machine state.
   719                                  ;; DMAgic registers have to get copied without using DMA, so
   720                                  ;; that we don't corrupt the registers.
   721  89a3 a900                       lda #<$6200
   722  89a5 8500                       sta <dos_scratch_vector+0
   723  89a7 a962                       lda #>$6200
   724  89a9 8501                       sta <dos_scratch_vector+1
   725  89ab a9fd                       lda #<$0ffd
   726  89ad 8502                       sta <dos_scratch_vector+2
   727  89af a90f                       lda #>$0ffd
   728  89b1 8503                       sta <dos_scratch_vector+3
   729                          
   730                                  ;; Copy $D680 - $D70F, which covers both regions of interest
   731  89b3 a38f                       ldz #$8f
   732  89b5 6b                 @zz:    tza
   733  89b6 aa                         tax
   734  89b7 bd80d6                     lda $d680,x
   735  89ba ea9200                     sta [<dos_scratch_vector],z
   736  89bd ca                         dex
   737  89be 3b                         dez
   738  89bf c2ff                       cpz #$ff
   739  89c1 d0f2                       bne @zz
   740  89c3 a300                       ldz #$00
   741                          
   742                                  ;; Now DMA copy the SD sector buffer from $FFD6e00 to
   743                                  ;; $FFD6000.
   744                                  ;; XXX Replace this (And the above!) with a fixed DMA list. It will be shorter and faster
   745  89c5 a9ff                       lda #$ff
   746  89c7 8d818a                     sta freeze_region_dmalist_source_mb
   747  89ca 8d838a                     sta freeze_region_dmalist_dest_mb
   748  89cd a98d                       lda #$8d
   749  89cf 8d8a8a                     sta freeze_region_dmalist_source_bank
   750  89d2 8d8d8a                     sta freeze_region_dmalist_dest_bank
   751  89d5 a900                       lda #<$6e00
   752  89d7 8d888a                     sta freeze_region_dmalist_source_start+0
   753  89da a96e                       lda #>$6e00
   754  89dc 8d898a                     sta freeze_region_dmalist_source_start+1
   755  89df a900                       lda #<$6000
   756  89e1 8d8b8a                     sta freeze_region_dmalist_dest_start+0
   757  89e4 a960                       lda #>$6000
   758  89e6 8d8c8a                     sta freeze_region_dmalist_dest_start+1
   759  89e9 a900                       lda #<$0200
   760  89eb 8d868a                     sta freeze_region_dmalist_count+0
   761  89ee a902                       lda #>$0200
   762  89f0 8d878a                     sta freeze_region_dmalist_count+1
   763                          
   764                                  ;; Execute DMA job
   765  89f3 a9ff                       lda #$ff
   766  89f5 8d02d7                     sta $d702
   767  89f8 8d04d7                     sta $d704
   768  89fb a98a                       lda #>freeze_region_dmalist
   769  89fd 8d01d7                     sta $d701
   770  8a00 a97f                       lda #<freeze_region_dmalist
   771  8a02 8d05d7                     sta $d705
   772                          
   773                          do_freeze_prep_none:
   774  8a05 60                         rts
   775                          
   776                          ;; Jump table of routines to be called before saving specific regions
   777                          freeze_prep_jump_table:
   778  8a06 058a                       !16 do_freeze_prep_none
   779  8a08 908a                       !16 do_freeze_prep_palette_select
   780  8a0a 908a                       !16 do_freeze_prep_palette_select
   781  8a0c 908a                       !16 do_freeze_prep_palette_select
   782  8a0e 908a                       !16 do_freeze_prep_palette_select
   783  8a10 a389                       !16 do_freeze_prep_stash_sd_buffer_and_regs
   784  8a12 6b89                       !16 do_freeze_prep_thumbnail
   785  8a14 788a                       !16 do_freeze_prep_viciv
   786                          
   787                          ;; Jump table of routines to be called before restoring specific regions
   788                          ;; (the same region list is used for freeze and unfreeze, so the jump
   789                          ;; tables for unfreezing mirror those used during freezing. The only difference
   790                          ;; is we require two sets of jump tables for unfreezing, as sometimes we have
   791                          ;; to prepare the memory map before restoring, and sometimes we have to move
   792                          ;; the restored data to the correct place in memory after restoration.
   793                          unfreeze_prep_jump_table:
   794                                  ;; SD card buffer and regs get restored in post routine
   795  8a16 3a8a                       !16 do_unfreeze_prep_none
   796  8a18 908a                       !16 do_unfreeze_prep_palette_select
   797  8a1a 908a                       !16 do_unfreeze_prep_palette_select
   798  8a1c 908a                       !16 do_unfreeze_prep_palette_select
   799  8a1e 908a                       !16 do_unfreeze_prep_palette_select
   800                                  ;; SD card buffer and regs get restored in post routine
   801  8a20 3a8a                       !16 do_unfreeze_prep_none
   802                                  ;; thumbnail doesn't get restored at all
   803  8a22 3a8a                       !16 do_unfreeze_prep_none
   804                                  ;; VIC-IV regs need nothing special before unfreezing
   805  8a24 3a8a                       !16 do_unfreeze_prep_none
   806                          	;; No prior preparation required for handling hyperregs
   807  8a26 3a8a               	!16 do_unfreeze_prep_none
   808                          
   809                          unfreeze_post_jump_table:
   810  8a28 3b8a                       !16 do_unfreeze_post_scratch_to_sdcard_regs
   811  8a2a 3a8a                       !16 do_unfreeze_post_none
   812  8a2c 3a8a                       !16 do_unfreeze_post_none
   813  8a2e 3a8a                       !16 do_unfreeze_post_none
   814  8a30 3a8a                       !16 do_unfreeze_post_none
   815                                  ;; Don't actually restore the SD card registers until the very end.
   816                                  ;; For a start, it will result in totally the wrong SD sector address being there
   817                                  ;; when we go to read the next sector!
   818                          ;;         !16 do_unfreeze_post_restore_sd_buffer_and_regs
   819  8a32 3a8a                       !16 do_unfreeze_post_none
   820  8a34 3a8a                       !16 do_unfreeze_post_none
   821  8a36 3a8a                       !16 do_unfreeze_post_none
   822                          	;; No prior preparation required for handling hyperregs
   823  8a38 3c8a               	!16 do_unfreeze_post_hyperregs
   824                          
   825                          do_unfreeze_prep_none:
   826                          do_unfreeze_post_none:
   827                                  ;; This just needs to have an RTS, so we use one from the end of this
   828                                  ;; routine.
   829  8a3a 60                         rts
   830                          
   831                          do_unfreeze_post_scratch_to_sdcard_regs:
   832                                  ;; XXX - Not implemented
   833  8a3b 60                         rts
   834                          
   835                          do_unfreeze_post_hyperregs:	
   836                          	;; XXX For reasons unknown, the DMA restoration of the hypervisor registers
   837                          	;; messes up $D651.
   838                          	;; At the point that this fix-up routine is called, the SD card sector
   839                          	;; containing the data is available, and so we can simply fix the problem
   840                          	;; by copying $ffd6e11 to $ffd3651
   841                          	;; If problems later occur for other regs in this range, we can just
   842                          	;; make a 32-bit ZP indirect copy loop, since there is some claim that
   843                          	;; DMA writing to those registers is problematic.
   844                          
   845                                  ;; that we don't corrupt the registers.
   846  8a3c a911                       lda #<$6e11
   847  8a3e 8500                       sta <dos_scratch_vector+0
   848  8a40 a96e                       lda #>$6e11
   849  8a42 8501                       sta <dos_scratch_vector+1
   850  8a44 a9fd                       lda #<$0ffd
   851  8a46 8502                       sta <dos_scratch_vector+2
   852  8a48 a90f                       lda #>$0ffd
   853  8a4a 8503                       sta <dos_scratch_vector+3
   854                          
   855  8a4c a300                       ldz #$00
   856  8a4e eab200                     lda [<dos_scratch_vector],z
   857  8a51 8d51d6             	sta $d651
   858                          
   859  8a54 60                 	rts
   860                          
   861                          
   862                          	
   863                          	
   864                          copy_sdcard_regs_to_scratch:
   865                                  ;; Copy the main SD card access registers to a
   866                                  ;; scratch area, so that we can save them, and thus restore
   867                                  ;; them after unfreezing.
   868                                  ;; (This is done outside of the automatic loop, because
   869                                  ;; it has to be handled specially.)
   870  8a55 a20f                       ldx #$0f
   871  8a57 bd80d6             dfp1:   lda $d680,x
   872  8a5a 9d678a                     sta freeze_scratch_area,x
   873  8a5d ca                         dex
   874  8a5e 10f7                       bpl dfp1
   875                                  ;; Also save $D070 (palette select register)
   876                                  ;; since it gets stomped while saving palettes
   877  8a60 ad70d0                     lda $d070
   878  8a63 8d778a                     sta freeze_d070
   879  8a66 60                         rts
   880                          
   881                          freeze_scratch_area:
   882  8a67 0000000000000000...        !8 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   883                          freeze_d070:
   884  8a77 00                         !8 0
   885                          
   886                          do_freeze_prep_viciv:
   887                                  ;; Restore saved $D070 value to fix that $D070 will have been
   888                                  ;; stomped over by the palette saving routines
   889  8a78 ad778a                     lda freeze_d070
   890  8a7b 8d70d0                     sta $d070
   891  8a7e 60                         rts
   892                          
   893                          freeze_region_dmalist:
   894  8a7f 0a                         !8 $0A ;; F011A format DMA list
   895  8a80 80                         !8 $80 ;; Source MB option follows
   896                          freeze_region_dmalist_source_mb:
   897  8a81 00                         !8 $00
   898  8a82 81                         !8 $81 ;; Dest MB option follows
   899                          freeze_region_dmalist_dest_mb:
   900  8a83 00                         !8 $00
   901  8a84 00                         !8 $00 ;; end of enhanced DMA option list
   902                          
   903                                  ;; F011A format DMA list
   904  8a85 00                         !8 $00 ;; copy + last request in chain
   905                          freeze_region_dmalist_count:
   906  8a86 0000                       !16 $0000 ;; size of copy
   907                          freeze_region_dmalist_source_start:
   908  8a88 0000                       !16 $0000 ;; source address lower 16 bits
   909                          freeze_region_dmalist_source_bank:
   910  8a8a 00                         !8 $00   ;;
   911                          freeze_region_dmalist_dest_start:
   912  8a8b 0000                       !16 $0000
   913                          freeze_region_dmalist_dest_bank:
   914  8a8d 00                         !8 $00
   915  8a8e 0000                       !16 $0000 ;; modulo (unused)
   916                          
   917                          do_unfreeze_prep_palette_select:
   918                                  ;; We do the same memory map setup during freeze and unfreeze
   919                          do_freeze_prep_palette_select:
   920                                  ;; X = 6, 8, 10 or 12
   921                                  ;; Use this to pick which of the four palette banks
   922                                  ;; is visible at $D100-$D3FF
   923  8a90 8a                         txa
   924  8a91 18                         clc
   925  8a92 e902                       sbc #freeze_prep_palette0
   926  8a94 0a                         asl
   927  8a95 0a                         asl
   928  8a96 0a                         asl
   929  8a97 0a                         asl
   930  8a98 0a                         asl
   931  8a99 093f                       ora #$3f  ;; keep displaying the default palette
   932  8a9b 8d70d0                     sta $d070
   933  8a9e 60                         rts
   934                          
   935                          wait_on_shift_key:
   936  8a9f ad11d6                     lda $d611
   937  8aa2 f0fb                       beq wait_on_shift_key
   938  8aa4 ad11d6             -       lda $d611
   939  8aa7 d0fb                       bne -
   940  8aa9 60                         rts
   941                          
   942                          debug_show_sector:
   943                                  ;; XXX DEBUG
   944  8aaa ad81d6                     lda $d681
   945  8aad 8d0008                     sta $0800
   946  8ab0 ad82d6                     lda $d682
   947  8ab3 8d0108                     sta $0801
   948  8ab6 ad83d6                     lda $d683
   949  8ab9 8d0208                     sta $0802
   950  8abc ad84d6                     lda $d684
   951  8abf 8d0308                     sta $0803
   952  8ac2 60                         rts
   953                          
   954                          syspart_read_freeze_region_list_trap:
   955                                  ;; Copy freeze_mem_list out to user memory
   956  8ac3 ae41d6                     ldx hypervisor_x
   957  8ac6 8600                       stx <dos_scratch_vector+0
   958  8ac8 ad42d6                     lda hypervisor_y
   959  8acb 297f                       and #$7f ;; don't allow writing over hypervisor or IO when copying it out
   960  8acd 8501                       sta <dos_scratch_vector+1
   961  8acf a298                       ldx #freeze_mem_list_end-freeze_mem_list
   962  8ad1 a000                       ldy #$00
   963  8ad3 b9df8a             -       lda freeze_mem_list,y
   964  8ad6 9100                       sta (<dos_scratch_vector),y
   965  8ad8 c8                         iny
   966  8ad9 ca                         dex
   967  8ada d0f7                       bne -
   968  8adc 4c1082                     jmp return_from_trap_with_success
   969                          
   970                          freeze_mem_list:
   971                          	;; XXX - There must not be more than 32 of these, as the region list
   972                          	;; has to fit within a single page.
   973                          	
   974                                  ;; start address (4 bytes), length (3 bytes),
   975                                  ;; preparatory action required before reading/writing (1 byte)
   976                                  ;; Each segment will live in its own sector (or sectors if
   977                                  ;; >512 bytes) when frozen. So we should avoid excessive
   978                                  ;; numbers of blocks.
   979                          
   980                                  ;; core SDcard registers we need to be ready to start writing
   981                                  ;; sectors. We copy these out and in manually at the start
   982                                  ;; and end of the freeze and unfreeze routines, respectively.
   983                                  ;; So they are not done here.
   984                                  ;; (the +$FFF0000 is to rebase the pointer into the hypervisor memory area)
   985  8adf 678aff0f                   !32 freeze_scratch_area+$fff0000
   986  8ae3 1000                       !16 $0010
   987  8ae5 00                         !8 0
   988  8ae6 00                         !8 freeze_prep_none
   989                          
   990                                  ;; SDcard sector buffer + SD card registers
   991                                  ;; We have to save this before anything much else, because
   992                                  ;; we need it for freezing.  We stash $FFD6E00-FFF and
   993                                  ;; $FFD3680-70F at $FFD6000 before hand, so that we preserve
   994                                  ;; these registers before touching them.
   995                                  ;; (the DMAgic registers at $DDF370x have to get copied manually,
   996                                  ;; so that we don't mess up the DMA state.  Also, when restoring
   997                                  ;; we have to take some care putting them back exactly.)
   998                          
   999  8ae7 0060fd0f                   !32 $ffd6000
  1000  8aeb 9000                       !16 $0090
  1001  8aed 00                         !8 0
  1002  8aee 0a                         !8 freeze_prep_stash_sd_buffer_and_regs
  1003                          
  1004                                  ;; SDcard sector buffer (F011)
  1005  8aef 006cfd0f                   !32 $ffd6c00
  1006  8af3 0002                       !16 $0200
  1007  8af5 00                         !8 0
  1008  8af6 00                         !8 freeze_prep_none
  1009                          
  1010                                  ;; Process decriptor
  1011  8af7 00bdff0f                   !32 $fffbd00
  1012  8afb 0001                       !16 $0100
  1013  8afd 00                         !8 0
  1014  8afe 00                         !8 freeze_prep_none
  1015                          
  1016                                  ;; $D640-$D67E hypervisor state registers
  1017                                  ;; XXX - These can't be read by DMA, so we need to have a
  1018                                  ;; prep routine that copies them out first?
  1019  8aff 4036fd0f                   !32 $ffd3640
  1020  8b03 3f00                       !16 $003f
  1021  8b05 00                         !8 0
  1022  8b06 10                         !8 freeze_prep_hyperregs
  1023                          
  1024                                  ;; VIC-IV palette block 0
  1025  8b07 0031fd0f                   !32 $ffd3100
  1026  8b0b 0003                       !16 $0300
  1027  8b0d 00                         !8 0
  1028  8b0e 02                         !8 freeze_prep_palette0
  1029                          
  1030                                  ;; VIC-IV palette block 1
  1031  8b0f 0031fd0f                   !32 $ffd3100
  1032  8b13 0003                       !16 $0300
  1033  8b15 00                         !8 0
  1034  8b16 04                         !8 freeze_prep_palette1
  1035                          
  1036                                  ;; VIC-IV palette block 2
  1037  8b17 0031fd0f                   !32 $ffd3100
  1038  8b1b 0003                       !16 $0300
  1039  8b1d 00                         !8 0
  1040  8b1e 06                         !8 freeze_prep_palette2
  1041                          
  1042                                  ;; VIC-IV palette block 3
  1043  8b1f 0031fd0f                   !32 $ffd3100
  1044  8b23 0003                       !16 $0300
  1045  8b25 00                         !8 0
  1046  8b26 08                         !8 freeze_prep_palette3
  1047                          
  1048                                  ;; 32KB colour RAM
  1049  8b27 0000f80f                   !32 $ff80000
  1050  8b2b 0080                       !16 $8000
  1051  8b2d 00                         !8 $00
  1052  8b2e 00                         !8 freeze_prep_none
  1053                          
  1054                                  ;; CIAs
  1055  8b2f 003cfd0f                   !32 $ffd3c00
  1056  8b33 0002                       !16 $0200
  1057  8b35 00                         !8 0
  1058  8b36 00                         !8 freeze_prep_none
  1059                          
  1060                                  ;; VIC-IV, F011 $D000-$D0FF
  1061                                  ;; This should be last since it is not a whole sector worth, and there is a bug
  1062                                  ;; that gets tickled sometimes if a region is not an integer number of sectors.
  1063  8b37 0030fd0f                   !32 $ffd3000
  1064  8b3b 8000                       !16 $0080
  1065  8b3d 00                         !8 0
  1066  8b3e 0e                         !8 freeze_prep_viciv
  1067                          
  1068                                  ;; VIC-IV C128 2MHz enable emulation register
  1069  8b3f 3000fd0f                   !32 $ffd0030
  1070  8b43 0100                       !16 $0001
  1071  8b45 00                         !8 0
  1072  8b46 00                         !8 freeze_prep_none
  1073                          
  1074                                  ;; 384KB RAM (includes the 128KB "ROM" area)
  1075                                  ;; Must be saved before doing the thumbnail, which re-uses $1000-$1FFF to store the thumbnail image
  1076  8b47 00000000                   !32 $0000000
  1077  8b4b 0000                       !16 $0000
  1078  8b4d 06                         !8 6          ;; =6x64K blocks = 384KB
  1079  8b4e 00                         !8 freeze_prep_none
  1080                          
  1081                                  ;; Process scratch space
  1082  8b4f 00bd0000                   !32 currenttask_block
  1083  8b53 0001                       !16 $0100
  1084  8b55 00                         !8 0
  1085  8b56 00                         !8 freeze_prep_none
  1086                          
  1087                                  ;; $D700-$D7FF CPU registers (excluding DMAgic registers, which we save/restore along with SD card registers)
  1088  8b57 1037fd0f                   !32 $ffd3710
  1089  8b5b f000                       !16 $00F0
  1090  8b5d 00                         !8 0
  1091  8b5e 00                         !8 freeze_prep_none
  1092                          
  1093                                  ;; Internal 1541 4KB RAM + 16KB ROM
  1094                                  ;; XXX - Need to also save state of VIAs
  1095  8b5f 00b0fd0f                   !32 $FFDB000
  1096  8b63 0050                       !16 $5000
  1097  8b65 00                         !8 0
  1098  8b66 00                         !8 freeze_prep_none
  1099                          
  1100                                  ;; XXX - Thumbnail must be saved last, because something about freezing this causes
  1101                                  ;; the freezing of the remaining regions to fail.
  1102                                  ;; 4KB thumbnail of screen
  1103                                  ;; The prep routine copies this down to $1000-$1FFF, so we have to have saved the rest of RAM
  1104                                  ;; first
  1105  8b67 00100000                   !32 $0001000
  1106  8b6b 0010                       !16 $1000
  1107  8b6d 80                         !8 $80                              ;; bit 7 set in # banks tells unfreezer to ignore it.
  1108  8b6e 0c                         !8 freeze_prep_thumbnail
  1109                          
  1110                                  ;; XXX - Other IO chips!
  1111                          
  1112                                  ;; End of list
  1113  8b6f ffffffff                   !32 $FFFFFFFF
  1114  8b73 ffff                       !16 $FFFF
  1115  8b75 ff                         !8 $FF
  1116  8b76 ff                         !8 $FF
  1117                          
  1118                          freeze_mem_list_end:
  1119                          
  1120                          freeze_dma_length_remaining:
  1121  8b77 000000                     !8 0,0,0
  1122                          
  1123                                  ;; If bit 7 set, then don't DMA the region into place on unfreezing
  1124                          unfreeze_skip:
  1125  8b7a 00                         !8 0
  1126                          

; ******** Source: src/hyppo/main.asm
   372                          
   373                          ;; /*  -------------------------------------------------------------------
   374                          ;;     DOS, process control and related functions trap
   375                          ;;     ---------------------------------------------------------------- */

; ******** Source: dos.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; XXX - Track down why 2nd and subsequent LFN blocks are not used.
     7                          
     8                          dos_and_process_trap:
     9                          
    10                                  ;; XXX - Machine is being updated to automatically disable IRQs on trapping
    11                                  ;; to hypervisor, but for now, we need to do this explicitly.
    12                                  ;; Should be able to be removed after 20160103
    13                                  ;; BG: cannot confirm removal of the instruction below. Dated 20160902
    14  8b7b 78                         sei
    15                          
    16                                  ;; XXX - We have just added a fix for this in the CPU, to CLEAR DECIMAL MODE
    17                                  ;; on entry to the hypervisor. But I'm not taking any chances just now.
    18                                  ;;
    19  8b7c d8                         cld
    20                          
    21                                  ;; Sub-function is selected by A.
    22                                  ;; Bits 6-1 are the only ones used.
    23                                  ;; Mask out bit 0 so that indirect jmp's are valid.
    24                                  ;;
    25  8b7d 297e                       and #$7E
    26  8b7f aa                         tax
    27  8b80 7c838b                     jmp (dos_and_process_trap_table,x)
    28                          
    29                          ;;         ========================
    30                          
    31                          dos_and_process_trap_table:
    32                          
    33                                  ;; $00 - $0E
    34                                  ;;
    35  8b83 488c                       !16 trap_dos_getversion
    36  8b85 5f8c                       !16 trap_dos_getdefaultdrive
    37  8b87 bd8c                       !16 trap_dos_getcurrentdrive          ;; appears out-of-order (is far below)
    38  8b89 688c                       !16 trap_dos_selectdrive
    39  8b8b cb8f                       !16 trap_dos_getdisksize              ;; not currently implememted
    40  8b8d cb8f                       !16 trap_dos_getcwd                   ;; not currently implememted
    41  8b8f 2b8f                       !16 trap_dos_chdir                    
    42  8b91 cb8f                       !16 trap_dos_mkdir                    ;; not currently implememted
    43                          
    44                                  ;; $10 - $1E
    45                                  ;;
    46  8b93 cb8f                       !16 trap_dos_rmdir                    ;; not currently implememted
    47  8b95 d78e                       !16 trap_dos_opendir
    48  8b97 eb8e                       !16 trap_dos_readdir
    49  8b99 198f                       !16 trap_dos_closedir
    50  8b9b 398f                       !16 trap_dos_openfile
    51  8b9d 1c8f                       !16 trap_dos_readfile                 
    52  8b9f cb8f                       !16 trap_dos_writefile                ;; not currently implememted
    53  8ba1 c68c                       !16 trap_dos_mkfile                   ;; implementation started
    54                          
    55                                  ;; $20 - $2E
    56                                  ;;
    57  8ba3 478f                       !16 trap_dos_closefile
    58  8ba5 768c                       !16 trap_dos_closeall
    59  8ba7 cb8f                       !16 trap_dos_seekfile                 ;; not currently implememted
    60  8ba9 cb8f                       !16 trap_dos_rmfile                   ;; not currently implememted
    61  8bab cb8f                       !16 trap_dos_fstat                    ;; not currently implememted
    62  8bad cb8f                       !16 trap_dos_rename                   ;; not currently implememted
    63  8baf cb8f                       !16 trap_dos_filedate                 ;; not currently implememted
    64  8bb1 9e8c                       !16 trap_dos_setname
    65                          
    66                                  ;; $30 - $3E
    67                                  ;;
    68  8bb3 698f                       !16 trap_dos_findfirst
    69  8bb5 758f                       !16 trap_dos_findnext
    70  8bb7 638f                       !16 trap_dos_findfile
    71  8bb9 7f8c                       !16 trap_dos_loadfile
    72  8bbb 7b8f                       !16 trap_dos_geterrorcode
    73  8bbd 988c                       !16 trap_dos_setup_transfer_area
    74  8bbf 228f                       !16 trap_dos_cdrootdir
    75  8bc1 7c8c                       !16 trap_dos_loadfile_attic
    76                          
    77                                  ;; $40 - $4E
    78                                  ;;
    79  8bc3 848f                       !16 trap_dos_d81attach0
    80  8bc5 908f                       !16 trap_dos_d81detach
    81  8bc7 968f                       !16 trap_dos_d81write_en
    82  8bc9 8a8f                       !16 trap_dos_d81attach1
    83  8bcb 9c8f                       !16 trap_dos_get_proc_desc
    84  8bcd 2f82                       !16 invalid_subfunction
    85  8bcf 2f82                       !16 invalid_subfunction
    86  8bd1 2f82                       !16 invalid_subfunction
    87                          
    88                                  ;; $50 - $5E
    89                                  ;;
    90  8bd3 cb8f                       !16 trap_dos_gettasklist              ;; not currently implememted
    91  8bd5 cb8f                       !16 trap_dos_sendmessage              ;; not currently implememted
    92  8bd7 cb8f                       !16 trap_dos_receivemessage           ;; not currently implememted
    93  8bd9 cb8f                       !16 trap_dos_writeintotask            ;; not currently implememted
    94  8bdb cb8f                       !16 trap_dos_readoutoftask            ;; not currently implememted
    95  8bdd 2f82                       !16 invalid_subfunction
    96  8bdf 2f82                       !16 invalid_subfunction
    97  8be1 2f82                       !16 invalid_subfunction
    98                          
    99                                  ;; $60 - $6E
   100                                  ;;
   101  8be3 cb8f                       !16 trap_dos_terminateothertask       ;; not currently implememted
   102  8be5 cb8f                       !16 trap_dos_create_task_native       ;; not currently implememted
   103  8be7 cb8f                       !16 trap_dos_load_into_task           ;; not currently implememted
   104  8be9 cb8f                       !16 trap_dos_create_task_c64          ;; not currently implememted
   105  8beb cb8f                       !16 trap_dos_create_task_c65          ;; not currently implememted
   106  8bed cb8f                       !16 trap_dos_exit_and_switch_to_task  ;; not currently implememted
   107  8bef cb8f                       !16 trap_dos_switch_to_task           ;; not currently implememted
   108  8bf1 cb8f                       !16 trap_dos_exit_task                ;; not currently implememted
   109                          
   110                                  ;; $70 - $7E
   111                                  ;;
   112  8bf3 3a8c                       !16 trap_task_toggle_rom_writeprotect
   113  8bf5 2f8c                       !16 trap_task_toggle_force_4502
   114  8bf7 098c                       !16 trap_task_get_mapping
   115  8bf9 1c8c                       !16 trap_task_set_mapping
   116  8bfb 2f82                       !16 invalid_subfunction
   117  8bfd 2f82                       !16 invalid_subfunction
   118  8bff 038c                       !16 trap_serial_monitor_write
   119  8c01 cfa2                       !16 reset_entry
   120                          
   121                          trap_serial_monitor_write:
   122  8c03 8c7cd6                     sty hypervisor_write_char_to_serial_monitor
   123  8c06 4c1082                     jmp return_from_trap_with_success
   124                          
   125                          ;;         ========================
   126                          
   127                          trap_task_get_mapping:
   128  8c09 200eab             	jsr hypervisor_setup_copy_region
   129  8c0c 900b               	bcc @bad
   130  8c0e a005               	ldy #5
   131                          @copyloop:
   132  8c10 b94ad6             	lda hypervisor_maplolo,y
   133  8c13 9106               	sta (<hypervisor_userspace_copy_vector),y
   134  8c15 88                 	dey
   135  8c16 10f8               	bpl @copyloop
   136  8c18 38                 	sec
   137                          @bad:
   138  8c19 4c6e8c             	jmp return_from_trap_with_carry_flag
   139                          
   140                          trap_task_set_mapping:
   141  8c1c 200eab             	jsr hypervisor_setup_copy_region
   142  8c1f 900b               	bcc @bad2
   143  8c21 a005               	ldy #5
   144                          @copyloop2:
   145  8c23 b106               	lda (<hypervisor_userspace_copy_vector),y
   146  8c25 994ad6             	sta hypervisor_maplolo,y
   147  8c28 88                 	dey
   148  8c29 10f8               	bpl @copyloop2
   149  8c2b 38                 	sec
   150                          @bad2:
   151  8c2c 4c6e8c             	jmp return_from_trap_with_carry_flag
   152                          	
   153                          trap_task_toggle_force_4502:
   154  8c2f ad7dd6                     lda hypervisor_feature_enables
   155  8c32 4920                       eor #$20
   156  8c34 8d7dd6                     sta hypervisor_feature_enables
   157  8c37 4c428c                     jmp returnFeatureState
   158                          
   159                          trap_task_toggle_rom_writeprotect:
   160  8c3a ad7dd6                     lda hypervisor_feature_enables
   161  8c3d 4904                       eor #$04
   162  8c3f 8d7dd6                     sta hypervisor_feature_enables
   163                          returnFeatureState:
   164                                  ;; Pass updated state back out to caller, so they know the result
   165  8c42 8d40d6                     sta hypervisor_a
   166  8c45 4c1082                     jmp return_from_trap_with_success
   167                          
   168                          trap_dos_getversion:
   169                          
   170                                  ;; Return OS and DOS version.
   171                                  ;; A/X = OS Version major/minor
   172                                  ;; Z/Y = DOS Version major/minor
   173                          
   174  8c48 a902                       lda #<os_version
   175  8c4a 8d41d6                     sta hypervisor_x
   176  8c4d a901                       lda #>os_version
   177  8c4f 8d40d6                     sta hypervisor_a
   178  8c52 a902                       lda #<dos_version
   179  8c54 8d43d6                     sta hypervisor_z
   180  8c57 a901                       lda #>dos_version
   181  8c59 8d42d6                     sta hypervisor_y
   182  8c5c 4c1082                     jmp return_from_trap_with_success
   183                          
   184                          ;;         ========================
   185                          
   186                          trap_dos_getdefaultdrive:
   187                          
   188  8c5f ad02bc                     lda dos_default_disk
   189  8c62 8d40d6                     sta hypervisor_a
   190  8c65 4c1082                     jmp return_from_trap_with_success
   191                          
   192                          ;;         ========================
   193                          
   194                          trap_dos_selectdrive:
   195                          
   196  8c68 ae41d6                     ldx hypervisor_x
   197  8c6b 207f92                     jsr dos_set_current_disk
   198                          
   199                          return_from_trap_with_carry_flag:
   200  8c6e b003                       bcs +
   201  8c70 4c1e82                     jmp return_from_trap_with_failure
   202  8c73 4c1082             +       jmp return_from_trap_with_success
   203                          
   204                          trap_dos_closeall:
   205                          
   206  8c76 20ce8f                     jsr dos_clear_filedescriptors
   207  8c79 4c1082                     jmp return_from_trap_with_success
   208                          
   209                          ;;         ========================
   210                          
   211                          trap_dos_loadfile_attic:
   212  8c7c a908               	lda #$08  		; Set address to $8xxxxxx to access attic RAM
   213  8c7e 2c                 	!8 $2c 		; BIT $xxxx to skip lda #$00 below
   214                          	;; FALL THROUGH
   215                          	
   216                          trap_dos_loadfile:
   217                          
   218                                  ;; Only allow loading into lower 16MB to avoid possibility of writing
   219                                  ;; over hypervisor
   220                                  ;;
   221  8c7f a900                       lda #$00
   222  8c81 851b                       sta <(dos_file_loadaddress+3)
   223                          
   224  8c83 ad41d6                     lda hypervisor_x
   225  8c86 8518                       sta <dos_file_loadaddress
   226  8c88 ad42d6                     lda hypervisor_y
   227  8c8b 8519                       sta <(dos_file_loadaddress+1)
   228  8c8d ad43d6                     lda hypervisor_z
   229  8c90 851a                       sta <(dos_file_loadaddress+2)
   230                          
   231  8c92 205198                     jsr dos_readfileintomemory
   232  8c95 4c6e8c                     jmp return_from_trap_with_carry_flag
   233                          
   234                          ;;         ========================
   235                          
   236                          trap_dos_setup_transfer_area:
   237                          
   238  8c98 200eab                     jsr hypervisor_setup_copy_region
   239                          
   240  8c9b 4c6e8c                     jmp return_from_trap_with_carry_flag
   241                          
   242                          trap_dos_setname:
   243                          
   244                                  ;; read file name from any where in bottom 32KB of RAM, as mapped on entry
   245                                  ;; to the hypervisor (this prevents the user from setting the filename to some
   246                                  ;; piece of the hypervisor, and thus leaking hypervisor data to user-land if the
   247                                  ;; user were to later query the filename).
   248                          
   249                                  +Checkpoint "trap_dos_setname"
   250                          
   251  8c9e 200eab                     jsr hypervisor_setup_copy_region
   252  8ca1 900c                       bcc tdsnfailure
   253                          
   254  8ca3 a606                       ldx <hypervisor_userspace_copy_vector
   255  8ca5 a407                       ldy <(1+hypervisor_userspace_copy_vector)
   256  8ca7 205699                     jsr dos_setname
   257  8caa 9003                       bcc tdsnfailure
   258                          
   259                                  ;; setname succeeded
   260                                  ;;
   261                          
   262  8cac 4c1082                     jmp return_from_trap_with_success
   263                          
   264                          ;;         ========================
   265                          
   266                          tdsnfailure:
   267                                  ;; save the error code so a later trap_dos_geterrorcode will return it
   268  8caf 8dfabc                     sta dos_error_code
   269  8cb2 4c1e82                     jmp return_from_trap_with_failure
   270                          
   271                          ;;         ========================
   272                          
   273                          
   274                          illegalvalue:
   275                          
   276                                  ;; BG: the below section seems never called from anywhere: suggest removal
   277                          
   278                          !if DEBUG_HYPPO {
   279                          ;;         tya
   280                          ;;         tax
   281                          ;;         jsr checkpoint_bytetohex
   282                          ;;         sty iv1+0
   283                          ;;         stx iv1+1
   284                          ;;
   285                          ;;         jsr checkpoint
   286                          ;;         .byte 0,"Filename contains $00 @ position $"
   287                          ;; iv1:        .byte "%%",0
   288                          }
   289                          
   290  8cb5 a911                       lda #dos_errorcode_illegal_value
   291  8cb7 8dfabc                     sta dos_error_code
   292  8cba 4c1e82                     jmp return_from_trap_with_failure
   293                          
   294                          ;;         ========================
   295                          
   296                          trap_dos_getcurrentdrive:
   297                          
   298  8cbd ad03bc                     lda dos_disk_current_disk
   299  8cc0 8d40d6                     sta hypervisor_a
   300  8cc3 4c1082                     jmp return_from_trap_with_success
   301                          
   302                          ;;         ========================
   303                          
   304                          trap_dos_mkfile:
   305                          
   306                          	;; XXX Filename must already be set.
   307                          	;; XXX Must be a file in the current directory only.
   308                          	;; XXX Can only create normal files, not directories
   309                          	;;     (change attribute after).
   310                          	;; XXX Only supports 8.3 names for now.
   311                          	;; XXX Filenames without extension might still cause problems.
   312                          	;; XXX Allocates 512KB at a time, i.e., a full FAT sector's
   313                          	;;     worth of clusters.
   314                          	;; XXX Allocates a contiguous block, so that D81s etc can
   315                          	;;     be created, and guaranteed contiguous on the storage,
   316                          	;;     so that they can be mounted.
   317                          	;; XXX Size of file specified in $ZZYYXX, i.e., limit of 16MB.
   318                          	;; XXX Doesn't handle full file systems (or ones without enough space
   319                          	;;     free properly. Should check candidate cluster number is not too
   320                          	;;     high, and abort if it is.
   321                          
   322                          	;; First, make sure the file doesn't already exist
   323  8cc6 20c093             	jsr dos_findfile
   324  8cc9 9009               	bcc +
   325                          	;; File exists, so abort
   326  8ccb 18                 	clc
   327  8ccc a98d               	lda #dos_errorcode_file_exists
   328  8cce 8dfabc             	sta dos_error_code
   329  8cd1 4c1e82             	jmp return_from_trap_with_failure
   330                          +
   331                          
   332                          	;; We need 1 FAT sector per 512KB of data.
   333                          	;; I.e., shift ZZ right by three bits to get number
   334                          	;; of empty FAT sectors we need to indicate sufficient space.
   335  8cd4 ad43d6             	lda hypervisor_z
   336  8cd7 4a                 	lsr
   337  8cd8 4a                 	lsr
   338  8cd9 4a                 	lsr
   339  8cda 18                 	clc
   340  8cdb 6901               	adc #$01 
   341  8cdd 8d04bf             	sta dos_scratch_byte_1
   342                          
   343                          	;; Now go looking for empty FAT sectors
   344                          	;; Start at cluster 128, and add 128 each time to step through
   345                          	;; them.
   346                          	;; This skips the first sector of FAT, which always has some used
   347                          	;; bits, and ensures we can allocate on a whole sector basis.
   348  8ce0 a980               	lda #128
   349  8ce2 8510               	sta <(zptempv32+0)
   350  8ce4 a900               	lda #$00
   351  8ce6 8511               	sta <(zptempv32+1)
   352  8ce8 8512               	sta <(zptempv32+2)
   353  8cea 8513               	sta <(zptempv32+3)
   354                          
   355                          	;; Initially 0 empty pages found
   356  8cec a900               	lda #0
   357  8cee 8d05bf             	sta dos_scratch_byte_2
   358                          
   359  8cf1 20cf9f             	jsr sd_map_sectorbuffer
   360                          
   361                          find_empty_fat_page_loop:
   362                          	
   363  8cf4 a203               	ldx #3
   364  8cf6 b510               -	lda <zptempv32,x
   365  8cf8 9db3bc             	sta dos_current_cluster,x
   366  8cfb ca                 	dex
   367  8cfc 10f8               	bpl -
   368                          
   369  8cfe 20c68e             	jsr read_fat_sector_for_cluster
   370                          	
   371                          	;; Is the page empty
   372  8d01 a200               	ldx #0
   373  8d03 bd00de             -	lda sd_sectorbuffer,x
   374  8d06 d008               	bne +
   375  8d08 bd00df             	lda sd_sectorbuffer+$100,x
   376  8d0b d003               	bne +
   377                          
   378  8d0d e8                 	inx
   379  8d0e d0f3               	bne -
   380                          +
   381                          	
   382                          	;; Z=1 if FAT sector all unallocated, Z=0 otherwise
   383  8d10 f008               	beq fat_sector_is_empty
   384                          
   385                          	;; Reset empty FAT sector counter
   386  8d12 a900               	lda #0
   387  8d14 8d05bf             	sta dos_scratch_byte_2
   388  8d17 4c258d             	jmp +
   389                          	
   390                          fat_sector_is_empty:	
   391  8d1a ee05bf             	inc dos_scratch_byte_2
   392  8d1d ad05bf             	lda dos_scratch_byte_2
   393  8d20 cd04bf             	cmp dos_scratch_byte_1
   394  8d23 f01c               	beq found_enough_contiguous_free_space
   395                          +
   396                          	;; Need to find another
   397  8d25 a980               	lda #$80
   398  8d27 18                 	clc
   399  8d28 6510               	adc <(zptempv32+0)
   400  8d2a 8510               	sta <(zptempv32+0)
   401  8d2c a511               	lda <(zptempv32+1)
   402  8d2e 6900               	adc #0
   403  8d30 8511               	sta <(zptempv32+1)
   404  8d32 a512               	lda <(zptempv32+2)
   405  8d34 6900               	adc #0
   406  8d36 8512               	sta <(zptempv32+2)
   407  8d38 a513               	lda <(zptempv32+3)
   408  8d3a 6900               	adc #0
   409  8d3c 8513               	sta <(zptempv32+3)
   410                          
   411                          	;; XXX Check that we haven't hit the end of the file system
   412                          	
   413  8d3e 4cf48c             	jmp find_empty_fat_page_loop
   414                          
   415                          found_enough_contiguous_free_space:
   416                          
   417                          	;; Space begins dos_scratch_byte_2 FAT sectors before here,
   418                          	;; so rewind back to there by taking $80 away for each count.
   419  8d41 ce05bf             	dec dos_scratch_byte_2
   420                          	
   421  8d44 ad05bf             -	lda dos_scratch_byte_2
   422  8d47 f01f               	beq +
   423  8d49 a510               	lda <(zptempv32+0)
   424  8d4b 38                 	sec
   425  8d4c e980               	sbc #$80
   426  8d4e 8510               	sta <(zptempv32+0)
   427  8d50 a511               	lda <(zptempv32+1)
   428  8d52 e900               	sbc #0
   429  8d54 8511               	sta <(zptempv32+1)
   430  8d56 a512               	lda <(zptempv32+2)
   431  8d58 e900               	sbc #0
   432  8d5a 8512               	sta <(zptempv32+2)
   433  8d5c a513               	lda <(zptempv32+3)
   434  8d5e e900               	sbc #0
   435  8d60 8513               	sta <(zptempv32+3)
   436  8d62 ce05bf             	dec dos_scratch_byte_2
   437  8d65 4c448d             	jmp -
   438                          +
   439                          	;; zptempv32 now contains the starting cluster for our file
   440                          
   441                          	;; Find directory entry slot
   442  8d68 20838e             	jsr dos_find_free_dirent
   443  8d6b b001               	bcs +
   444                          	;; Couldn't find a free dirent, so return whatever error
   445                          	;; we have been indicated.
   446  8d6d 60                 	rts
   447                          +
   448                          
   449                          	;; Show offset in directory sector for dirent
   450                          ;;	lda dos_scratch_vector+0
   451                          ;;	sta $0700
   452                          ;;	lda dos_scratch_vector+1
   453                          ;;	and #$01
   454                          ;;	sta $0701
   455                          ;;
   456                          ;;	;; Show directory sector
   457                          ;;	ldx #3
   458                          ;;!:	lda $d681,x
   459                          ;;	sta $0703,x
   460                          ;;	dex
   461                          ;;	bpl !-
   462                          ;;
   463                          ;;	;; Show first cluster we will use
   464                          ;;	ldx #3
   465                          ;;!:	lda zptempv32,x
   466                          ;;	sta $0708,x
   467                          ;;	dex
   468                          ;;	bpl !-
   469                          	
   470                          	;; XXX Populate dirent structure
   471                          	;; dirent: erase old contents
   472  8d6e a01f               	ldy #31
   473  8d70 a900               	lda #0
   474  8d72 9100               -	sta (<dos_scratch_vector),y
   475                          	;; Put spaces in filename field (first 11 bytes)
   476  8d74 c00b               	cpy #11
   477  8d76 d002               	bne foo1
   478  8d78 a920               	lda #$20
   479                          foo1:	
   480  8d7a 88                 	dey
   481  8d7b 10f5               	bpl -
   482                          	;; dirent: filename
   483                          	;; Split filename at dot
   484  8d7d a000               	ldy #0
   485  8d7f a200               	ldx #fs_fat32_dirent_offset_shortname
   486  8d81 bd67bc             -	lda dos_requested_filename,x
   487  8d84 c92e               	cmp #$2e
   488  8d86 d004               	bne not_dot
   489  8d88 a007               	ldy #8-1
   490  8d8a d006               	bne was_dot
   491                          not_dot:
   492                          	;; Don't write nul char if filename is short
   493  8d8c c900               	cmp #0
   494  8d8e f00a               	beq +
   495  8d90 9100               	sta (<dos_scratch_vector),y
   496                          was_dot:	
   497  8d92 f006               	beq +
   498  8d94 e8                 	inx
   499  8d95 c8                 	iny
   500  8d96 c00b               	cpy #11
   501  8d98 d0e7               	bne -
   502                          +
   503                          	
   504                          	;; dirent: attributes
   505  8d9a a00b               	ldy #fs_fat32_dirent_offset_attributes
   506  8d9c a920               	lda #$20 ;; Archive bit set
   507  8d9e 9100               	sta (<dos_scratch_vector),y
   508                          	;; dirent: start cluster
   509  8da0 a01a               	ldy #fs_fat32_dirent_offset_clusters_low
   510  8da2 a510               	lda <(zptempv32+0)
   511  8da4 9100               	sta (<dos_scratch_vector),y
   512  8da6 c8                 	iny
   513  8da7 a511               	lda <(zptempv32+1)
   514  8da9 9100               	sta (<dos_scratch_vector),y
   515  8dab a014               	ldy #fs_fat32_dirent_offset_clusters_high
   516  8dad a512               	lda <(zptempv32+2)
   517  8daf 9100               	sta (<dos_scratch_vector),y
   518  8db1 c8                 	iny
   519  8db2 a513               	lda <(zptempv32+3)
   520  8db4 9100               	sta (<dos_scratch_vector),y	
   521                          	;; dirent: file length
   522  8db6 a01c               	ldy #fs_fat32_dirent_offset_file_length
   523  8db8 ad41d6             	lda hypervisor_x
   524  8dbb 9100               	sta (<dos_scratch_vector),y
   525  8dbd c8                 	iny
   526  8dbe ad42d6             	lda hypervisor_y
   527  8dc1 9100               	sta (<dos_scratch_vector),y
   528  8dc3 c8                 	iny
   529  8dc4 ad43d6             	lda hypervisor_z
   530  8dc7 9100               	sta (<dos_scratch_vector),y
   531  8dc9 c8                 	iny
   532  8dca a900               	lda #0
   533  8dcc 9100               	sta (<dos_scratch_vector),y
   534                          
   535                          	;; Write sector back with updated dirent
   536  8dce 20559f             	jsr write_non_mbr_sector
   537  8dd1 20669f             	jsr sd_wait_for_ready
   538                          		
   539                          	;; Update both FATs to make the allocation
   540                          
   541                          	;; Work out how many sectors full of incrementing clusters
   542                          	;; we need.
   543  8dd4 ad04bf             	lda dos_scratch_byte_1
   544  8dd7 8d05bf             	sta dos_scratch_byte_2
   545                          mkfile_fat_write_loop:	
   546                          	;; Get the (currently empty) sector
   547  8dda a203               	ldx #3
   548  8ddc b510               -	lda <zptempv32,x
   549  8dde 9db3bc             	sta dos_current_cluster,x
   550  8de1 ca                 	dex
   551  8de2 10f8               	bpl -
   552  8de4 20c68e             	jsr read_fat_sector_for_cluster
   553                          
   554                          	;; Update cluster number and write it into the field
   555  8de7 a000               	ldy #0
   556                          -
   557                          	;; XXX Rework to use 32-bit pseudo register
   558  8de9 a510               	lda <(zptempv32+0)
   559  8deb 18                 	clc
   560  8dec 6901               	adc #1
   561  8dee 8510               	sta <(zptempv32+0)
   562  8df0 9900de             	sta sd_sectorbuffer,y
   563  8df3 c8                 	iny
   564  8df4 a511               	lda <(zptempv32+1)
   565  8df6 6900               	adc #0
   566  8df8 8511               	sta <(zptempv32+1)
   567  8dfa 9900de             	sta sd_sectorbuffer,y
   568  8dfd c8                 	iny
   569  8dfe a512               	lda <(zptempv32+2)
   570  8e00 6900               	adc #0
   571  8e02 8512               	sta <(zptempv32+2)
   572  8e04 9900de             	sta sd_sectorbuffer,y
   573  8e07 c8                 	iny
   574  8e08 a513               	lda <(zptempv32+3)
   575  8e0a 6900               	adc #0
   576  8e0c 8513               	sta <(zptempv32+3)
   577  8e0e 9900de             	sta sd_sectorbuffer,y
   578  8e11 c8                 	iny
   579  8e12 d0d5               	bne -
   580                          -
   581  8e14 a510               	lda <(zptempv32+0)
   582  8e16 18                 	clc
   583  8e17 6901               	adc #1
   584  8e19 8510               	sta <(zptempv32+0)
   585  8e1b 9900df             	sta sd_sectorbuffer+$100,y
   586  8e1e c8                 	iny
   587  8e1f a511               	lda <(zptempv32+1)
   588  8e21 6900               	adc #0
   589  8e23 8511               	sta <(zptempv32+1)
   590  8e25 9900df             	sta sd_sectorbuffer+$100,y
   591  8e28 c8                 	iny
   592  8e29 a512               	lda <(zptempv32+2)
   593  8e2b 6900               	adc #0
   594  8e2d 8512               	sta <(zptempv32+2)
   595  8e2f 9900df             	sta sd_sectorbuffer+$100,y
   596  8e32 c8                 	iny
   597  8e33 a513               	lda <(zptempv32+3)
   598  8e35 6900               	adc #0
   599  8e37 8513               	sta <(zptempv32+3)
   600  8e39 9900df             	sta sd_sectorbuffer+$100,y
   601  8e3c c8                 	iny
   602  8e3d d0d5               	bne -
   603                          
   604                          	;; If the last FAT sector for this file, then
   605                          	;; the last cluster entry should be $0FFFFFF8 to mark
   606                          	;; end of file.
   607  8e3f ad05bf             	lda dos_scratch_byte_2
   608  8e42 c901               	cmp #1
   609  8e44 d012               	bne +
   610  8e46 a9f8               	lda #$F8
   611  8e48 8dfcdf             	sta $dffc
   612  8e4b a9ff               	lda #$FF
   613  8e4d 8dfddf             	sta $dffd
   614  8e50 8dfedf             	sta $dffe
   615  8e53 a90f               	lda #$0F
   616  8e55 8dffdf             	sta $dfff
   617                          +	
   618                          	;; Write FAT sector to FAT1
   619  8e58 20559f             	jsr write_non_mbr_sector
   620  8e5b 20669f             	jsr sd_wait_for_ready
   621                          
   622                          	;; Work out where it will be in the 2nd FAT
   623  8e5e ad04bc             	lda dos_disk_table_offset
   624  8e61 0909               	ora #fs_fat32_length_of_fat
   625  8e63 a8                 	tay
   626  8e64 a200               	ldx #0
   627  8e66 bd81d6             -	lda $d681,x
   628  8e69 7900bb             	adc dos_disk_table,y
   629  8e6c c8                 	iny
   630  8e6d e8                 	inx
   631  8e6e e004               	cpx #4
   632  8e70 d0f4               	bne -
   633                          	
   634                          	;; Write FAT sector to FAT2
   635  8e72 20559f             	jsr write_non_mbr_sector
   636  8e75 20669f             	jsr sd_wait_for_ready
   637                          	
   638                          	;; More FAT sectors to go?
   639  8e78 ce05bf             	dec dos_scratch_byte_2
   640  8e7b f003               	beq +
   641  8e7d 4cda8d             	jmp mkfile_fat_write_loop
   642                          +		
   643                          
   644                          	;; All done: File has been created.
   645  8e80 4c1082             	jmp return_from_trap_with_success
   646                          
   647                          dos_find_free_dirent:
   648                          	;; Start by opening the directory.
   649  8e83 20f093             	jsr dos_opendir
   650                          	;; Then look for free directory entry slots.
   651  8e86 20cf9f             	jsr sd_map_sectorbuffer
   652                          
   653                          	;; FALL THROUGH
   654                          	
   655                          empty_dirent_search_loop:	
   656                          	
   657  8e89 20ec96             	jsr dos_file_read_current_sector
   658                          
   659                          	;; Look for free dirent in first half of each sector.
   660  8e8c a200               	ldx #0
   661  8e8e a9de               	lda #$de
   662  8e90 8501               	sta <(dos_scratch_vector+1)
   663  8e92 bd00de             -	lda sd_sectorbuffer,x
   664  8e95 c900               	cmp #$00 ;; vacant
   665  8e97 f029               	beq available_dirent_slot
   666  8e99 c9e5               	cmp #$e5 ;; deleted
   667  8e9b f025               	beq available_dirent_slot
   668  8e9d 8a                 	txa
   669  8e9e 6920               	adc #$20
   670  8ea0 aa                 	tax
   671  8ea1 d0ef               	bne -
   672  8ea3 e601               	inc <(dos_scratch_vector+1)
   673  8ea5 bd00de             -	lda sd_sectorbuffer,x
   674  8ea8 c900               	cmp #$00 ;; vacant
   675  8eaa f016               	beq available_dirent_slot
   676  8eac c9e5               	cmp #$e5 ;; deleted
   677  8eae f012               	beq available_dirent_slot
   678  8eb0 8a                 	txa
   679  8eb1 6920               	adc #$20
   680  8eb3 aa                 	tax
   681  8eb4 d0ef               	bne -
   682                          
   683                          	;; No empty slots in this directory, so see if there any more sectors in
   684                          	;; this directory?
   685  8eb6 200997             	jsr dos_file_advance_to_next_sector
   686  8eb9 b0ce               	bcs empty_dirent_search_loop
   687                          
   688                          	;; Directory is full, so return error
   689                          	;; XXX Later we should allow extending the directory by adding another cluster.
   690  8ebb a98e               	lda #dos_errorcode_directory_full
   691  8ebd 8dfabc             	sta dos_error_code
   692  8ec0 18                 	clc
   693  8ec1 60                 	rts
   694                          	
   695                          available_dirent_slot:	
   696  8ec2 8600               	stx <(dos_scratch_vector+0)
   697                          	
   698  8ec4 38                 	sec
   699  8ec5 60                 	rts
   700                          
   701                          ;;         ========================
   702                          	
   703                          read_fat_sector_for_cluster:
   704  8ec6 200c98             	jsr dos_cluster_to_fat_sector
   705                          
   706                          	;; Now read the sector
   707  8ec9 a203                       ldx #3
   708  8ecb bdb3bc             -       lda dos_current_cluster,x
   709  8ece 9d81d6                     sta $d681,x
   710  8ed1 ca                         dex
   711  8ed2 10f7                       bpl -
   712  8ed4 4ce49f             	jmp sd_readsector
   713                          	
   714                          ;;         ========================
   715                          	
   716                          trap_dos_opendir:
   717                          
   718                                  ;; X = File descriptor
   719                                  ;; Y = Page of memory to write dirent into
   720                          
   721                                  ;; Open the current working directory for iteration.
   722                                  ;;
   723  8ed7 20f093                     jsr dos_opendir
   724  8eda b006                       bcs tdod1
   725                          
   726                                  ;; Something has gone wrong. Assume dos_opendir will
   727                                  ;; have set error code
   728                                  ;;
   729  8edc adfabc                     lda dos_error_code
   730  8edf 4c1e82                     jmp return_from_trap_with_failure
   731                          
   732                          tdod1:
   733                                  ;; Directory opened ok.
   734                                  ;;
   735  8ee2 adf8bc                     lda dos_current_file_descriptor
   736  8ee5 8d40d6                     sta hypervisor_a
   737  8ee8 4c1082                     jmp return_from_trap_with_success
   738                          
   739                          ;;         ========================
   740                          
   741                          trap_dos_readdir:
   742                          
   743                                  ;; Read next directory entry from file descriptor $XX
   744                                  ;; Return dirent structure to $YY00
   745                                  ;; in first 32KB of mapped address space
   746                          
   747                                  +Checkpoint "trap_dos_readdir"
   748                          
   749  8eeb 20cf9f                     jsr sd_map_sectorbuffer
   750                          
   751                                  ;; Get offset to current file descriptor
   752                                  ;; (we can't use X register, as has been clobbered in the jump
   753                                  ;; table dispatch code)
   754                                  ;;
   755  8eee ae41d6                     ldx hypervisor_x
   756  8ef1 8ef8bc                     stx dos_current_file_descriptor
   757                          
   758  8ef4 20c596                     jsr dos_get_file_descriptor_offset
   759  8ef7 901a                       bcc tdrd1
   760  8ef9 8df9bc                     sta dos_current_file_descriptor_offset
   761                          
   762  8efc 202694                     jsr dos_readdir
   763  8eff 9012                       bcc tdrd1
   764                          
   765                                  ;; Read the directory entry, now copy it to userland
   766                                  ;;
   767  8f01 200eab                     jsr hypervisor_setup_copy_region
   768  8f04 900d                       bcc tdrd1
   769                          
   770                                  ;; We can now copy the bytes of the dirent to user-space
   771                                  ;;
   772  8f06 a056                       ldy #dos_dirent_structure_length-1
   773                          tdrd2:
   774                                  ;; This loop actually copies the whole dirent.
   775                                  ;; XXX dos_dirent_longfilename must be first in the dirent structure
   776  8f08 b90fbc                     lda dos_dirent_longfilename,y
   777  8f0b 9106                       sta (<hypervisor_userspace_copy_vector),y
   778  8f0d 88                         dey
   779  8f0e 10f8                       bpl tdrd2
   780                          
   781                                  +Checkpoint "trap_dos_readdir <success>"
   782                          
   783  8f10 4c1082                     jmp return_from_trap_with_success
   784                          
   785                          ;;         ========================
   786                          
   787                          tdrd1:
   788                                  +Checkpoint "trap_dos_readdir <failure>"
   789                          
   790  8f13 adfabc                     lda dos_error_code
   791  8f16 4c1e82                     jmp return_from_trap_with_failure
   792                          
   793                          ;;         ========================
   794                          
   795                          trap_dos_closedir:
   796  8f19 4c478f                     jmp trap_dos_closefile
   797                          
   798                          ;;         ========================
   799                          
   800                          trap_dos_readfile:
   801  8f1c 20ee98             	jsr dos_readfile	
   802  8f1f 4c6e8c                     jmp return_from_trap_with_carry_flag
   803                          
   804                          
   805                          trap_dos_cdrootdir:
   806  8f22 ae41d6             	ldx hypervisor_x
   807  8f25 209a92             	jsr dos_cdroot
   808  8f28 4c6e8c             	jmp return_from_trap_with_carry_flag
   809                          	
   810                          trap_dos_chdir:
   811                          
   812                                  ;; Opens file in current dirent structure
   813                                  ;; XXX - This means we must preserve the dirent struct when
   814                                  ;; context-switching to avoid a race-condition
   815                          
   816  8f2b 207a93                     jsr dos_chdir
   817  8f2e 9003                       bcc tdcd1
   818                          
   819                                  +Checkpoint "trap_dos_chdir <success>"
   820                          
   821  8f30 4c1082                     jmp return_from_trap_with_success
   822                          
   823                          tdcd1:
   824                                  +Checkpoint "trap_dos_chdir <failure>"
   825                          
   826  8f33 adfabc                     lda dos_error_code
   827  8f36 4c1e82                     jmp return_from_trap_with_failure
   828                          
   829                          ;;         ========================
   830                          
   831                          	
   832                          trap_dos_openfile:
   833                          
   834                                  ;; Opens file in current dirent structure
   835                                  ;; XXX - This means we must preserve the dirent struct when
   836                                  ;; context-switching to avoid a race-condition
   837                          
   838  8f39 20ac93                     jsr dos_openfile
   839  8f3c 9003                       bcc tdof1
   840                          
   841                                  +Checkpoint "trap_dos_openfile <success>"
   842                          
   843  8f3e 4c1082                     jmp return_from_trap_with_success
   844                          
   845                          tdof1:
   846                                  +Checkpoint "trap_dos_openfile <failure>"
   847                          
   848  8f41 adfabc                     lda dos_error_code
   849  8f44 4c1e82                     jmp return_from_trap_with_failure
   850                          
   851                          ;;         ========================
   852                          
   853                          trap_dos_closefile:
   854                          
   855  8f47 ae41d6                     ldx hypervisor_x
   856  8f4a 8ef8bc                     stx dos_current_file_descriptor
   857                          
   858  8f4d 20c596                     jsr dos_get_file_descriptor_offset
   859  8f50 900b                       bcc tdcf1
   860  8f52 8df9bc                     sta dos_current_file_descriptor_offset
   861  8f55 206693                     jsr dos_closefile
   862  8f58 9003                       bcc tdcf1
   863                          
   864                                  +Checkpoint "trap_dos_closefile <success>"
   865                          
   866  8f5a 4c1082                     jmp return_from_trap_with_success
   867                          tdcf1:
   868                                  +Checkpoint "trap_dos_closefile <failure>"
   869                          
   870  8f5d adfabc                     lda dos_error_code
   871  8f60 4c1e82                     jmp return_from_trap_with_failure
   872                          
   873                          ;;         ========================
   874                          
   875                          trap_dos_findfile:
   876                          
   877  8f63 20c093                     jsr dos_findfile
   878  8f66 4c6e8c                     jmp return_from_trap_with_carry_flag
   879                          
   880                          ;;         ========================
   881                          
   882                          trap_dos_findfirst:
   883                          
   884  8f69 20cc93                     jsr dos_findfirst
   885  8f6c adf8bc                     lda dos_current_file_descriptor
   886  8f6f 8d40d6                     sta hypervisor_a
   887  8f72 4c6e8c                     jmp return_from_trap_with_carry_flag
   888                          
   889                          ;;         ========================
   890                          
   891                          trap_dos_findnext:
   892                          
   893  8f75 20dc93                     jsr dos_findnext
   894  8f78 4c6e8c                     jmp return_from_trap_with_carry_flag
   895                          
   896                          ;;         ========================
   897                          
   898                          trap_dos_geterrorcode:
   899                          
   900  8f7b adfabc                     lda dos_error_code
   901  8f7e 8d40d6                     sta hypervisor_a
   902                          
   903                          !if DEBUG_HYPPO {
   904                                  tax                                ;; convert .X to char-representation for display
   905                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
   906                                  sty tdgec1+0
   907                                  stx tdgec1+1
   908                          
   909                                  jsr checkpoint
   910                                  !8 0
   911                                  !text "dos_geterrorcode <=$"
   912                          tdgec1: !text "%%>"
   913                                  !8 0
   914                          }
   915                          
   916  8f81 4c1082                     jmp return_from_trap_with_success
   917                          
   918                          ;;         ========================
   919                          
   920                          trap_dos_d81attach0:
   921                          
   922                                  +Checkpoint "trap_dos_d81attach0"
   923                          
   924  8f84 208799                     jsr dos_d81attach0
   925  8f87 4c6e8c                     jmp return_from_trap_with_carry_flag
   926                          
   927                          ;;         ========================
   928                          
   929                          trap_dos_d81attach1:
   930                          
   931                                  +Checkpoint "trap_dos_d81attach1"
   932                          
   933  8f8a 20ed99                     jsr dos_d81attach1
   934  8f8d 4c6e8c                     jmp return_from_trap_with_carry_flag
   935                          
   936                          ;;         ========================
   937                          
   938                          trap_dos_d81detach:
   939                          
   940  8f90 207699                     jsr dos_d81detach
   941                          
   942  8f93 4c1082                     jmp return_from_trap_with_success
   943                          
   944                          ;;         ========================
   945                          
   946                          trap_dos_d81write_en:
   947                          
   948  8f96 20af8f                     jsr dos_d81write_en
   949  8f99 4c6e8c                     jmp return_from_trap_with_carry_flag
   950                          
   951                          ;;         ========================
   952                          
   953                          trap_dos_get_proc_desc:
   954  8f9c 200eab                     jsr hypervisor_setup_copy_region
   955  8f9f 900b                       bcc @bad
   956  8fa1 a000                       ldy #0
   957                          @copyloop:
   958  8fa3 b900bd                     lda currenttask_block,y
   959  8fa6 9106                       sta (<hypervisor_userspace_copy_vector),y
   960  8fa8 c8                         iny
   961  8fa9 d0f8                       bne @copyloop
   962  8fab 38                         sec
   963                          @bad:
   964  8fac 4c6e8c                     jmp return_from_trap_with_carry_flag
   965                          
   966                          dos_d81write_en:
   967  8faf ad8bd6                     lda $d68b
   968  8fb2 2903                       and #$03
   969  8fb4 c903                       cmp #$03
   970  8fb6 d00c                       bne td81we1
   971  8fb8 0904                       ora #$04
   972  8fba 8d8bd6                     sta $d68b
   973                          
   974                                  ;; Mark disk image write-enabled in proces descriptor
   975  8fbd ad11bd                     lda currenttask_d81_image0_flags
   976  8fc0 0904                       ora #d81_image_flag_write_en
   977                          
   978  8fc2 38                         sec
   979  8fc3 60                         rts
   980                          
   981                          td81we1:
   982                                  ;; No disk image mounted
   983                                  ;;
   984                          
   985                                  +Checkpoint "dos_d81writ_en-FAIL"
   986                          
   987  8fc4 a980                       lda #dos_errorcode_no_such_disk
   988  8fc6 8dfabc                     sta dos_error_code
   989  8fc9 18                         clc
   990  8fca 60                         rts
   991                          
   992                          ;;         ========================
   993                          
   994                          ;; BG: the following are placeholders for the future development
   995                          
   996                          trap_dos_getdisksize:
   997                          trap_dos_getcwd:
   998                          trap_dos_mkdir:
   999                          trap_dos_rmdir:
  1000                          trap_dos_writefile:
  1001                          trap_dos_seekfile:
  1002                          trap_dos_rmfile:
  1003                          trap_dos_fstat:
  1004                          trap_dos_rename:
  1005                          trap_dos_filedate:
  1006                          trap_dos_gettasklist:
  1007                          trap_dos_sendmessage:
  1008                          trap_dos_receivemessage:
  1009                          trap_dos_writeintotask:
  1010                          trap_dos_readoutoftask:
  1011                          trap_dos_terminateothertask:
  1012                          trap_dos_create_task_native:
  1013                          trap_dos_load_into_task:
  1014                          trap_dos_create_task_c64:
  1015                          trap_dos_create_task_c65:
  1016                          trap_dos_exit_and_switch_to_task:
  1017                          trap_dos_switch_to_task:
  1018                          trap_dos_exit_task:
  1019                          
  1020  8fcb 4c2f82                     jmp invalid_subfunction;;
  1021                          
  1022                          ;;         ========================
  1023                          
  1024                          ;; ======================================================================================
  1025                          ;; ======================================================================================
  1026                          ;; ======================================================================================
  1027                          
  1028                          ;; Clear all file descriptors.
  1029                          ;; This just consists of setting the drive number to $ff,
  1030                          ;; which indicates "no such drive"
  1031                          ;; Drive number field is first byte of file descriptor for convenience
  1032                          
  1033                          dos_clear_filedescriptors:
  1034                          
  1035                                  ;; XXX - This doesn't close the underlying file descriptors!
  1036                                  ;;
  1037  8fce a9ff                       lda #$ff
  1038  8fd0 8d80bd                     sta currenttask_filedescriptor0
  1039  8fd3 8da0bd                     sta currenttask_filedescriptor1
  1040  8fd6 8dc0bd                     sta currenttask_filedescriptor2
  1041  8fd9 8de0bd                     sta currenttask_filedescriptor3
  1042                          
  1043                          	;; XXX - Doesn't flush any files open for write
  1044  8fdc 8db8bc                     sta dos_file_descriptors
  1045  8fdf 8dc8bc                     sta dos_file_descriptors+$10
  1046  8fe2 8dd8bc                     sta dos_file_descriptors+$20
  1047  8fe5 8de8bc                     sta dos_file_descriptors+$30
  1048                          	
  1049  8fe8 38                         sec
  1050  8fe9 60                         rts
  1051                          
  1052                          ;;         ========================
  1053                          
  1054                          ;; Read partition table from SD card.
  1055                          ;;
  1056                          ;; Add all FAT32 partitions to our list of known disks.
  1057                          ;;
  1058                          ;; This routine assumes that the SD card has been reset and is ready to
  1059                          ;; service requests.
  1060                          ;;
  1061                          ;; XXX - We don't support extended partition tables! Only the old-fashion
  1062                          ;; 4 DOS partitions.  We might get excited and add support for them later
  1063                          ;;
  1064                          dos_read_partitiontable:
  1065                          
  1066                                  ;; clear error code
  1067                                  ;;
  1068  8fea a900                       lda #0
  1069  8fec 8dfabc                     sta dos_error_code
  1070                          
  1071                                  ;; Clear the list of known disks
  1072                                  ;;
  1073  8fef 205d90                     jsr dos_initialise_disklist
  1074                          
  1075  8ff2 204690                     jsr dos_read_mbr
  1076  8ff5 903e                       bcc l_drpt_fail
  1077                          
  1078                                  ;; Make the sector buffer visible
  1079                                  ;;
  1080  8ff7 20cf9f                     jsr sd_map_sectorbuffer
  1081                          
  1082  8ffa a902                       lda #dos_errorcode_bad_signature
  1083  8ffc 8dfabc                     sta dos_error_code
  1084                          
  1085                                  ;; check for $55, $AA MBR signature
  1086                                  ;;
  1087  8fff adfedf                     lda sd_sectorbuffer+$1FE
  1088  9002 c955                       cmp #$55
  1089  9004 d02f                       bne l_drpt_fail
  1090  9006 adffdf                     lda sd_sectorbuffer+$1FF
  1091  9009 c9aa                       cmp #$AA
  1092  900b d028                       bne l_drpt_fail
  1093                          
  1094                                  ;; yes, $55AA MBR signature was found
  1095                          
  1096                                  +Checkpoint "Found $55, $AA at $1FE on MBR"
  1097                          
  1098                                  ;; Partitions start at offsets $1BE, $1CE, $1DE, $1EE
  1099                                  ;; so consider each in turn.  Opening the partition causes other sectors to
  1100                                  ;; be read, so we must re-read the MBR between each
  1101                          
  1102                                  ;; get pointer to second half of sector buffer so that we can access the
  1103                                  ;; partition entries as we see fit.
  1104                                  ;;
  1105                          
  1106  900d a9be                       lda #<(sd_sectorbuffer+$1BE)
  1107  900f 8500                       sta <dos_scratch_vector
  1108  9011 a9df                       lda #>(sd_sectorbuffer+$1BE)
  1109  9013 8501                       sta <(dos_scratch_vector+1)
  1110                                  +Checkpoint "=== Checking Partition #1 at $01BE"
  1111  9015 206390                     jsr dos_consider_partition_entry
  1112                          
  1113  9018 204690                     jsr dos_read_mbr
  1114  901b 9018                       bcc l_drpt_fail
  1115  901d a9ce                       lda #<(sd_sectorbuffer+$1CE)
  1116  901f 8500                       sta <dos_scratch_vector
  1117                                  +Checkpoint "=== Checking Partition #2 at $01CE"
  1118  9021 206390                     jsr dos_consider_partition_entry
  1119                          
  1120  9024 204690                     jsr dos_read_mbr
  1121  9027 900c                       bcc l_drpt_fail
  1122  9029 a9de                       lda #<(sd_sectorbuffer+$1DE)
  1123  902b 8500                       sta <dos_scratch_vector
  1124                                  +Checkpoint "=== Checking Partition #3 at $01DE"
  1125  902d 206390                     jsr dos_consider_partition_entry
  1126                          
  1127  9030 204690                     jsr dos_read_mbr
  1128  9033 b003                       bcs +
  1129                          l_drpt_fail:
  1130  9035 4ce190                     jmp drpt_fail
  1131  9038 a9ee               +       lda #<(sd_sectorbuffer+$1EE)
  1132  903a 8500                       sta <dos_scratch_vector
  1133                                  +Checkpoint "=== Checking Partition #4 at $01EE"
  1134  903c 206390                     jsr dos_consider_partition_entry
  1135                          
  1136  903f a900                       lda #0
  1137  9041 8dfabc                     sta dos_error_code
  1138  9044 38                         sec
  1139  9045 60                         rts
  1140                          
  1141                          ;;         ========================
  1142                          
  1143                          dos_read_mbr:
  1144                          
  1145                                  ;; Offset zero on disk
  1146                                  ;;
  1147                          
  1148  9046 a900                       lda #0
  1149  9048 8d81d6                     sta sd_address_byte0
  1150  904b 8d82d6                     sta sd_address_byte1
  1151  904e 8d83d6                     sta sd_address_byte2
  1152  9051 8d84d6                     sta sd_address_byte3
  1153                          
  1154                                  +Checkpoint "Reading MBR @ 0x00000000"
  1155                          
  1156                                  ;; Read sector
  1157                                  ;;
  1158  9054 20e49f                     jsr sd_readsector
  1159  9057 b003                       bcs +
  1160  9059 4ce190                     jmp drpt_fail
  1161  905c 60                 +       rts
  1162                          
  1163                          ;;         ========================
  1164                          
  1165                          dos_initialise_disklist:
  1166                          
  1167  905d a900                       lda #0
  1168  905f 8d01bc                     sta dos_disk_count
  1169  9062 60                         rts
  1170                          
  1171                          ;;         ========================
  1172                          
  1173                          dos_consider_partition_entry:
  1174                          	
  1175  9063 a900                       lda #$00
  1176  9065 8dfabc                     sta dos_error_code
  1177                          
  1178                                  ;; Offset within partition table entry of partition type
  1179                                  ;;
  1180                                  ;; BG: make this a hash-define
  1181                                  ;;
  1182  9068 a004                       ldy #$04
  1183                          
  1184                                  ;; Get partition type byte
  1185                                  ;;
  1186  906a b100                       lda (<dos_scratch_vector),y
  1187                          
  1188                                  ;; We like FAT32 partitions, whether LBA or CHS addressed, although we actually
  1189                                  ;; use LBA addressing.  XXX - Can this cause problems for CHS partitions?
  1190                                  ;; (SD cards which must really use LBA, can still show up with CHS partitions!
  1191                                  ;;  this is really annoying.)
  1192                                  ;;
  1193  906c c90c                       cmp #constant_partition_type_fat32_lba        ;; compare with 0x0C
  1194  906e f02c                       beq partitionisinteresting_lba
  1195                          
  1196  9070 c90b                       cmp #constant_partition_type_fat32_chs        ;; compare with 0x0B
  1197  9072 f02b                       beq partitionisinteresting_chs
  1198                          
  1199  9074 c941                       cmp #constant_partition_type_megea65_sys ;; compare with 0x41
  1200  9076 f008                       beq partitionisinteresting_mega65sys
  1201                          
  1202  9078 a901                       lda #dos_errorcode_partition_not_interesting
  1203  907a 8dfabc                     sta dos_error_code
  1204  907d 4cdf90                     jmp partitionisnotinteresting
  1205                          
  1206                          ;;         ========================
  1207                          
  1208                          partitionisinteresting_mega65sys:
  1209                          
  1210                                  +Checkpoint "MEGA65 System Partition (type=0x41)"
  1211                          
  1212                                  ;; Only one system partition
  1213  9080 adfcbc                     lda syspart_present
  1214  9083 f003                       beq +
  1215  9085 4ce190                     jmp partitionerror
  1216                          +
  1217                                  ;; Store start and length of System partition
  1218                                  ;; (These are the first two fields of the syspart structure
  1219                                  ;;  to facilitate a simple copy here)
  1220  9088 a008                       ldy #$08
  1221  908a a200                       ldx #$00
  1222                          
  1223  908c b100               spc1:   lda (<dos_scratch_vector),y
  1224  908e 9dc0bb                     sta syspart_structure,x
  1225  9091 e8                         inx
  1226  9092 c8                         iny
  1227  9093 c010                       cpy #$10
  1228  9095 d0f5                       bne spc1
  1229                          
  1230  9097 205882                     jsr syspart_open
  1231  909a 38                         sec
  1232  909b 60                         rts
  1233                          
  1234                          partitionisinteresting_lba:
  1235                          
  1236                                  +Checkpoint "Partn has fat32_lba (type=0x0c)"
  1237                          
  1238  909c 4ca290                     jmp partitionisinteresting
  1239                          
  1240                          partitionisinteresting_chs:
  1241                          
  1242                                  +Checkpoint "WARN:Partn has fat32_chs (type=0x0b)"
  1243                          
  1244  909f 4ca290                     jmp partitionisinteresting
  1245                          
  1246                          ;;         ========================
  1247                          
  1248                          partitionisinteresting:
  1249                          
  1250                                  ;; Make sure we have a spare disk slot
  1251  90a2 ad01bc                     lda dos_disk_count
  1252  90a5 c906                       cmp #dos_max_disks
  1253  90a7 d003                       bne +
  1254  90a9 4ce190                     jmp partitionerror
  1255                          +
  1256                                  ;; Partition is FAT32 (either 0B or 0C), so add it to the list
  1257                          
  1258                                  ;; Disk structures in dos_disk_table are 32 bytes long, so shift count left
  1259                                  ;; 5 times to get offset in dos disk list table
  1260                                  ;;
  1261                                  ;; initially, dos_disk_count=00 so shifting results in =00
  1262                                  ;;
  1263  90ac ad01bc                     lda dos_disk_count
  1264  90af 0a                         asl
  1265  90b0 0a                         asl
  1266  90b1 0a                         asl
  1267  90b2 0a                         asl
  1268  90b3 0a                         asl
  1269  90b4 aa                         tax
  1270                          
  1271                                  ;; Copy relevant fields into place
  1272                                  ;; These are start of partition and length of partition (both in sectors)
  1273                                  ;; XXX - This requires that our dos_disk_table has these two fields together
  1274                                  ;; at the start of the structure.
  1275                                  ;;
  1276  90b5 a008                       ldy #$08        ;; partition_lba_begin (4 bytes)
  1277                          
  1278  90b7 b100               dcpe1:  lda (<dos_scratch_vector),y
  1279  90b9 9d00bb                     sta dos_disk_table,x
  1280  90bc e8                         inx
  1281  90bd c8                         iny
  1282  90be c010                       cpy #$10        ;; partition_num_sectors (4 bytes)
  1283  90c0 d0f5                       bne dcpe1
  1284                          
  1285                                  ;; Examine the internals of the partition to get the remaining fields.
  1286                                  ;; At this point we no longer use the contents of the MBR
  1287                                  ;;
  1288                          
  1289  90c2 20e390                     jsr dos_disk_openpartition
  1290  90c5 901a                       bcc partitionerror
  1291                          
  1292                          !if DEBUG_HYPPO {
  1293                                  jsr dump_disk_table
  1294                          }
  1295                          
  1296                                  ;; Check if partition is bootable (or the only partition)
  1297                                  ;; If so, make the partition the default disk
  1298                                  ;;
  1299                                  ;; BG, we should examine all four partitions before setting the default disk
  1300                                  ;;
  1301  90c7 ad01bc                     lda dos_disk_count
  1302  90ca f006                       beq makethispartitionthedefault
  1303  90cc a000                       ldy #$00
  1304  90ce b100                       lda (<dos_scratch_vector),y
  1305  90d0 1008                       bpl dontmakethispartitionthedefault
  1306                          
  1307                          
  1308                          makethispartitionthedefault:
  1309  90d2 ad01bc                     lda dos_disk_count
  1310  90d5 8d02bc                     sta dos_default_disk
  1311                          
  1312                          !if DEBUG_HYPPO {
  1313                                  ;; print out this message to Checkpoint
  1314                                  ;;
  1315                          
  1316                                  tax                                ;; convert .X to char-representation for display
  1317                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1318                                  sty mtptd
  1319                                  stx mtptd+1
  1320                          
  1321                                  jsr checkpoint
  1322                                  !8 0
  1323                                  !text "dos_default_disk = "
  1324                          mtptd:  !text "xx"
  1325                                  !8 0
  1326                          
  1327                          ;; jsr dump_disk_table
  1328                          }
  1329                          
  1330                                  ;; return OK
  1331                                  ;;
  1332  90d8 38                         sec
  1333  90d9 60                         rts
  1334                          
  1335                          ;;         ========================
  1336                          
  1337                          dontmakethispartitionthedefault:
  1338                          
  1339  90da ae01bc                     ldx dos_disk_count
  1340                          
  1341                          !if DEBUG_HYPPO {
  1342                                  ;; print out this message to Checkpoint
  1343                                  ;;
  1344                          
  1345                                                                  ;; convert .X to char-representation for display
  1346                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1347                                  stx mtptd2
  1348                          
  1349                                  jsr checkpoint
  1350                                  !8 0
  1351                                  !text "Part#"
  1352                          mtptd2: !text "x NOT set to the default_disk"
  1353                                  !8 0
  1354                          
  1355                          ;; jsr dump_disk_table
  1356                          }
  1357                          
  1358                                  ;; return OK
  1359                                  ;;
  1360                          
  1361  90dd 38                         sec
  1362  90de 60                         rts
  1363                          
  1364                          ;;         ========================
  1365                          
  1366                          partitionisnotinteresting:
  1367                          
  1368                                  ;; return OK
  1369                                  ;;
  1370                          
  1371                                  +Checkpoint "Partition not interesting"
  1372                          
  1373  90df 38                         sec
  1374  90e0 60                         rts
  1375                          
  1376                          ;;         ========================
  1377                          
  1378                          drpt_fail:
  1379                          
  1380                                  ;; error code will already be set
  1381                          
  1382                          partitionerror:
  1383                          
  1384                                  ;; return ERROR
  1385                          
  1386                          !if DEBUG_HYPPO {
  1387                                  ldx dos_error_code                ;; convert .X to char-representation for display
  1388                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1389                                  sty perr
  1390                                  stx perr+1
  1391                          
  1392                                  jsr checkpoint
  1393                                  !8 0
  1394                                  !text "partitionerror="
  1395                          perr:   !text "xx"
  1396                                  !8 0
  1397                          }
  1398                          
  1399  90e1 18                         clc
  1400  90e2 60                         rts
  1401                          
  1402                          dos_disk_openpartition:
  1403                          
  1404                                  +Checkpoint "dos_disk_openpartition: (examine Vol ID)"
  1405                          
  1406                                  ;; A contains the disk number we are trying to open.
  1407                                  ;;
  1408  90e3 a900                       lda #$00
  1409  90e5 8dfabc                     sta dos_error_code
  1410                          
  1411                                  ;; Load first sector of file system and parse.
  1412                                  ;; This is the Volume ID pointed to by the PartitionTable in the MBR
  1413                          
  1414                                  ;; Get offset of disk entry in our disk table structure
  1415                                  ;;
  1416  90e8 ad01bc                     lda dos_disk_count
  1417  90eb 0a                         asl
  1418  90ec 0a                         asl
  1419  90ed 0a                         asl
  1420  90ee 0a                         asl
  1421  90ef 0a                         asl
  1422  90f0 8d04bc                     sta dos_disk_table_offset
  1423                          
  1424                                  ;; Now pull the start sector from the structure and get ready to request
  1425                                  ;; that structure from the SD card.
  1426                                  ;;
  1427  90f3 0900                       ora #fs_start_sector        ;; OR with 00 does nothing, but this is the standard
  1428  90f5 a8                         tay
  1429  90f6 a200                       ldx #$00
  1430                          
  1431  90f8 b900bb             ddop1:  lda dos_disk_table,y
  1432  90fb 9d81d6                     sta sd_address_byte0,x
  1433  90fe c8                         iny
  1434  90ff e8                         inx
  1435  9100 e004                       cpx #$04
  1436  9102 d0f4                       bne ddop1
  1437                          
  1438                          !if DEBUG_HYPPO {
  1439                          jsr dumpsectoraddress        ;; debugging
  1440                          }
  1441                          
  1442  9104 20e49f                     jsr sd_readsector
  1443  9107 90d8                       bcc partitionerror
  1444                          
  1445                                  ;; We now have the sector, so parse.
  1446                          
  1447  9109 20cf9f                     jsr sd_map_sectorbuffer
  1448                          
  1449                          ;;         ========================
  1450                          
  1451                                  ;; Check for 55/AA singature (again, for the Vol-ID of this partition)
  1452                                  ;;
  1453                          
  1454  910c a902                       lda #dos_errorcode_bad_signature
  1455  910e 8dfabc                     sta dos_error_code
  1456                          
  1457  9111 adfedf                     lda sd_sectorbuffer+$1FE
  1458  9114 c955                       cmp #$55
  1459  9116 f003                       beq ddop1a
  1460  9118 4ce190                     jmp partitionerror
  1461                          ddop1a:
  1462  911b adffdf                     lda sd_sectorbuffer+$1FF
  1463  911e c9aa                       cmp #$AA
  1464  9120 f003                       beq ddop1b
  1465  9122 4ce190                     jmp partitionerror
  1466                          ddop1b:
  1467                                  +Checkpoint "Partn has $55, $AA GOOD"
  1468                          
  1469                                  ;; Start populating fields
  1470                          
  1471                          ;;         BG assumes this is all correct...
  1472                          
  1473                          ;;         ========================
  1474                          
  1475                                  ;; Filter out obviously FAT16/FAT12 file systems
  1476                                  ;;
  1477  9125 a903                       lda #dos_errorcode_is_small_fat
  1478  9127 8dfabc                     sta dos_error_code
  1479                                  ;;
  1480                                  ;; BG i think we dont need to check this for minimal operation
  1481                                  ;;
  1482                                  ;; for fat32, the 11'th entry is unused, http:;;www.easeus.com/resource/fat32-disk-structure.htm
  1483                                  ;;
  1484  912a ad11de                     lda sd_sectorbuffer+$11        ;; this is NOT the MBSyte of the number of FATs
  1485  912d d0b2                       bne partitionerror
  1486                          
  1487                          ;;         ========================
  1488                          
  1489                                  ;; get # copies of fat
  1490                                  ;;
  1491  912f ad04bc                     lda dos_disk_table_offset
  1492  9132 0917                       ora #fs_fat32_fat_copies        ;; is $17
  1493  9134 a8                         tay
  1494  9135 ad10de                     lda sd_sectorbuffer+$10        ;; should be 2
  1495  9138 9900bb                     sta dos_disk_table,y
  1496                          
  1497                          ;;         ========================
  1498                          
  1499                                  ;; With root directory entries = 0, the reserved sector count
  1500                                  ;; is the number of reserved sectors, plus (copies of fat) *
  1501                                  ;; (sectors in one copy of the fat).
  1502                                  ;; the first FAT begins immediately after the reserved sectors
  1503                          
  1504                                  ;; Determine system sector count
  1505                                  ;; (= reserved sectors + fat_count * fat_sectors)
  1506                                  ;; $20 + $EE5 + $EE5 = $1DEA
  1507                                  ;; plus partition offset = $81 = $1E6B
  1508                                  ;; partition length = $3BAF7F
  1509                                  ;; $08 sectors / cluster
  1510                                  ;; so data sectors in partition = $3BAF7F - $1DEA = $3B9195
  1511                                  ;; = $77232 clusters
  1512                          
  1513                                  ;; BG does not like the above reasoning, ie fixed number of reserved sectors.
  1514                          
  1515                                  ;; Reserved sector field on disk is only 2 bytes!
  1516                                  ;;
  1517  913b ad04bc                     lda dos_disk_table_offset
  1518  913e 090d                       ora #fs_fat32_system_sectors        ;; is $0D
  1519  9140 a8                         tay
  1520  9141 a200                       ldx #$00
  1521                          
  1522  9143 bd0ede             ddop10: lda sd_sectorbuffer+$0E,x
  1523  9146 9900bb                     sta dos_disk_table,y
  1524  9149 c8                         iny
  1525  914a e8                         inx
  1526  914b e002                       cpx #$02
  1527  914d d0f4                       bne ddop10
  1528                          
  1529                          ;;         ========================
  1530                          
  1531                                  ;; Store length of one copy of the FAT
  1532                                  ;;
  1533  914f ad04bc                     lda dos_disk_table_offset
  1534  9152 0909                       ora #fs_fat32_length_of_fat        ;; is $09
  1535  9154 a8                         tay
  1536  9155 a200                       ldx #$00
  1537                          
  1538  9157 bd24de             ddop11: lda sd_sectorbuffer+$24,x        ;; sectors_per_fat
  1539  915a 9900bb                     sta dos_disk_table,y
  1540  915d c8                         iny
  1541  915e e8                         inx
  1542  915f e004                       cpx #$04
  1543  9161 d0f4                       bne ddop11
  1544                          
  1545                          ;;         ========================
  1546                          
  1547                                  ;; Get number of reserved clusters.  We only allow upto 255 reserved
  1548                                  ;; clusters, so report an error if the upper three bytes are not zero
  1549                                  ;;
  1550                                  ;; BG: why only 255 reserved clusters? and isnt it reserved sectors instead?
  1551                                  ;; and seems to be looking at the root_dir_first_cluster
  1552                                  ;;
  1553  9163 a904                       lda #dos_errorcode_too_many_reserved_clusters
  1554  9165 8dfabc                     sta dos_error_code
  1555                          
  1556  9168 ad2dde                     lda sd_sectorbuffer+$2C+1
  1557  916b 0d2ede                     ora sd_sectorbuffer+$2C+2
  1558  916e 0d2fde                     ora sd_sectorbuffer+$2C+3
  1559                          
  1560                                  ;; XXX - 16 bit BNE should be fine here! Why doesn't it work?
  1561                                  ;;         bne partitionerror
  1562                          
  1563  9171 f003                       beq ddop11ok
  1564  9173 4ce190                     jmp partitionerror
  1565                          
  1566                          ;;         ========================
  1567                          
  1568                          ddop11ok:
  1569                          
  1570                                  ;; <64K reserved clusters, so file system passes this test -- just copy number
  1571                                  ;;
  1572                                  ;; BG does not agree with the logic, of <64k reservedclusters to passes
  1573                                  ;; BG the code below could be changed to be same as lda,ora,tay
  1574                                  ;;
  1575                                  ;; BG, so by design, we reject any Vol_ID that has
  1576                                  ;; RootDirFirstCluster[3..0] not equal to $00000002
  1577                                  ;;
  1578  9176 ac04bc                     ldy dos_disk_table_offset
  1579  9179 ad2cde                     lda sd_sectorbuffer+$2C        ;; 2c is the ClusterNumberOfFirstRootDir
  1580  917c 990fbb                     sta dos_disk_table + fs_fat32_reserved_clusters,y
  1581                          
  1582                          ;; Checkpoint("dos_disk_table-1")
  1583                          ;; jsr dump_disk_table        ; debugging
  1584                          
  1585                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00 = (fs_start_sector),                       (fs_sector_count)
  1586                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02 = type, (sectorsPerFat),(reservedSectors),(reservedClusters)
  1587                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02 = x..x                                ,(fs_fat32_fat_copies)
  1588                          ;; dos_disk_table[18-1F] = 00,00,00,00,xx,xx,xx,xx
  1589                          
  1590                          ;;         ========================
  1591                          
  1592                                  ;; Now work out the sector of cluster 0, by adding:
  1593                                  ;;   fs_fat32_system_sectors
  1594                                  ;; + the length of each FAT
  1595                                  ;; + start of partition,
  1596                                  ;; and store this result in dos_disk_table[18..1B]
  1597                                  ;;
  1598                                  ;; For efficiency, we pull the fields we need out of the sector buffer,
  1599                                  ;; instead of working out their offsets in the dos_disk_table structure.
  1600                                  ;; BG disagree, we know the offsets of the fields in dos_disk_table
  1601                          
  1602                                  ;; Start with fs_fat32_system_sectors (which is 16 bits), then pad MSBs with zero
  1603                                  ;;
  1604  917f ad04bc                     lda dos_disk_table_offset
  1605  9182 090d                       ora #fs_fat32_system_sectors        ;; is $0D
  1606  9184 a8                         tay
  1607  9185 ad04bc                     lda dos_disk_table_offset
  1608  9188 0918                       ora #fs_fat32_cluster0_sector        ;; is $18
  1609  918a aa                         tax
  1610  918b a302                       ldz #$02
  1611                          
  1612  918d b900bb             ddop2:  lda dos_disk_table,y
  1613  9190 9d00bb                     sta dos_disk_table,x
  1614  9193 c8                         iny
  1615  9194 e8                         inx
  1616  9195 3b                         dez
  1617  9196 d0f5                       bne ddop2
  1618                          
  1619                                  ;; clear top 16 bits of cluster0_sector (dos_disk_table[1A,1B])
  1620                                  ;;
  1621                                  ;; BG: why tza, just do lda#$00
  1622  9198 6b                         tza
  1623  9199 9d00bb                     sta dos_disk_table+0,x
  1624  919c 9d01bb                     sta dos_disk_table+1,x
  1625                          
  1626                          ;; Checkpoint("dos_disk_table-2")
  1627                          ;; jsr dump_disk_table        ; debugging
  1628                          
  1629                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1630                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1631                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02
  1632                          ;; dos_disk_table[18-1F] = 38,02,00,00,xx,xx,xx,xx -> $00000238
  1633                          
  1634                          
  1635                          ;;         ========================
  1636                          
  1637                                  ;; Now add length of fat for each copy of the fat
  1638                                  ;;
  1639  919f a905                       lda #dos_errorcode_not_two_fats
  1640  91a1 8dfabc                     sta dos_error_code
  1641                          
  1642                                  ;; BG #FATs should be sourced from dos_disk_table[17], not from buffer+$10
  1643                          
  1644  91a4 ab10de                     ldz sd_sectorbuffer+$10         ;; # of FAT copies
  1645  91a7 f004                       beq l_partitionerror            ;; There must be at least one copy of the FAT!
  1646  91a9 c202                       cpz #2
  1647  91ab f003                       beq ddop_addnextfatsectors
  1648                          l_partitionerror:
  1649  91ad 4ce190                     jmp partitionerror
  1650                          
  1651                          ddop_addnextfatsectors:
  1652  91b0 ad04bc                     lda dos_disk_table_offset
  1653  91b3 0918                       ora #fs_fat32_cluster0_sector   ;; is $18
  1654  91b5 a8                         tay
  1655  91b6 a200                       ldx #$00
  1656  91b8 18                         clc
  1657  91b9 08                         php                             ;; push processor-status (to remember the carry-flag)
  1658                          
  1659  91ba 28                 ddop12: plp                             ;; pull processor-status
  1660  91bb b900bb                     lda dos_disk_table,y            ;; cluster0_sector
  1661  91be 7d24de                     adc sd_sectorbuffer+$24,x       ;; sectors per fat ;BG should load from dos_disk_table[09]
  1662  91c1 9900bb                     sta dos_disk_table,y            ;; cluster0_sector
  1663  91c4 08                         php
  1664  91c5 c8                         iny
  1665  91c6 e8                         inx
  1666  91c7 e004                       cpx #$04
  1667  91c9 d0ef                       bne ddop12
  1668                          
  1669  91cb 28                         plp
  1670                                  ;;
  1671                                  ;; as Z was initially 2 (#FATs), we do this loop twice
  1672                                  ;; resulting in 2x the sectorsPerFat added to "reservedSectors".
  1673  91cc 3b                         dez
  1674  91cd d0e1                       bne ddop_addnextfatsectors
  1675                          
  1676                          ;; Checkpoint("dos_disk_table-3")
  1677                          ;; jsr dump_disk_table        ; debugging
  1678                          
  1679                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1680                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1681                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02
  1682                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx -> $00000238 + ($000003e6 + $000003e6) = $00000A04
  1683                          
  1684                          ;; BG does not agree with the calculations below, why do we need to calculate it this way?
  1685                          
  1686                                  ;; Next, we temporarily need the number of data sectors, so that we can work
  1687                                  ;; out the number of clusters in the file system.
  1688                                  ;; This is the total number of sectors in the partition, minus the number of
  1689                                  ;; reserved sectors.
  1690                          
  1691                                  ;; Subtract (cluster 0 sector = 32 bits) from
  1692                                  ;; (length of filesystem in sectors = 32 bits)
  1693                          
  1694  91cf ad04bc                     lda dos_disk_table_offset
  1695  91d2 0918                       ora #fs_fat32_cluster0_sector   ;; is $18
  1696  91d4 aa                         tax
  1697  91d5 ad04bc                     lda dos_disk_table_offset
  1698  91d8 0912                       ora #fs_fat32_cluster_count     ;; is $12
  1699  91da a8                         tay
  1700  91db 38                         sec
  1701  91dc ad20de                     lda sd_sectorbuffer+$20+0     ;; from FAT spec, this is number of sectors in partition
  1702  91df fd00bb                     sbc dos_disk_table+0,x        ;; x=$18 initially
  1703  91e2 9900bb                     sta dos_disk_table+0,y        ;; y=$12 initially
  1704  91e5 ad21de                     lda sd_sectorbuffer+$20+1
  1705  91e8 fd01bb                     sbc dos_disk_table+1,x
  1706  91eb 9901bb                     sta dos_disk_table+1,y
  1707  91ee ad22de                     lda sd_sectorbuffer+$20+2
  1708  91f1 fd02bb                     sbc dos_disk_table+2,x
  1709  91f4 9902bb                     sta dos_disk_table+2,y
  1710  91f7 ad23de                     lda sd_sectorbuffer+$20+3
  1711  91fa fd03bb                     sbc dos_disk_table+3,x
  1712  91fd 9903bb                     sta dos_disk_table+3,y
  1713                          
  1714                          ;;         ========================
  1715                          
  1716                          get_sec_per_cluster:
  1717                                  ;; Get sectors per cluster (and store in dos_disk_table entry)
  1718                                  ;; (this gets destoryed below, so we have to re-read it again after)
  1719                                  ;;
  1720  9200 ad04bc                     lda dos_disk_table_offset
  1721  9203 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1722  9205 a8                         tay
  1723  9206 ad0dde                     lda sd_sectorbuffer+$0D
  1724  9209 9900bb                     sta dos_disk_table,y
  1725                          
  1726                          ;; Checkpoint("dos_disk_table-4")
  1727                          ;; jsr dump_disk_table        ; debugging
  1728                          
  1729                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1730                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1731                          ;; dos_disk_table[10-17] = 00,00,FC,95,0F,00,08,02 -> new data appears
  1732                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1733                          
  1734                          
  1735                          ;;         ========================
  1736                          
  1737                                  ;; Now divide number of sectors available for clusters by the number of
  1738                                  ;; sectors per cluster to obtain the number of actual clusters in the file
  1739                                  ;; system.  Since clusters must contain a power-of-two number of sectors,
  1740                                  ;; we can implement the division using a simple shift.
  1741                          
  1742                                  ;; copy number of sectors into number of sectors ready for shifting down
  1743                          
  1744                                  ;; Put number of sectors per cluster into Z, and don't shift if there is only
  1745                                  ;; one sector per cluster.
  1746                                  ;;
  1747  920c ad0dde                     lda sd_sectorbuffer+$0D            ;; because of the checkpoint message above
  1748  920f 4b                         taz                                ;; why store .A in .Z anyway
  1749                          
  1750  9210 29fe                       and #$fe        ;; #%1111.1110
  1751  9212 f01e                       beq ddop_gotclustercount
  1752                          
  1753                          ddop14:
  1754                                  ;; Divide cluster count by two.  This is a 32-bit value, so we have to use
  1755                                  ;; ROR to do the shift, and propagate the carry bits between the bytes.
  1756                                  ;; This also entails doing it from the last byte, backwards.
  1757                          
  1758                                  ;; Get offset of start of (sectors_per_cluster) field
  1759                                  ;;
  1760  9214 ad04bc                     lda dos_disk_table_offset
  1761  9217 0912                       ora #fs_fat32_cluster_count        ;; is $12
  1762                          
  1763                                  ;; get offset of last byte in this field
  1764                                  ;;
  1765  9219 18                         clc
  1766  921a 6903                       adc #$03
  1767  921c a8                         tay
  1768                          
  1769  921d a203                       ldx #$03
  1770  921f 18                         clc
  1771                          
  1772  9220 b900bb             ddop15: lda dos_disk_table,y
  1773  9223 6a                         ror
  1774  9224 9900bb                     sta dos_disk_table,y
  1775  9227 88                         dey
  1776  9228 ca                         dex
  1777  9229 10f5                       bpl ddop15
  1778                          
  1779  922b 6b                         tza
  1780  922c 4a                         lsr
  1781  922d 4b                         taz
  1782  922e 29fe                       and #$fe
  1783  9230 d0e2                       bne ddop14
  1784                          
  1785                          ddop_gotclustercount:
  1786                          
  1787                          ;; Checkpoint("dos_disk_table-5")
  1788                          ;; jsr dump_disk_table        ; debugging
  1789                          
  1790                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1791                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1792                          ;; dos_disk_table[10-17] = 00,00,AF,7C,00,00,08,02 -> new data appears
  1793                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1794                          
  1795                          
  1796                                  ;; Re-get sectors per cluster (and store in dos_disk_table entry)
  1797                                  ;; (this was destroyed in the calculation above)
  1798                                  ;;
  1799  9232 ad04bc                     lda dos_disk_table_offset
  1800  9235 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1801  9237 a8                         tay
  1802  9238 ad0dde                     lda sd_sectorbuffer+$0D
  1803  923b 9900bb                     sta dos_disk_table,y
  1804                          
  1805                          ;; Checkpoint("dos_disk_table-6")
  1806                          ;; jsr dump_disk_table        ; debugging
  1807                          
  1808                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1809                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1810                          ;; dos_disk_table[10-17] = 00,00,AF,7C,00,00,08,02
  1811                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1812                          
  1813                          ;;         ========================
  1814                          
  1815                                  ;; filter out non-FAT32 filesystems
  1816                                  ;; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
  1817                                  ;; such file systems, which should be rare, anyway.
  1818                          
  1819  923e ad04bc                     lda dos_disk_table_offset
  1820  9241 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1821  9243 a8                         tay
  1822  9244 a906                       lda #dos_errorcode_too_few_clusters
  1823  9246 8dfabc                     sta dos_error_code
  1824                          
  1825  9249 b903bb                     lda dos_disk_table+3,y        ;; BG this seems to creep-out-of-bounds from +16 to +19
  1826  924c 1902bb                     ora dos_disk_table+2,y
  1827  924f d003                       bne +
  1828  9251 4ce190                     jmp partitionerror
  1829                          +
  1830                                  ;; Now get cluster of root directory.
  1831                                  ;;
  1832  9254 ad04bc                     lda dos_disk_table_offset
  1833  9257 0910                       ora #fs_fat32_root_dir_cluster                ;; is $10
  1834  9259 a8                         tay
  1835                          
  1836  925a a203                       ldx #$03
  1837  925c bd2cde             ddop16: lda sd_sectorbuffer+$2C,x        ;; +$2c is rootDirFirstCluster[3..0]
  1838  925f 9900bb                     sta dos_disk_table,y
  1839  9262 ca                         dex
  1840                          ;; BG should there be a "dey" here somewhere?
  1841  9263 10f7                       bpl ddop16
  1842                          
  1843                                  ;; We have now set the following fields:
  1844                                  ;;
  1845                                  ;; fs_fat32_length_of_fat
  1846                                  ;; fs_fat32_system_sectors
  1847                                  ;; fs_fat32_reserved_clusters
  1848                                  ;; fs_fat32_root_dir_cluster
  1849                                  ;; 12,13,14,15 ?
  1850                                  ;; fs_fat32_sectors_per_cluster
  1851                                  ;; fs_fat32_fat_copies
  1852                                  ;; fs_fat32_cluster0_sector
  1853                          
  1854                                  ;; Our caller has set:
  1855                                  ;;
  1856                                  ;; fs_start_sector
  1857                                  ;; fs_sector_count
  1858                          
  1859                          ;; Checkpoint("dos_disk_table-7")
  1860                          ;; jsr dump_disk_table        ; debugging
  1861                          
  1862                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1863                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1864                          ;; dos_disk_table[10-17] = 02,00,AF,7C,00,00,08,02 -> new data appears in [10]
  1865                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1866                          
  1867                                  ;; So all that is left for us is to set fs_type_and_source to $0F
  1868                                  ;; to indicate FAT32 filesystem on the SD card ...
  1869                                  ;;
  1870  9265 ad04bc                     lda dos_disk_table_offset
  1871  9268 0908                       ora #fs_type_and_source                ;; is $08
  1872  926a a8                         tay
  1873  926b a90f                       lda #$0f
  1874  926d 9900bb                     sta dos_disk_table,y
  1875                          
  1876                          ;; jsr dump_disk_table        ; debugging
  1877                          
  1878                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1879                          ;; dos_disk_table[08-0F] = 0F,E6,03,00,00,38,02,02 -> new data appears in [08]
  1880                          ;; dos_disk_table[10-17] = 02,00,AF,7C,00,00,08,02
  1881                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1882                          
  1883                                  +Checkpoint "FAT32 partition data copied to dos_disk_table"
  1884                          
  1885                                  ;; ... and increment the number of disks we know
  1886  9270 ee01bc                     inc dos_disk_count
  1887                          
  1888                          dos_return_success:
  1889                          
  1890                                  ;; Return success
  1891                                  ;;
  1892  9273 a900                       lda #$00
  1893  9275 8dfabc                     sta dos_error_code
  1894                          
  1895  9278 38                         sec
  1896  9279 60                         rts
  1897                          
  1898                          ;;         ========================
  1899                          ;;         ========================
  1900                          
  1901                          dos_return_error:
  1902                          
  1903  927a 8dfabc                     sta dos_error_code
  1904                          
  1905                          dos_return_error_already_set:
  1906                          
  1907  927d 18                         clc
  1908  927e 60                         rts
  1909                          
  1910                          ;;         ========================
  1911                          
  1912                          dos_set_current_disk:
  1913                          
  1914                                  ;; Is disk number valid?
  1915                                  ;;
  1916                                  ;; INPUT: .X = disk
  1917                                  ;;
  1918  927f a980                       lda #dos_errorcode_no_such_disk
  1919  9281 8dfabc                     sta dos_error_code
  1920                          
  1921  9284 ec01bc                     cpx dos_disk_count
  1922  9287 9003                       bcc +
  1923  9289 4ce190                     jmp partitionerror        ;; BG shouldnt this be bmi?
  1924                          +
  1925  928c 8e03bc                     stx dos_disk_current_disk
  1926  928f 8a                         txa
  1927  9290 0a                         asl
  1928  9291 0a                         asl
  1929  9292 0a                         asl
  1930  9293 0a                         asl
  1931  9294 0a                         asl
  1932  9295 8d04bc                     sta dos_disk_table_offset
  1933                          
  1934                          !if DEBUG_HYPPO {
  1935                                  ldx dos_disk_current_disk        ;; convert .X to char-representation for display
  1936                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1937                                  sty dscd+0
  1938                                  stx dscd+1
  1939                          
  1940                                  ;; print debug message
  1941                                  ;;
  1942                                  jsr checkpoint
  1943                                  !8 0
  1944                                  !text "dos_set_current_disk="
  1945                          dscd:   !text "xx"
  1946                                  !8 0
  1947                          }
  1948                          
  1949  9298 38                         sec
  1950  9299 60                         rts
  1951                          
  1952                          ;;         ========================
  1953                          
  1954                          dos_cdroot:
  1955                          
  1956                                  ;; Change to root directory on specified disk
  1957                                  ;; (Changes current disk if required)
  1958                                  ;;
  1959                                  ;; INPUT: .X = disk
  1960                          
  1961  929a 207f92                     jsr dos_set_current_disk
  1962  929d 90de                       bcc dos_return_error_already_set
  1963                          
  1964                          dos_cdroot_current_disk_arleady_set:
  1965                          
  1966                                  ;; get offset of disk entry
  1967                                  ;;
  1968                          	
  1969  929f ae04bc                     ldx dos_disk_table_offset
  1970  92a2 bd10bb                     lda dos_disk_table + fs_fat32_root_dir_cluster +0,x
  1971  92a5 8d05bc                     sta dos_disk_cwd_cluster
  1972  92a8 bd11bb                     lda dos_disk_table + fs_fat32_root_dir_cluster +1,x
  1973  92ab 8d06bc                     sta dos_disk_cwd_cluster+1
  1974                          
  1975  92ae a900                       lda #$00
  1976  92b0 8d07bc                     sta dos_disk_cwd_cluster+2        ;; BG here we assume that the 2x MSB's are zero
  1977  92b3 8d08bc                     sta dos_disk_cwd_cluster+3
  1978                          
  1979                                  ;; Nothing else to do, as it doesn't actually affect any existing DOS activity,
  1980                                  ;; only future file/directory operations.
  1981                          
  1982  92b6 4c7392                     jmp dos_return_success
  1983                          
  1984                          ;;         ========================
  1985                          
  1986                          dos_cluster_to_sector:
  1987                          
  1988                                  ;; convert a cluster number in dos_current_cluster into a sector number
  1989                                  ;; pre-loaded into SD address registers
  1990                                  ;; It is assumed to be on the current disk
  1991                          
  1992  92b9 a203                       ldx #$03
  1993  92bb bdb3bc             dcts0:  lda dos_current_cluster,x
  1994  92be 9d81d6                     sta $d681,x
  1995  92c1 ca                         dex
  1996  92c2 10f7                       bpl dcts0
  1997                          
  1998                                  ;; subtract 2 from the cluster number (clusters 0 and 1 don't actually exist
  1999                                  ;; on FAT32).
  2000                                  ;;
  2001  92c4 a9ff                       lda #$ff
  2002  92c6 aa                         tax
  2003  92c7 a8                         tay
  2004  92c8 4b                         taz
  2005  92c9 a9fe                       lda #$fe
  2006  92cb 20359b                     jsr sdsector_add_uint32
  2007                          
  2008                                  ;; now shift it left according to fs_sectors_per_cluster
  2009                                  ;;
  2010  92ce ae04bc                     ldx dos_disk_table_offset
  2011  92d1 bd16bb                     lda dos_disk_table+fs_fat32_sectors_per_cluster,x
  2012  92d4 a8                         tay
  2013  92d5 29fe                       and #$fe
  2014  92d7 f014                       beq multipliedclusternumber
  2015                          
  2016  92d9 18                 dcts1:  clc
  2017  92da 2e81d6                     rol $D681
  2018  92dd 2e82d6                     rol $D682
  2019  92e0 2e83d6                     rol $D683
  2020  92e3 2e84d6                     rol $D684
  2021  92e6 98                         tya
  2022  92e7 4a                         lsr
  2023  92e8 a8                         tay
  2024  92e9 29fe                       and #$fe
  2025  92eb d0ec                       bne dcts1
  2026                          
  2027                          multipliedclusternumber:
  2028                          
  2029                                  ;; skip over filesystem reserved and FAT sectors
  2030                                  ;;
  2031  92ed a918                       lda #fs_fat32_cluster0_sector
  2032  92ef 20549b                     jsr sdsector_add_uint32_from_disktable
  2033                          
  2034                                  ;; add start sector of partition
  2035                                  ;;
  2036  92f2 a900                       lda #fs_start_sector
  2037  92f4 20549b                     jsr sdsector_add_uint32_from_disktable
  2038                          
  2039                                  ;; XXX - Check that result does not exceed fs_start_sector+fs_sector_count
  2040                                  ;; and run over into another partition
  2041                          
  2042                                  ;; return success
  2043  92f7 38                         sec
  2044  92f8 60                         rts
  2045                          
  2046                          ;;         ========================
  2047                          
  2048                          dos_requested_filename_to_uppercase:
  2049                          
  2050                                  ;; Convert filename to upper case for comparison
  2051                                  ;;
  2052  92f9 ae66bc                     ldx dos_requested_filename_len
  2053  92fc e03f                       cpx #$3f
  2054  92fe a981                       lda #dos_errorcode_name_too_long
  2055  9300 9003                       bcc drftu1
  2056  9302 4c7a92                     jmp dos_return_error
  2057                          drftu1:
  2058  9305 bd67bc                     lda dos_requested_filename,x
  2059  9308 20f89e                     jsr toupper
  2060  930b 9d67bc                     sta dos_requested_filename,x
  2061  930e ca                         dex
  2062  930f 10f4                       bpl drftu1
  2063  9311 38                         sec
  2064  9312 60                         rts
  2065                          
  2066                          ;;         ========================
  2067                          
  2068                          dos_get_free_descriptor:
  2069                          
  2070  9313 a200                       ldx #$00
  2071                          
  2072  9315 8a                 dgfd1:  txa
  2073  9316 0a                         asl
  2074  9317 0a                         asl
  2075  9318 0a                         asl
  2076  9319 0a                         asl
  2077  931a a8                         tay
  2078  931b b9b8bc                     lda dos_file_descriptors+dos_filedescriptor_offset_diskid,y
  2079  931e c9ff                       cmp #$FF
  2080  9320 f00a                       beq dgfd_found_free
  2081  9322 e8                         inx
  2082  9323 e004                       cpx #dos_filedescriptor_max
  2083  9325 d0ee                       bne dgfd1
  2084                          
  2085  9327 a984                       lda #dos_errorcode_too_many_open_files
  2086  9329 4c7a92                     jmp dos_return_error
  2087                          
  2088                          ;;         ========================
  2089                          
  2090                          dgfd_found_free:
  2091                          
  2092  932c 8ef8bc                     stx dos_current_file_descriptor
  2093  932f 8cf9bc                     sty dos_current_file_descriptor_offset
  2094                          
  2095                                  ;; Push the address dos_file_descriptors + dos_current_file_descriptor_offset
  2096                                  ;;
  2097  9332 18                         clc
  2098  9333 a9b8                       lda #<dos_file_descriptors
  2099  9335 6df9bc                     adc dos_current_file_descriptor_offset
  2100  9338 a8                         tay
  2101  9339 a9bc                       lda #>dos_file_descriptors
  2102  933b 6900                       adc #$00
  2103  933d 48                         pha
  2104  933e 5a                         phy
  2105                          
  2106                                  ;; Clear descriptor entry
  2107                                  ;;
  2108  933f a00f                       ldy #$0f
  2109  9341 a900                       lda #$00
  2110                          
  2111  9343 8201               dgfd2:  sta ($01,sp),y
  2112  9345 88                         dey
  2113  9346 d0fb                       bne dgfd2
  2114                          
  2115                                  ;; Pop the address
  2116  9348 68                         pla
  2117  9349 68                         pla
  2118                          
  2119                                  ;; Return file descriptor in X
  2120  934a 38                         sec
  2121  934b 60                         rts
  2122                          
  2123                          ;;         ========================
  2124                          
  2125                          dos_clearall:
  2126                          
  2127                                  ;; Free all file descriptors with extreme prejudice
  2128                                  ;; Clear dos_disk_table
  2129                          
  2130                                  ;; display debug message to uart
  2131                                  ;;
  2132                                  +Checkpoint "dos_clearall:"
  2133                          
  2134  934c a9ff                       lda #$ff
  2135  934e 8db8bc                     sta dos_file_descriptors
  2136  9351 8dc8bc                     sta dos_file_descriptors+$10
  2137  9354 8dd8bc                     sta dos_file_descriptors+$20
  2138  9357 8de8bc                     sta dos_file_descriptors+$30
  2139  935a a200                       ldx #$00
  2140  935c a900                       lda #$00
  2141  935e 9d00bb             dca1:   sta dos_disk_table,x
  2142  9361 e8                         inx
  2143  9362 d0fa                       bne dca1
  2144  9364 38                         sec
  2145  9365 60                         rts
  2146                          
  2147                          ;;         ========================
  2148                          
  2149                          dos_closefile:
  2150                          
  2151                                  ;; Close the current file/directory
  2152                                  ;; If the file is read-only, we can just free the file descriptor and return.
  2153                                  ;; XXX - If the file is open for write, we might have a buffer to flush.
  2154                                  ;; (Worry about this when we implement writing. Opening files for write will
  2155                                  ;; probably require the caller to nominate a 512 byte buffer in user-space
  2156                                  ;; memory so that the convenience write-byte routine can work.  The other case,
  2157                                  ;; writing a sector at a time, should just be synchronous, so that there is no
  2158                                  ;; buffering required.)
  2159                          
  2160  9366 aef9bc                     ldx dos_current_file_descriptor_offset
  2161  9369 bdb9bc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2162  936c c901                       cmp #dos_filemode_readwrite
  2163  936e d000                       bne dcf_simple
  2164                          
  2165                                  ;; This is where we would flush the write buffer, and update file length in
  2166                                  ;; directory, if required.  Note that to save space, we don't actually keep the
  2167                                  ;; location of the directory entry of the file in the file descriptor.  This
  2168                                  ;; complicates things somewhat, and we might need to change this.  However, the
  2169                                  ;; file descriptor table must be a power of two in length, and there isn't any
  2170                                  ;; space to double its' size.  Thus we will need a separate table that holds the
  2171                                  ;; directory sector and entry for any file being written to.  We might save a
  2172                                  ;; few bytes by allowing less than dos_filedescriptor_max files to be open for
  2173                                  ;; writing at any point in time.
  2174                          
  2175                          dcf_simple:
  2176                          
  2177  9370 aef9bc                     ldx dos_current_file_descriptor_offset
  2178  9373 a9ff                       lda #$ff ;; not allocated flag for file descriptor
  2179  9375 9db8bc                     sta dos_file_descriptors + dos_filedescriptor_offset_diskid,x
  2180  9378 38                         sec
  2181  9379 60                         rts
  2182                          
  2183                          ;;         ========================
  2184                          
  2185                          dos_chdir:
  2186                          	;; Works similarly to dos_openfile, i.e. you must first have the
  2187                          	;; directory in the dirent structure, found via dos_findfile
  2188                          
  2189                                  ;; Check if the file is a directory, if so, refuse to open it.
  2190                                  ;;
  2191  937a ad65bc                     lda dos_dirent_type_and_attribs
  2192  937d 2910                       and #fs_fat32_attribute_isdirectory
  2193  937f d005                       bne dcd_is_a_directory
  2194                          
  2195  9381 a987                       lda #dos_errorcode_not_a_directory
  2196  9383 4c7a92                     jmp dos_return_error
  2197                          	
  2198                          ;;         ========================
  2199                          
  2200                          dcd_is_a_directory:
  2201                          
  2202  9386 205196                     jsr dos_set_current_file_from_dirent
  2203  9389 904b                       bcc l3_dos_return_error_already_set
  2204                          
  2205                          	;; Close the file descriptor opened by dos_set_current_file_from_dirent
  2206  938b 206693             	jsr dos_closefile
  2207                          
  2208                          	;; Copy cluster of requesteed directory into disk CWD cluster
  2209  938e a203               	ldx #3
  2210  9390 bd5dbc             dcd1:	lda dos_dirent_cluster,x
  2211  9393 9d05bc             	sta dos_disk_cwd_cluster,x
  2212  9396 ca                 	dex
  2213  9397 10f7               	bpl dcd1
  2214                          
  2215                          	;; Check if cluster 0. If so, cd to root directory
  2216                          	;; (its a convention to put cluster 0 in references to the root directory
  2217                          	;; on some FAT implementations, apparently).
  2218                          	
  2219  9399 a203               	ldx #3
  2220  939b a900               	lda #0
  2221  939d 1d05bc             dcd2:	ora dos_disk_cwd_cluster,x
  2222  93a0 ca                 	dex
  2223  93a1 10fa               	bpl dcd2
  2224                          
  2225  93a3 c900               	cmp #0
  2226  93a5 d003               	bne @nonZeroCluster
  2227                          
  2228                          	;; Is cluster 0, so change to root directory
  2229  93a7 4c9f92             	jmp dos_cdroot_current_disk_arleady_set
  2230                          	
  2231                          @nonZeroCluster:
  2232                          	;; Return success
  2233  93aa 38                 	sec
  2234  93ab 60                 	rts
  2235                          
  2236                          ;;         ========================
  2237                          	
  2238                          	
  2239                          dos_openfile:
  2240                          
  2241                                  ;; Open the file that is in the dirent structure
  2242                                  ;; (to open a file by arbitrary name, you must first call dos_findfile)
  2243                          
  2244                                  ;; Check if the file is a directory, if so, refuse to open it.
  2245                                  ;;
  2246  93ac ad65bc                     lda dos_dirent_type_and_attribs
  2247  93af 2910                       and #fs_fat32_attribute_isdirectory
  2248  93b1 f005                       beq dof_not_a_directory
  2249                          
  2250  93b3 a986                       lda #dos_errorcode_is_a_directory
  2251  93b5 4c7a92                     jmp dos_return_error
  2252                          
  2253                          ;;         ========================
  2254                          
  2255                          dof_not_a_directory:
  2256                          
  2257  93b8 205196                     jsr dos_set_current_file_from_dirent
  2258  93bb 9019                       bcc l3_dos_return_error_already_set
  2259                          
  2260  93bd 4c9e96                     jmp dos_open_current_file
  2261                          
  2262                          ;;         ========================
  2263                          
  2264                          dos_findfile:
  2265                          
  2266                                  ;; Convenience wrapper around dos_findfirst to make sure that we don't
  2267                                  ;; leave any hanging file descriptors.
  2268                          
  2269  93c0 20cc93                     jsr dos_findfirst
  2270  93c3 08                         php
  2271  93c4 206693                     jsr dos_closefile
  2272  93c7 28                         plp
  2273  93c8 900c                       bcc l3_dos_return_error_already_set
  2274  93ca 38                         sec
  2275  93cb 60                         rts
  2276                          
  2277                          ;;         ========================
  2278                          
  2279                          dos_findfirst:
  2280                          
  2281                                  ;; Search for file in current directory
  2282                          
  2283                                  ;; Convert name to upper case for searching
  2284                                  ;;
  2285  93cc 20f992                     jsr dos_requested_filename_to_uppercase
  2286  93cf 9005                       bcc l3_dos_return_error_already_set
  2287                          
  2288  93d1 20f093                     jsr dos_opendir
  2289  93d4 b003                       bcs +
  2290                          l3_dos_return_error_already_set:
  2291  93d6 4c7d92                     jmp dos_return_error_already_set
  2292                          +
  2293                                  ;; Directory is now open, and we can now iterate through directory entries
  2294                                  ;;
  2295  93d9 4cdc93             	jmp dos_findnext
  2296                          
  2297                          
  2298                          ;;         ========================
  2299                          
  2300                          dos_findnext:
  2301                          
  2302                                  ;; Keep searching in directory for another match
  2303                          
  2304                          dff_try_next_entry:
  2305                          
  2306                                  ;; Get next directory entry
  2307                                  ;;
  2308  93dc 202694                     jsr dos_readdir
  2309  93df b008                       bcs dff_have_next_entry
  2310                          
  2311  93e1 206693                     jsr dos_closefile
  2312                          
  2313  93e4 a988                       lda #dos_errorcode_file_not_found
  2314  93e6 4c7a92                     jmp dos_return_error
  2315                          
  2316                          dff_have_next_entry:
  2317                          
  2318                                  ;; Compare dos_dirent_longfilename with dos_requested_filename
  2319                                  ;;
  2320  93e9 201296                     jsr dos_dirent_compare_name_to_requested
  2321                          
  2322                                  ;; no match? try next entry
  2323                                  ;;
  2324  93ec 90ee                       bcc dff_try_next_entry
  2325                          
  2326                                  ;; we have a match, so return success
  2327                                  ;; (we don't close the file handle for the directory search, because the
  2328                                  ;; caller may want to find multiple matches)
  2329                                  ;;
  2330  93ee 38                         sec
  2331  93ef 60                         rts
  2332                          
  2333                          ;;         ========================
  2334                          
  2335                          dos_opendir:
  2336                          
  2337                                  ;; Open the current directory as a file
  2338                                  ;;
  2339  93f0 201393                     jsr dos_get_free_descriptor
  2340  93f3 b003                       bcs +
  2341  93f5 4c7d92                     jmp dos_return_error_already_set
  2342                          +
  2343                                  ;; get offset in file descriptor table
  2344                                  ;;
  2345  93f8 8a                         txa
  2346  93f9 0a                         asl
  2347  93fa 0a                         asl
  2348  93fb 0a                         asl
  2349  93fc 0a                         asl
  2350  93fd a8                         tay
  2351                          
  2352                                  ;; set disk id
  2353                                  ;;
  2354  93fe ad03bc                     lda dos_disk_current_disk
  2355  9401 99b8bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,y
  2356                          
  2357                                  ;; load cluster of dir into file descriptor
  2358                                  ;;
  2359  9404 a200                       ldx #$00
  2360                          
  2361  9406 bd05bc             dff1:   lda dos_disk_cwd_cluster,x
  2362  9409 99babc                     sta dos_file_descriptors+dos_filedescriptor_offset_startcluster,y
  2363  940c 99bebc                     sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,y
  2364  940f c8                         iny
  2365  9410 e8                         inx
  2366  9411 e004                       cpx #$04
  2367  9413 d0f1                       bne dff1
  2368                          
  2369                                  ;; Mark file descriptor as being a directory
  2370                                  ;;
  2371  9415 aef9bc                     ldx dos_current_file_descriptor_offset
  2372  9418 a980                       lda #dos_filemode_directoryaccess
  2373  941a 9db9bc                     sta dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2374                          
  2375  941d 209e96                     jsr dos_open_current_file
  2376  9420 b003                       bcs +
  2377  9422 4c7d92                     jmp dos_return_error_already_set
  2378  9425 60                 +       rts
  2379                          
  2380                          ;;         ========================
  2381                          
  2382                          dos_readdir:
  2383                          
  2384                                  ;; Get the current file entry, and advance pointer
  2385                                  ;; This requires parsing the current directory entry onwards, accumulating
  2386                                  ;; long filename parts as required.  We only support filenames to 64 chars,
  2387                                  ;; so long names longer than that will get ignored.
  2388                                  ;; LFN entries have an attribute byte of $0F (normally indicates volume label)
  2389                                  ;; LFN entries use 16-bit unicode values. For now we will just keep the lower
  2390                                  ;; byte of these
  2391                          
  2392                                  ;; clear long file name data from last call
  2393                                  ;;
  2394  9426 a900                       lda #0
  2395  9428 8d4fbc                     sta dos_dirent_longfilename_length
  2396                          
  2397  942b 20ec96                     jsr dos_file_read_current_sector
  2398                          
  2399                          !if DEBUG_HYPPO {
  2400                          ;; debug info, unsure what byte is being displayed...
  2401                          ;;
  2402                                  +Checkpoint "-"
  2403                          
  2404                                  ldy dos_current_file_descriptor_offset
  2405                                  clc
  2406                                  lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  2407                          
  2408                                  tax                                ;; convert .X to char-representation for display
  2409                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2410                                  sty drdcp0+2
  2411                                  stx drdcp0+3
  2412                          
  2413                                  ldy dos_current_file_descriptor_offset
  2414                                  clc
  2415                                  lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  2416                          
  2417                                  tax                                ;; convert .X to char-representation for display
  2418                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2419                                  sty drdcp0+0
  2420                                  stx drdcp0+1
  2421                          
  2422                                  jsr checkpoint
  2423                                  !8 0
  2424                                  !text "dos_readdir["
  2425                          drdcp0: !text "xxyy]"
  2426                                  !8 0
  2427                          
  2428                                  jsr dumpsectoraddress        ;; debug
  2429                                  jsr dumpfddata                ;; debug
  2430                          
  2431                          ;; end of debug
  2432                          }
  2433                          
  2434  942e aef9bc                     ldx dos_current_file_descriptor_offset
  2435  9431 bdb9bc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2436  9434 c980                       cmp #dos_filemode_directoryaccess
  2437  9436 f00e                       beq drd_isdir
  2438  9438 c981                       cmp #dos_filemode_end_of_directory
  2439  943a d005                       bne drd_notadir
  2440                          
  2441  943c a9ff                       lda #dos_errorcode_eof
  2442  943e 4c7a92                     jmp dos_return_error
  2443                          
  2444                          ;;         ========================
  2445                          
  2446                          drd_notadir:
  2447                                  ;; refuse to read files as directories
  2448                                  ;;
  2449  9441 a987                       lda #dos_errorcode_not_a_directory
  2450  9443 4c7a92                     jmp dos_return_error
  2451                          
  2452                          ;;         ========================
  2453                          
  2454                          drd_isdir:
  2455                          
  2456                                  ;; Clear dirent structure
  2457                                  ;; WARNING - Uses carnal knowledge to know that dirent structure is
  2458                                  ;; 64+1+11+4+4+1 = 85 contiguous bytes
  2459                                  ;;
  2460  9446 a256                       ldx #dos_dirent_structure_length-1
  2461  9448 a900                       lda #$00
  2462                          
  2463  944a 9d0fbc             drce1:  sta dos_dirent_longfilename,x
  2464  944d ca                         dex
  2465  944e 10fa                       bpl drce1
  2466                          
  2467                                  ;; Read current sector
  2468                                  ;;
  2469  9450 20ec96                     jsr dos_file_read_current_sector
  2470  9453 b003                       bcs +
  2471  9455 4c7d92                     jmp dos_return_error_already_set
  2472  9458 20cf9f             +       jsr sd_map_sectorbuffer
  2473                          
  2474                          drce_next_piece:
  2475                          
  2476                                  ;; Offset in sector correctly indicates where we need to read.
  2477                                  ;; Sectors are 512 bytes, so we can't just do a register index.
  2478                                  ;; Instead we will setup a 16-bit pointer.
  2479                                  ;;
  2480  945b adf9bc                     lda dos_current_file_descriptor_offset
  2481  945e 090b                       ora #dos_filedescriptor_offset_offsetinsector
  2482  9460 aa                         tax
  2483  9461 bdb8bc                     lda dos_file_descriptors,x
  2484  9464 8500                       sta <dos_scratch_vector
  2485  9466 bdb9bc                     lda dos_file_descriptors+1,x
  2486  9469 18                         clc
  2487  946a 69de                       adc #$DE   ;; high byte of SD card sector buffer
  2488  946c 8501                       sta <(dos_scratch_vector+1)
  2489                          
  2490                                  ;; (dos_scratch_vector) now has the address of the directory entry
  2491                          
  2492                          !if DEBUG_HYPPO {
  2493                                  phx        ;; as the code below clobbers X
  2494                          
  2495                                  ;; print out filename and attrib
  2496                                  ;;
  2497                                  ldy #fs_fat32_dirent_offset_shortname
  2498                                  ldx #0
  2499                          eight31:
  2500                                  lda (<dos_scratch_vector),y
  2501                                  jsr makeprintable
  2502                                  sta eight3,x
  2503                                  iny
  2504                                  inx
  2505                                  cpx #11                ;; 11 chars in the filename (8+3)
  2506                                  bne eight31
  2507                                  ;;
  2508                                  ;; attrib
  2509                                  ;;
  2510                                  ldy #fs_fat32_dirent_offset_attributes        ;; = 0x0B
  2511                                  lda (<dos_scratch_vector),y
  2512                                  tax                                ;; convert .X to char-representation for display
  2513                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2514                                  sty eight3attrib+0
  2515                                  stx eight3attrib+1
  2516                                  ;;
  2517                                  ;; char1
  2518                                  ;;
  2519                                  ldy #$00
  2520                                  lda (<dos_scratch_vector),y
  2521                                  tax                                ;; convert .X to char-representation for display
  2522                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2523                                  sty eight3char1+0
  2524                                  stx eight3char1+1
  2525                          
  2526                                  ;;
  2527                          
  2528                                  jsr checkpoint
  2529                                  !8 0
  2530                                  !text " (8.3)+(ATTRIB)+(NAME[0]) = "
  2531                          eight3: !text "FILENAMEEXT "
  2532                          eight3attrib:
  2533                                  !text "xx "
  2534                          eight3char1:
  2535                                  !text "xx"
  2536                                  !8 0
  2537                          
  2538                                  plx        ;; as the code above clobbers X
  2539                          }
  2540                          
  2541                          ;;         ========================
  2542                          
  2543                                  ;; first, check if the entry begins with $E5 marking a deleted file.
  2544                          	;; Entry entries we just ignore, as they are totally valid.
  2545                          
  2546  946e a000                       ldy #fs_fat32_dirent_offset_shortname        ;; Y=0 (first char of entry)
  2547  9470 b100                       lda (<dos_scratch_vector),y
  2548  9472 c9e5                       cmp #$e5
  2549  9474 d003                       bne +
  2550  9476 4c0296                     jmp drd_deleted_or_invalid_entry
  2551                          +
  2552  9479 c900               	cmp #$00
  2553  947b d003                       bne +
  2554                          	;; Empty entry, so skip over it
  2555  947d 4c0296             	jmp drd_deleted_or_invalid_entry
  2556                          +
  2557                                  ;; now check the attrib
  2558                          
  2559  9480 a00b                       ldy #fs_fat32_dirent_offset_attributes        ;; = 0x0B
  2560  9482 b100                       lda (<dos_scratch_vector),y
  2561                          
  2562                                  ;; check the kind of data we are looking at:
  2563                                  ;; bit 5 = 1         -> is a Archive
  2564                                  ;; bit 4 = 1         -> is a Directory
  2565                                  ;; bit 3 = 1         -> is a Volume ID
  2566                                  ;; bit 2 = 1         -> is a System
  2567                                  ;; bit 1 = 1         -> is a Hidden
  2568                                  ;; bit 0 = 1         -> is a Readonly
  2569                          
  2570  9484 a8                         tay        ;; for safe keeping
  2571                          
  2572                                  ;; if bits xx3210 = xx1111 -> is a long filename
  2573                                  ;; we process these differently to the standard (shortname) entries
  2574                                  ;;
  2575  9485 290f                       and #$0f
  2576  9487 c90f                       cmp #$0f                ;; %00001111 LFN entry special attribute value (xxxx1111)
  2577  9489 d003                       bne drce_cont0
  2578  948b 4ca394                     jmp drce_longname        ;; MATCH -> must be LFN
  2579                          
  2580                          drce_cont0:
  2581  948e 98                         tya        ;; from safe keeping
  2582                          
  2583                                  ;; if bit-3 = 1 -> Vol ID
  2584                                  ;; we process the Vol ID different (for now)
  2585                                  ;;
  2586  948f 2908                       and #$08
  2587  9491 c908                       cmp #$08                ;; %00001000 Vol-ID
  2588  9493 d003                       bne drce_cont2
  2589  9495 4c2e95             	jmp drce_cont_next_part	; Ignore it
  2590                          
  2591                          drce_cont2:
  2592  9498 98                         tya        ;; from safe keeping
  2593                          
  2594                                  ;; check for bits 2 or 1 asserted
  2595                                  ;; we should ignore these hidden/system files (for now)
  2596                                  ;;
  2597  9499 2906                       and #$06                ;; %00000110
  2598  949b f003                       beq drce_cont3        ;; branch if equal to zero (ie not Hidden OR System)
  2599                          	;; Ignore hidden/system files for now
  2600                          	;; XXX We should have a flag to enable/disable this behaviour
  2601  949d 4c2e95             	jmp drce_cont_next_part
  2602                          
  2603                          drce_cont3:
  2604                          
  2605                                  ;; was not hidden/system, or Vol-ID, or LFN,
  2606                                  ;; so we process this entry regardless of if read-only (bit0) or not
  2607                          
  2608  94a0 4c3995                     jmp drce_normalrecord
  2609                          
  2610                          ;;         ========================
  2611                          
  2612                          drce_longname:
  2613                          
  2614                          disable_lfn_byte:	
  2615  94a3 4c2e95             	jmp drce_cont_next_part
  2616                          
  2617  94a6 ee20d0             	inc $d020
  2618  94a9 4ca394             	jmp drce_longname
  2619                          	
  2620                                  ;; make sure long entry type is "filename" (=$00)
  2621                                  ;;
  2622  94ac a00c                       ldy #fs_fat32_dirent_offset_lfn_type
  2623  94ae b100                       lda (<dos_scratch_vector),y
  2624  94b0 f003                       beq +
  2625  94b2 4c3995                     jmp drce_normalrecord
  2626                          +
  2627                                  ;; verify checksum of long name
  2628                                  ;; XXX - Actually, we need to keep the checksum, and then compare it with the
  2629                                  ;; checksum we compute on the short name to check if this is the right long
  2630                                  ;; name.  We are just going to ignore this for now, and assume (and hope) that
  2631                                  ;; the LFN structure is always healthy.  I am sure this will come back to bite
  2632                                  ;; us at some point, and it can be fixed at that point in time.
  2633                          
  2634                                  ;; It's a long filename piece
  2635                                  ;; byte 0 gives the position in the LFN of this piece.
  2636                                  ;; Each piece has 13 16-bit unicode values.
  2637                                  ;; For now, we will only use the lower byte.  later we should gather the
  2638                                  ;; long filenames as UTF-16, and then convert them to UTF-8.
  2639                          
  2640  94b5 a000                       ldy #fs_fat32_dirent_offset_lfn_part_number
  2641  94b7 b100                       lda (<dos_scratch_vector),y
  2642  94b9 293f                       and #$3f ;; mask out end of LFN indicator
  2643  94bb 3a                         dec ;; subtract one, since pieces are numbered from 1 upwards
  2644                          
  2645                                  ;; each piece has 13 chars, and we only allow 64 characters total, so any
  2646                                  ;; piece number >4 can be ignored
  2647                                  ;;
  2648  94bc c905                       cmp #5
  2649  94be b061                       bcs drce_ignore_lfn_piece
  2650  94c0 aa                         tax
  2651  94c1 bd0d96                     lda lfn_piece_offsets,x
  2652  94c4 aa                         tax
  2653                          
  2654                                  +Checkpoint "found LFN piece <start>"
  2655                          
  2656                                  ;; Copy first part of LFN
  2657                                  ;;
  2658  94c5 a001                       ldy #fs_fat32_dirent_offset_lfn_part1_start
  2659  94c7 a305                       ldz #fs_fat32_dirent_offset_lfn_part1_chars
  2660  94c9 b100               drce2:  lda (<dos_scratch_vector),y
  2661  94cb f040                       beq drce_eot_in_filename
  2662  94cd 9d0fbc                     sta dos_dirent_longfilename,x
  2663  94d0 8e4fbc                     stx dos_dirent_longfilename_length
  2664  94d3 e8                         inx
  2665                                  ;; protect against over-long LFNs
  2666  94d4 e040                       cpx #$40
  2667  94d6 f035                       beq drce_eot_in_filename
  2668  94d8 c8                         iny
  2669  94d9 c8                         iny
  2670  94da 3b                         dez
  2671  94db d0ec                       bne drce2
  2672                          
  2673                                  ;; Copy second part of LFN
  2674                                  ;;
  2675  94dd a00e                       ldy #fs_fat32_dirent_offset_lfn_part2_start
  2676  94df a306                       ldz #fs_fat32_dirent_offset_lfn_part2_chars
  2677  94e1 b100               drce3:  lda (<dos_scratch_vector),y
  2678  94e3 f028                       beq drce_eot_in_filename
  2679  94e5 9d0fbc                     sta dos_dirent_longfilename,x
  2680  94e8 8e4fbc                     stx dos_dirent_longfilename_length
  2681  94eb e8                         inx
  2682                                  ;; protect against over-long LFNs
  2683  94ec e040                       cpx #$40
  2684  94ee f01d                       beq drce_eot_in_filename
  2685  94f0 c8                         iny
  2686  94f1 c8                         iny
  2687  94f2 3b                         dez
  2688  94f3 d0ec                       bne drce3
  2689                          
  2690                                  ;; Copy third part of LFN
  2691                                  ;;
  2692  94f5 a01c                       ldy #fs_fat32_dirent_offset_lfn_part3_start
  2693  94f7 a302                       ldz #fs_fat32_dirent_offset_lfn_part3_chars
  2694  94f9 b100               drce4:  lda (<dos_scratch_vector),y
  2695  94fb f010                       beq drce_eot_in_filename
  2696  94fd 9d0fbc                     sta dos_dirent_longfilename,x
  2697  9500 8e4fbc                     stx dos_dirent_longfilename_length
  2698  9503 e8                         inx
  2699                                  ;; protect against over-long LFNs
  2700  9504 e040                       cpx #$40
  2701  9506 f005                       beq drce_eot_in_filename
  2702  9508 c8                         iny
  2703  9509 c8                         iny
  2704  950a 3b                         dez
  2705  950b d0ec                       bne drce4
  2706                          
  2707                          drce_eot_in_filename:
  2708                          
  2709                                  +Checkpoint "BGOK drce_eot_in_filename"
  2710                          
  2711                                  ;; got all characters from this LFN piece
  2712                                  ;;
  2713  950d ec4fbc                     cpx dos_dirent_longfilename_length
  2714  9510 900f                       bcc drce_piece_didnt_grow_name_length
  2715  9512 8e4fbc                     stx dos_dirent_longfilename_length
  2716  9515 e03f                       cpx #$3f
  2717  9517 b008                       bcs drce_eot_in_filename2
  2718                          
  2719                                  ;; null terminate if there is space, for convenience
  2720                                  ;;
  2721  9519 a900                       lda #$00
  2722  951b 9d0fbc                     sta dos_dirent_longfilename,x
  2723  951e 8e4fbc                     stx dos_dirent_longfilename_length
  2724                          
  2725                          drce_eot_in_filename2:
  2726                          
  2727                          drce_piece_didnt_grow_name_length:
  2728                          
  2729                          drce_ignore_lfn_piece:
  2730                          
  2731                                  +Checkpoint "BGOK drce_ignore_lfn_piece"
  2732                          
  2733                                  ;; We have finished processing this piece of long name.
  2734                                  ;; bump directory entry, read next sector if required, and re-enter loop
  2735                                  ;; above to keep accumulating
  2736                          
  2737                          drce_cont_next:
  2738                          
  2739                                  +Checkpoint "BGOK drce_cont_next"
  2740                          
  2741  9521 202d96                     jsr dos_readdir_advance_to_next_entry
  2742  9524 9003                       bcc drce_no_more_pieces
  2743                          
  2744  9526 4c5b94                     jmp drce_next_piece
  2745                          
  2746                          drd_end_of_directory:
  2747                                  ;; If we have pieces, then emit the final filename,
  2748                                  ;; else return EOF on the directory by falling through to the following
  2749                                  ;; Can we ever be in such a position?  Let's assume for the time being that
  2750                                  ;; we can't.  If we start losing the last name in a directory list, then we
  2751                                  ;; can worry about fixing it then.
  2752                          
  2753                                  ;; FALL THROUGH to drce_no_more_pieces
  2754                          
  2755                          ;;         ========================
  2756                          
  2757                          drce_no_more_pieces:
  2758                                  +Checkpoint "FOUND END_OF_DIRECTORY"
  2759                          
  2760  9529 a9ff                       lda #dos_errorcode_eof
  2761  952b 4c7a92                     jmp dos_return_error
  2762                          
  2763                          ;;         ========================
  2764                          
  2765                          
  2766                          drce_cont_next_part:
  2767                          
  2768  952e 202d96                     jsr dos_readdir_advance_to_next_entry
  2769  9531 9003                       bcc +
  2770  9533 4c2694                     jmp dos_readdir
  2771  9536 4c7d92             +       jmp dos_return_error_already_set
  2772                          
  2773                          ;;         ========================
  2774                          
  2775                          drce_normalrecord:
  2776                                  ;; PGS: We have found a short name.
  2777                          
  2778                          
  2779                                  +Checkpoint "processing SHORT-name"
  2780                          
  2781                                  ;; store short name
  2782                                  ;;
  2783  9539 a000                       ldy #fs_fat32_dirent_offset_shortname
  2784                          
  2785                          ;; this test has already been done
  2786                          ;;
  2787                          ;;         ; Ignore empty and deleted entries (first byte $00 or $E5 respectively)
  2788                          ;;         ;
  2789                          ;;         lda (<dos_scratch_vector),y
  2790                          ;;         beq drd_end_of_directory
  2791                          ;;         cmp #$e5
  2792                          ;;         beq drd_deleted_or_invalid_entry
  2793                          
  2794  953b a200                       ldx #$00
  2795  953d b100               drce5:  lda (<dos_scratch_vector),y
  2796  953f 9d50bc                     sta dos_dirent_shortfilename,x
  2797  9542 e8                         inx
  2798  9543 c8                         iny
  2799  9544 e00b                       cpx #11
  2800  9546 d0f5                       bne drce5
  2801                          
  2802                                  ;; If we have no long name, copy it also to long name, inserting "." between
  2803                                  ;; name and extension as required.
  2804                                  ;;
  2805  9548 ad4fbc                     lda dos_dirent_longfilename_length
  2806  954b d05b                       bne drce_already_have_long_name
  2807                          
  2808                                  ;; copy name part
  2809                                  ;;
  2810  954d a000                       ldy #fs_fat32_dirent_offset_shortname
  2811  954f a200                       ldx #$00
  2812  9551 b100               drce7:  lda (<dos_scratch_vector),y
  2813  9553 9d0fbc                     sta dos_dirent_longfilename,x
  2814  9556 8e4fbc                     stx dos_dirent_longfilename_length
  2815  9559 e8                         inx
  2816  955a c8                         iny
  2817  955b c920                       cmp #$20            ;; space indicates end of short name before extension
  2818  955d f005                       beq drce_insert_dot
  2819  955f e008                       cpx #8
  2820  9561 d0ee                       bne drce7
  2821  9563 e8                         inx
  2822                          
  2823                          drce_insert_dot:
  2824  9564 ca                         dex
  2825  9565 a92e                       lda #'.'
  2826  9567 9d0fbc                     sta dos_dirent_longfilename,x
  2827  956a 8e4fbc                     stx dos_dirent_longfilename_length
  2828  956d e8                         inx
  2829                          
  2830                                  ;; copy extension part
  2831                                  ;;
  2832  956e a008                       ldy #fs_fat32_dirent_offset_shortname+8
  2833  9570 a300                       ldz #0
  2834  9572 b100               drce6:  lda (<dos_scratch_vector),y
  2835  9574 9d0fbc                     sta dos_dirent_longfilename,x
  2836  9577 8e4fbc                     stx dos_dirent_longfilename_length
  2837  957a e8                         inx
  2838  957b c8                         iny
  2839  957c 1b                         inz
  2840  957d c203                       cpz #3  ;; short name extensions are <=3 chars
  2841  957f f008                       beq drce_copied_extension
  2842                          
  2843                                  ;; also terminate extensions early if they are <3 chars
  2844                                  ;;
  2845  9581 c920                       cmp #$20
  2846  9583 f004                       beq drce_copied_extension
  2847  9585 e00c                       cpx #8+1+3
  2848  9587 d0e9                       bne drce6
  2849                          
  2850                          drce_copied_extension:
  2851                          	
  2852                          	;; Trim spaces from the end of the filename
  2853  9589 e000               	cpx #0
  2854  958b f013               	beq @filename0bytes
  2855  958d a920               	lda #$20
  2856  958f dd0ebc             	cmp dos_dirent_longfilename-1,x
  2857  9592 d004               	bne @nomorespaces
  2858  9594 ca                 	dex
  2859  9595 4c8995             	jmp drce_copied_extension
  2860                          	
  2861                          @nomorespaces:
  2862                          
  2863                          	;; And trim trailing . from file name in case extension
  2864                          	;; was all spaces. But don't trim it if the filename starts
  2865                          	;; with ., so that we don't mess up . and .. directories
  2866  9598 bd0ebc             	lda dos_dirent_longfilename-1,x
  2867                          	;; Is last char a . ?
  2868  959b c92e               	cmp #$2e
  2869  959d d001               	bne @notrailingdot
  2870                          
  2871                          @hastrailingdot:
  2872                          	
  2873                          	;; Cut . from end of filename
  2874  959f ca                 	dex
  2875                          
  2876                          @notrailingdot:
  2877                          	
  2878                          @filename0bytes:
  2879                          
  2880                          	;; null terminate short name for convenience in our debugging
  2881                                  ;;
  2882  95a0 a900                       lda #$00
  2883  95a2 9d0fbc                     sta dos_dirent_longfilename,x
  2884                          
  2885                                  ;; record length of short name
  2886  95a5 8e4fbc                     stx dos_dirent_longfilename_length
  2887                          
  2888                                  ;; fall through
  2889                          
  2890                          drce_already_have_long_name:
  2891                          
  2892                                  ;; now copy attribute field and other useful data
  2893                          
  2894                                  ;; starting cluster
  2895                                  ;;
  2896  95a8 a01a                       ldy #fs_fat32_dirent_offset_clusters_low
  2897  95aa b100                       lda (<dos_scratch_vector),y
  2898  95ac 8d5dbc                     sta dos_dirent_cluster
  2899  95af c8                         iny
  2900  95b0 b100                       lda (<dos_scratch_vector),y
  2901  95b2 8d5ebc                     sta dos_dirent_cluster+1
  2902                          
  2903  95b5 a014                       ldy #fs_fat32_dirent_offset_clusters_high
  2904  95b7 b100                       lda (<dos_scratch_vector),y
  2905  95b9 8d5fbc                     sta dos_dirent_cluster+2
  2906  95bc c8                         iny
  2907  95bd b100                       lda (<dos_scratch_vector),y
  2908  95bf 8d60bc                     sta dos_dirent_cluster+3
  2909                          
  2910                          
  2911                                  ;; file length in bytes
  2912                                  ;;
  2913  95c2 a01c                       ldy #fs_fat32_dirent_offset_file_length
  2914  95c4 a200                       ldx #0
  2915                          drce_fl:
  2916  95c6 b100                       lda (<dos_scratch_vector),y
  2917  95c8 9d61bc                     sta dos_dirent_length,x
  2918  95cb c8                         iny
  2919  95cc e8                         inx
  2920  95cd e004                       cpx #4
  2921  95cf d0f5                       bne drce_fl
  2922                          
  2923                                  ;; attributes
  2924                                  ;;
  2925  95d1 a00b                       ldy #fs_fat32_dirent_offset_attributes
  2926  95d3 b100                       lda (<dos_scratch_vector),y
  2927  95d5 8d65bc                     sta dos_dirent_type_and_attribs
  2928                          
  2929                                  +Checkpoint "drce_fl populated fields"
  2930                          
  2931  95d8 202d96                     jsr dos_readdir_advance_to_next_entry
  2932  95db b010                       bcs drce_not_eof
  2933                          
  2934                          drce_is_eof:
  2935                          
  2936                                  +Checkpoint "DEBUG drce_is_eof <!>"
  2937                          
  2938                                  ;; We need to pass the error through here to indicate EOF in directory,
  2939                                  ;; but in a way that can be defered to the next call to dos_readdir, because
  2940                                  ;; we have a valid entry right now.  We do this with a special file mode which
  2941                                  ;; is EOF of directory (dos_filemode_end_of_directory)
  2942                                  ;;
  2943  95dd aef9bc                     ldx dos_current_file_descriptor_offset
  2944  95e0 a981                       lda #dos_filemode_end_of_directory
  2945  95e2 9db9bc                     sta dos_file_descriptors + dos_filedescriptor_offset_mode ,x
  2946                          
  2947  95e5 aef9bc                     ldx dos_current_file_descriptor_offset
  2948  95e8 bdb9bc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2949                          
  2950  95eb 38                         sec
  2951  95ec 60                         rts
  2952                          
  2953                          drce_not_eof:
  2954                          
  2955                                  +Checkpoint "drce_not_eof CHECK<1/3>"
  2956                          
  2957                                  ;; Ignore zero-length filenames (corresponding to empty directory entries)
  2958                                  ;;
  2959  95ed ad4fbc                     lda dos_dirent_longfilename_length
  2960  95f0 c900                       cmp #0
  2961  95f2 f009                       beq l_dos_readdir
  2962                          
  2963                                  +Checkpoint "drce_not_eof CHECK<2/3>"
  2964                          
  2965  95f4 ad50bc                     lda dos_dirent_shortfilename
  2966  95f7 f004                       beq l_dos_readdir
  2967  95f9 c920                       cmp #$20
  2968  95fb d003                       bne +
  2969                          l_dos_readdir:
  2970  95fd 4c2694                     jmp dos_readdir
  2971                          +
  2972                                  +Checkpoint "drce_not_eof CHECK<3/3>"
  2973                          
  2974                          !if DEBUG_HYPPO {
  2975                                  ldx dos_dirent_longfilename_length
  2976                                  jsr lfndebug
  2977                          }
  2978                          
  2979  9600 38                         sec
  2980  9601 60                         rts
  2981                          
  2982                          ;;         ========================
  2983                          
  2984                          !if DEBUG_HYPPO {
  2985                          lfndebug:
  2986                                  ;; requires .X to be set
  2987                                  ;;
  2988                                                                  ;; convert .X to char-representation for display
  2989                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2990                                  sty fnmsg1-5
  2991                                  stx fnmsg1-4
  2992                          
  2993                                  ;; Show what we have in the filename so far
  2994                                  ;;
  2995                                  phx        ;; safekeep
  2996                          
  2997                                  ldx #29
  2998                          drce23: lda dos_dirent_longfilename,x
  2999                                  jsr makeprintable
  3000                                  sta fnmsg1,x
  3001                                  dex
  3002                                  bpl drce23
  3003                          
  3004                                  plx        ;; unsafekeep
  3005                          
  3006                                  jsr checkpoint
  3007                                  !8 0
  3008                                  !text "LFN(xx): " ;; the "xx" can be replaced with the name_length
  3009                          fnmsg1: !text ".............................." ;; BG: why only 30 chars?
  3010                                  !8 0
  3011                          
  3012                                  rts
  3013                          }
  3014                          
  3015                          ;;         ========================
  3016                          
  3017                          drd_deleted_or_invalid_entry:
  3018                          
  3019                          !if DEBUG_HYPPO {
  3020                                  tax
  3021                                                                  ;; convert .X to char-representation for display
  3022                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  3023                                  sty ddie+0
  3024                                  stx ddie+1
  3025                          
  3026                                  jsr checkpoint
  3027                                  !8 0
  3028                          ddie:   !text "xx drd_deleted_or_invalid_entry"
  3029                                  !8 0
  3030                          }
  3031                          	
  3032  9602 202d96                     jsr dos_readdir_advance_to_next_entry
  3033  9605 9003                       bcc +
  3034  9607 4c2694                     jmp dos_readdir
  3035                          +
  3036  960a 4c7d92                     jmp dos_return_error_already_set
  3037                          
  3038                          ;;         ========================
  3039                          
  3040                          lfn_piece_offsets:
  3041  960d 000d1a2734                 !8 13*0,13*1,13*2,13*3,13*4
  3042                          
  3043                          ;;         ========================
  3044                          
  3045                          dos_dirent_compare_name_to_requested:
  3046                          
  3047                                  ;; print debug message showing what we are comparing
  3048                          
  3049                                  ;; print filename for debug
  3050                          
  3051                                  ;; Do the cheap check of comparing the lengths first
  3052                                  ;;
  3053  9612 ad4fbc                     lda dos_dirent_longfilename_length
  3054  9615 cd66bc                     cmp dos_requested_filename_len
  3055  9618 d011                       bne dff3
  3056                          
  3057                                  ;; lengths match, so compare bytes
  3058                                  ;; XXX - Needs to support * and ?
  3059                                  ;; see http:;;6502.org/source/strings/patmatch.htm for a routine to take
  3060                                  ;; inspiration from.
  3061                                  ;;
  3062  961a ae4fbc                     ldx dos_dirent_longfilename_length
  3063  961d ca                         dex
  3064  961e bd0fbc             dff4:   lda dos_dirent_longfilename,x
  3065  9621 dd67bc                     cmp dos_requested_filename,x
  3066  9624 d005                       bne dff3
  3067  9626 ca                         dex
  3068  9627 10f5                       bpl dff4
  3069                          
  3070                                  ;; File names match, so return success
  3071                          
  3072                                  +Checkpoint "Found the file..."
  3073                          
  3074  9629 38                         sec
  3075  962a 60                         rts
  3076                          
  3077                          dff3:
  3078                                  ;; file names don't match, so return failure
  3079  962b 18                         clc
  3080  962c 60                         rts
  3081                          
  3082                          ;;         ========================
  3083                          
  3084                          dos_readdir_advance_to_next_entry:
  3085                          
  3086  962d acf9bc                     ldy dos_current_file_descriptor_offset
  3087                          
  3088  9630 18                         clc
  3089  9631 b9c3bc                     lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  3090  9634 6920                       adc #$20 ;; length of FAT32/VFAT directory entry
  3091  9636 99c3bc                     sta dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  3092  9639 d00b                       bne dratne_done
  3093                          
  3094                                  ;; Increment upper byte
  3095                                  ;;
  3096  963b b9c4bc                     lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  3097  963e 1a                         inc
  3098  963f c901                       cmp #$01
  3099  9641 d005                       bne drce_end_of_sector
  3100  9643 99c4bc                     sta dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  3101                          
  3102                          dratne_done:
  3103  9646 38                         sec
  3104  9647 60                         rts
  3105                          
  3106                          ;;         ========================
  3107                          
  3108                          drce_end_of_sector:
  3109                          
  3110                                  ;; Reset pointer back to start of sector
  3111                                  ;;
  3112  9648 a900                       lda #$00
  3113  964a 99c4bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,y
  3114                          
  3115  964d 200997                     jsr dos_file_advance_to_next_sector
  3116  9650 60                         rts
  3117                          
  3118                          ;;         ========================
  3119                          
  3120                          dos_set_current_file_from_dirent:
  3121                          
  3122                                  ;; copy start cluster from dirent to start and current cluster
  3123                                  ;;
  3124  9651 201393                     jsr dos_get_free_descriptor
  3125  9654 20c596                     jsr dos_get_file_descriptor_offset
  3126  9657 b003                       bcs +
  3127  9659 4c7d92                     jmp dos_return_error_already_set
  3128                          +
  3129                                  ;; set disk id
  3130                                  ;;
  3131  965c ad03bc                     lda dos_disk_current_disk
  3132  965f 9db8bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x
  3133                          
  3134                                  ;; set current cluster to start cluster
  3135                                  ;;
  3136  9662 a000                       ldy #0
  3137                          dscffd1:
  3138  9664 b95dbc                     lda dos_dirent_cluster,y
  3139  9667 9dbabc                     sta dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
  3140  966a 9dbebc                     sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  3141  966d e8                         inx
  3142  966e c8                         iny
  3143  966f c004                       cpy #4
  3144  9671 d0f1                       bne dscffd1
  3145                          
  3146  9673 20c596                     jsr dos_get_file_descriptor_offset
  3147  9676 b003                       bcs +
  3148  9678 4c7d92                     jmp dos_return_error_already_set
  3149                          +
  3150                          
  3151                                  ;; set disk id
  3152                                  ;;
  3153  967b ad03bc                     lda dos_disk_current_disk
  3154  967e 9db8bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x
  3155                          
  3156                                  ;; set mode
  3157                                  ;;
  3158  9681 a900                       lda #dos_filemode_readonly
  3159  9683 9db9bc                     sta dos_file_descriptors+dos_filedescriptor_offset_mode,x
  3160                          
  3161                                  ;; set sector in cluster (set to 0)
  3162                                  ;;
  3163  9686 a900                       lda #$00
  3164  9688 9dc2bc                     sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
  3165                          
  3166                                  ;; set offset in sector (set to 0)
  3167                                  ;;
  3168  968b 9dc3bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+0,x
  3169  968e 9dc4bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,x
  3170                          
  3171                                  ;; Get length of file, so that we can
  3172                                  ;; limit load to reported length of file, instead assuming cluster
  3173                                  ;; chain is correct length, and file ends on a cluster boundary
  3174  9691 a203                       ldx #$03
  3175  9693 bd61bc             -       lda dos_dirent_length,x
  3176  9696 9dabbc                     sta dos_bytes_remaining,x
  3177  9699 ca                         dex
  3178  969a 10f7                       bpl -
  3179                          	
  3180  969c 38                         sec
  3181  969d 60                         rts
  3182                          
  3183                          ;;         ========================
  3184                          
  3185                          dos_open_current_file:
  3186                          
  3187                                  ;; copy start cluster to current cluster, and zero position in file
  3188                                  ;;
  3189  969e 20c596                     jsr dos_get_file_descriptor_offset
  3190  96a1 b003                       bcs +
  3191  96a3 4c7d92                     jmp dos_return_error_already_set
  3192                          +
  3193                                  ;; Copy start cluster to current cluster
  3194                                  ;;
  3195  96a6 a003                       ldy #3
  3196  96a8 bdbabc             docf1:  lda dos_file_descriptors + dos_filedescriptor_offset_startcluster   ,x
  3197  96ab 9dbebc                     sta dos_file_descriptors + dos_filedescriptor_offset_currentcluster ,x
  3198  96ae e8                         inx
  3199  96af 88                         dey
  3200  96b0 10f6                       bpl docf1
  3201                          
  3202  96b2 20c596                     jsr dos_get_file_descriptor_offset
  3203  96b5 a900                       lda #$00
  3204                          
  3205                                  ;; sectorincluster, offsetinsector, fileoffset are contiguous, which allows
  3206                                  ;; us to clear these more efficiently.
  3207                                  ;;
  3208  96b7 a006                       ldy #6
  3209  96b9 9dc2bc             docf2:  sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
  3210  96bc e8                         inx
  3211  96bd 88                         dey
  3212  96be d0f9                       bne docf2
  3213                          
  3214  96c0 20c596                     jsr dos_get_file_descriptor_offset
  3215                          
  3216  96c3 38                         sec
  3217  96c4 60                         rts
  3218                          
  3219                          ;;         ========================
  3220                          
  3221                                  ;; Load A & X with the offset of the current file descriptor, relative to
  3222                                  ;; dos_file_descriptors.
  3223                          
  3224                          dos_get_file_descriptor_offset:
  3225                          
  3226  96c5 adf8bc                     lda dos_current_file_descriptor
  3227  96c8 c904                       cmp #4
  3228  96ca b007                       bcs dos_bad_file_descriptor
  3229  96cc 0a                         asl
  3230  96cd 0a                         asl
  3231  96ce 0a                         asl
  3232  96cf 0a                         asl
  3233  96d0 aa                         tax
  3234  96d1 38                         sec
  3235  96d2 60                         rts
  3236                          
  3237                          ;;         ========================
  3238                          
  3239                          dos_bad_file_descriptor:
  3240                          
  3241  96d3 a989                       lda #dos_errorcode_invalid_file_descriptor
  3242  96d5 4c7a92                     jmp dos_return_error
  3243                          
  3244                          ;;         ========================
  3245                          
  3246                          dos_set_current_cluster_from_file:
  3247                          
  3248                                  ;; copy cluster number in file to current cluster
  3249                                  ;;
  3250  96d8 20c596                     jsr dos_get_file_descriptor_offset
  3251  96db 901d                       bcc l2_dos_return_error_already_set
  3252                          
  3253  96dd a000                       ldy #$00
  3254  96df bdbebc             dfrcs1: lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  3255  96e2 99b3bc                     sta dos_current_cluster,y
  3256  96e5 e8                         inx
  3257  96e6 c8                         iny
  3258  96e7 c004                       cpy #$04
  3259  96e9 d0f4                       bne dfrcs1
  3260  96eb 60                         rts
  3261                          
  3262                          ;;         ========================
  3263                          
  3264                          dos_file_read_current_sector:
  3265                          
  3266  96ec 20c596                     jsr dos_get_file_descriptor_offset
  3267  96ef 20d896                     jsr dos_set_current_cluster_from_file
  3268  96f2 20b992                     jsr dos_cluster_to_sector
  3269                          
  3270                                  ;; Add sector within cluster
  3271                                  ;;
  3272  96f5 20c596                     jsr dos_get_file_descriptor_offset
  3273  96f8 b003                       bcs gotFDOffset
  3274                          l2_dos_return_error_already_set:
  3275  96fa 4c7d92                     jmp dos_return_error_already_set
  3276                          gotFDOffset:
  3277                          
  3278                                  ;; Set A to the offset of the sectorincluster field of the current
  3279                                  ;; file descriptor
  3280                                  ;;
  3281  96fd 090a                       ora #dos_filedescriptor_offset_sectorincluster
  3282                          
  3283                                  ;; Now put that offset in y, so that we can load the sector number in the
  3284                                  ;; current cluster for the current file descriptor
  3285                                  ;;
  3286  96ff a8                         tay
  3287  9700 b9b8bc                     lda dos_file_descriptors,y
  3288                          
  3289                                  ;; add sector number in cluster to current sector number (which is the
  3290                                  ;; start of the cluster)
  3291                                  ;;
  3292  9703 202e9b                     jsr sdsector_add_uint8
  3293                          
  3294  9706 4ce49f                     jmp sd_readsector
  3295                          
  3296                          ;;         ========================
  3297                          
  3298                          dos_file_advance_to_next_sector:
  3299                          
  3300                                  ;; Increment file position offset by 2 pages
  3301                                  ;;
  3302  9709 aef9bc                     ldx dos_current_file_descriptor_offset
  3303                          
  3304  970c bdc5bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0 ,x
  3305  970f 18                         clc
  3306  9710 6902                       adc #$02
  3307  9712 9dc5bc                     sta dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0 ,x
  3308  9715 9008                       bcc dfatns1
  3309  9717 fec6bc                     inc dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1 ,x
  3310  971a d003                       bne dfatns1
  3311  971c fec7bc                     inc dos_file_descriptors + dos_filedescriptor_offset_fileoffset+2 ,x
  3312                          dfatns1:
  3313                          
  3314                                  ;; increase sector
  3315                                  ;;
  3316  971f fec2bc                     inc dos_file_descriptors + dos_filedescriptor_offset_sectorincluster ,x
  3317  9722 bdc2bc                     lda dos_file_descriptors + dos_filedescriptor_offset_sectorincluster ,x
  3318  9725 ac04bc                     ldy dos_disk_table_offset
  3319                          
  3320  9728 d916bb                     cmp dos_disk_table + fs_fat32_sectors_per_cluster ,y
  3321                          
  3322                                  ;; and if necessary, advance to next cluster
  3323                                  ;;
  3324  972b f002                       beq dos_file_advance_to_next_cluster
  3325  972d 38                         sec
  3326  972e 60                         rts
  3327                          
  3328                          ;;         ========================
  3329                          
  3330                          dos_file_advance_to_next_cluster:
  3331                          
  3332                                  ;; set to sector 0 in cluster
  3333                                  ;;
  3334  972f acf9bc                     ldy dos_current_file_descriptor_offset
  3335  9732 a900                       lda #$00
  3336  9734 99c2bc                     sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,y
  3337                          
  3338                                  ;; read chained cluster number for fs_clusternumber
  3339                          
  3340                                  ;; FAT32 uses 32-bit cluster numbers.
  3341                                  ;; the text below may be misleading, as we have 8 sectors per cluster
  3342                                  ;; 512 / 4 = 128 cluster numbers per sector.
  3343                                  ;; To get the sector of the FAT containin a particular
  3344                                  ;; cluster entry, we thus need to shift the cluster number
  3345                                  ;; right 7 bits.  Then we add the start sector number of the FAT.
  3346                          
  3347  9737 20d896                     jsr dos_set_current_cluster_from_file
  3348                          
  3349                                  ;; copy cluster to sector number
  3350                                  ;;
  3351  973a a203                       ldx #$03
  3352                          dfanc1:
  3353  973c bdb3bc                     lda dos_current_cluster,x
  3354  973f 9dafbc                     sta dos_current_sector,x
  3355  9742 ca                         dex
  3356  9743 10f7                       bpl dfanc1
  3357                          
  3358                                  ;; Remember low byte of cluster number so that we can pull the
  3359                                  ;; cluster number for the next cluster out of the FAT sector
  3360                                  ;;
  3361  9745 adb3bc                     lda dos_current_cluster
  3362  9748 8d04bf                     sta dos_scratch_byte_1
  3363                          
  3364  974b 200c98                     jsr dos_cluster_to_fat_sector
  3365                          
  3366  974e 20f197             	jsr dos_remember_sd_sector
  3367                          	
  3368                                  ;; copy from current cluster to SD sector address register
  3369                                  ;;
  3370  9751 a203                       ldx #$03
  3371  9753 08                         php
  3372                          dfanc41:
  3373  9754 bdb3bc                     lda dos_current_cluster,x
  3374  9757 9d81d6                     sta $d681,x
  3375  975a ca                         dex
  3376  975b 10f7                       bpl dfanc41
  3377                          
  3378                          dfanc44:
  3379  975d 28                         plp
  3380  975e bdb3bc                     lda dos_current_cluster,x
  3381  9761 6900                       adc #$00
  3382  9763 9db3bc                     sta dos_current_cluster,x
  3383  9766 08                         php
  3384  9767 e8                         inx
  3385  9768 e004                       cpx #$04
  3386  976a d0f1                       bne dfanc44
  3387                          
  3388  976c 28                         plp
  3389                          
  3390                                  ;; read FAT sector
  3391                                  ;;
  3392  976d 20e49f                     jsr sd_readsector
  3393  9770 b003                       bcs @readSectorOk
  3394  9772 4c7d92                     jmp dos_return_error_already_set
  3395                          @readSectorOk:
  3396                          
  3397  9775 20cf9f                     jsr sd_map_sectorbuffer
  3398                          
  3399                                  ;; now read the right four bytes out.
  3400                                  ;; cluster number needs to be shifted left 2 bits.
  3401                                  ;; we only need the lowest order byte.
  3402                                  ;; Get low byte of old cluster number from dos_scratch_byte_1
  3403                                  ;; where we put it.
  3404                                  ;;
  3405  9778 ad04bf                     lda dos_scratch_byte_1
  3406  977b 0a                         asl
  3407  977c 0a                         asl
  3408  977d aa                         tax
  3409                          
  3410                                  ;; get offset to current cluster field in current file descriptor ...
  3411  977e adf9bc                     lda dos_current_file_descriptor_offset
  3412  9781 0906                       ora #dos_filedescriptor_offset_currentcluster
  3413  9783 a8                         tay
  3414                          
  3415                                  ;; ... and keep it handy, because we will need it a few times
  3416                                  ;;
  3417  9784 8c05bf                     sty dos_scratch_byte_2
  3418                          
  3419                                  ;; get offset of current cluster number field in file descriptor
  3420                                  ;; so that we can write the new cluster number in there.
  3421                                  ;;
  3422  9787 ac05bf                     ldy dos_scratch_byte_2
  3423                          
  3424  978a a300                       ldz #$00
  3425  978c ad04bf                     lda dos_scratch_byte_1
  3426  978f 2940                       and #$40
  3427  9791 d00f                       bne dfanc_high
  3428                          
  3429  9793 bd00de             dfanc6: lda sd_sectorbuffer,x
  3430  9796 99b8bc                     sta dos_file_descriptors,y
  3431  9799 e8                         inx
  3432  979a c8                         iny
  3433  979b 1b                         inz
  3434  979c c204                       cpz #$04
  3435  979e d0f3                       bne dfanc6
  3436  97a0 800d                       bra dfanc_check
  3437                          
  3438                          dfanc_high:
  3439  97a2 bd00df                     lda sd_sectorbuffer+$100,x
  3440  97a5 99b8bc                     sta dos_file_descriptors,y
  3441  97a8 e8                         inx
  3442  97a9 c8                         iny
  3443  97aa 1b                         inz
  3444  97ab c204                       cpz #$04
  3445  97ad d0f3                       bne dfanc_high
  3446                          
  3447                          dfanc_check:
  3448                                  ;; check that resulting cluster number is valid.
  3449                          
  3450                          ;;         jsr debug_show_cluster_number
  3451                          
  3452                                  ;; get current cluster field address again
  3453                                  ;;
  3454  97af ac05bf                     ldy dos_scratch_byte_2
  3455                          
  3456                                  ;; First, only the lower 28-bits are valid
  3457                                  ;;
  3458  97b2 b9bbbc                     lda dos_file_descriptors+3,y
  3459  97b5 290f                       and #$0f
  3460  97b7 99bbbc                     sta dos_file_descriptors+3,y
  3461                          
  3462                                  ;; Now check for special values:
  3463                                  ;; cluster 0 is invalid
  3464                                  ;;
  3465  97ba b9bbbc                     lda dos_file_descriptors+3,y
  3466  97bd 19babc                     ora dos_file_descriptors+2,y
  3467  97c0 19b9bc                     ora dos_file_descriptors+1,y
  3468  97c3 19b8bc                     ora dos_file_descriptors,y
  3469  97c6 c900                       cmp #$00
  3470  97c8 f01f                       beq dfanc_fail
  3471                          
  3472                                  ;; $FFFFFF7 = bad cluster
  3473                                  ;; $FFFFFFF = end of file
  3474                                  ;; (we'll treat anything from $FFFFFF0-F as bad/invalid for simplicity)
  3475  97ca b9bbbc                     lda dos_file_descriptors+3,y
  3476  97cd c90f                       cmp #$0f
  3477  97cf d013                       bne dfanc_ok
  3478  97d1 b9babc                     lda dos_file_descriptors+2,y
  3479  97d4 39b9bc                     and dos_file_descriptors+1,y
  3480  97d7 c9ff                       cmp #$ff
  3481  97d9 d009                       bne dfanc_ok
  3482  97db b9b8bc                     lda dos_file_descriptors,y
  3483  97de 29f0                       and #$f0
  3484  97e0 c9f0                       cmp #$f0
  3485  97e2 f005                       beq dfanc_fail
  3486                          
  3487                          dfanc_ok:
  3488                                  ;; cluster number is okay
  3489  97e4 20fd97             	jsr dos_restore_sd_sector
  3490  97e7 38                         sec
  3491  97e8 60                         rts
  3492                          
  3493                          dfanc_fail:
  3494  97e9 20fd97             	jsr dos_restore_sd_sector
  3495  97ec a985                       lda #dos_errorcode_invalid_cluster
  3496  97ee 4c7a92                     jmp dos_return_error
  3497                          
  3498                          	;; Some routines disturb the current SD card sector in the buffer,
  3499                          	;; but where the caller might not expect or want this to happen.
  3500                          	;; For this reason we have the following convenience routines for
  3501                          	;; stashing and restoring the current ready sector.
  3502                          dos_remember_sd_sector:
  3503  97f1 a203               	ldx #3
  3504  97f3 bd81d6             -	lda $d681,x
  3505  97f6 9d55bd             	sta dos_stashed_sd_sector_number,x
  3506  97f9 ca                 	dex
  3507  97fa 10f7               	bpl -
  3508  97fc 60                 	rts
  3509                          
  3510                          dos_restore_sd_sector:
  3511  97fd a203               	ldx #3
  3512  97ff bd55bd             -	lda dos_stashed_sd_sector_number,x
  3513  9802 9d81d6             	sta $d681,x
  3514  9805 ca                 	dex
  3515  9806 10f7               	bpl -
  3516  9808 20e49f             	jsr sd_readsector
  3517  980b 60                 	rts
  3518                          	
  3519                          	
  3520                          ;;         ========================
  3521                          
  3522                          dos_cluster_to_fat_sector:
  3523                                  ;; Take dos_current_cluster, as a cluster number,
  3524                                  ;; and compute the absolute sector number on the SD card
  3525                                  ;; where that cluster must live.
  3526                                  ;; INPUT: dos_current_cluster = cluster number
  3527                                  ;; OUTPUT: dos_current_cluster = absolute sector, which
  3528                                  ;;         contains the FAT sector that has the FAT entry
  3529                                  ;;         corresponding to the requested cluster number.
  3530                          
  3531                                  ;; shift right 7 times = divide by 128
  3532                                  ;;
  3533  980c a007                       ldy #$07
  3534  980e 18                 dfanc2: clc
  3535  980f 6eb6bc                     ror dos_current_cluster+3
  3536  9812 6eb5bc                     ror dos_current_cluster+2
  3537  9815 6eb4bc                     ror dos_current_cluster+1
  3538  9818 6eb3bc                     ror dos_current_cluster+0
  3539  981b 88                         dey
  3540  981c d0f0                       bne dfanc2
  3541                          
  3542                                  ;; add start of partition offset
  3543                                  ;;
  3544  981e ac04bc                     ldy dos_disk_table_offset
  3545  9821 a200                       ldx #$00
  3546  9823 18                         clc
  3547  9824 08                         php
  3548  9825 28                 dfanc3: plp
  3549  9826 bdb3bc                     lda dos_current_cluster,x
  3550  9829 7900bb                     adc dos_disk_table + fs_start_sector ,y
  3551  982c 9db3bc                     sta dos_current_cluster,x
  3552  982f 08                         php
  3553  9830 c8                         iny
  3554  9831 e8                         inx
  3555  9832 e004                       cpx #$04
  3556  9834 d0ef                       bne dfanc3
  3557  9836 28                         plp
  3558                          
  3559                                  ;; add start of fat offset
  3560                                  ;;
  3561  9837 ac04bc                     ldy dos_disk_table_offset
  3562  983a a200                       ldx #$00
  3563  983c 18                         clc
  3564  983d 08                         php
  3565  983e 28                 dfanc4: plp
  3566  983f bdb3bc                     lda dos_current_cluster,x
  3567  9842 790dbb                     adc dos_disk_table + fs_fat32_system_sectors ,y
  3568  9845 9db3bc                     sta dos_current_cluster,x
  3569  9848 08                         php
  3570  9849 c8                         iny
  3571  984a e8                         inx
  3572  984b e002                       cpx #$02
  3573  984d d0ef                       bne dfanc4
  3574                          
  3575  984f 28                         plp
  3576                          
  3577  9850 60                         rts
  3578                          
  3579                          ;;         ========================
  3580                          
  3581                          !if DEBUG_HYPPO {
  3582                          dos_print_current_cluster:
  3583                          
  3584                                  ;; prints a message to the screen
  3585                                  ;;
  3586                                  ldx #<msg_clusternumber
  3587                                  ldy #>msg_clusternumber
  3588                                  jsr printmessage
  3589                                  ldy #$00
  3590                                  ldz dos_current_cluster+3
  3591                                  jsr printhex
  3592                                  ldz dos_current_cluster+2
  3593                                  jsr printhex
  3594                                  ldz dos_current_cluster+1
  3595                                  jsr printhex
  3596                                  ldz dos_current_cluster+0
  3597                                  jsr printhex
  3598                          
  3599                                  +Checkpoint "dos_print_current_cluster"
  3600                          
  3601                                  rts
  3602                          }
  3603                          
  3604                          ;;         ========================
  3605                          
  3606                          dos_readfileintomemory:
  3607                          
  3608                                  ;; assumes that filename is already set using "dos_setname", which
  3609                                  ;; copies filename string into "dos_requested_filename",
  3610                                  ;;        and sets length into "dos_requested_filename_length".
  3611                                  ;;
  3612                                  ;; assumes that the 32-bit load-address pointer is set by
  3613                                  ;; storing load-address at "dos_file_loadaddress+{0-3}"
  3614                          
  3615                                  ;; print some debug information
  3616                                  ;;
  3617                                  ;;         jsr dos_print_current_cluster
  3618                          
  3619                                  ;; Clear number of sectors read
  3620  9851 a200                       ldx #$00
  3621  9853 8ea9bc                     stx dos_sectorsread
  3622  9856 8eaabc                     stx dos_sectorsread+1
  3623                          
  3624  9859 20cc93                     jsr dos_findfirst
  3625  985c 08                         php
  3626                          
  3627                                  ;; close directory now that we have what we were looking for ...
  3628                                  ;;
  3629  985d 206693                     jsr dos_closefile
  3630  9860 28                         plp
  3631                          
  3632                                  ;; ... but report if we hit an error
  3633                                  ;;
  3634  9861 900b                       bcc l_dos_return_error_already_set
  3635                          
  3636  9863 20ac93                     jsr dos_openfile
  3637  9866 9006                       bcc l_dos_return_error_already_set
  3638                          
  3639  9868 20cf9f                     jsr sd_map_sectorbuffer
  3640                          
  3641  986b 4c7198                     jmp drfim_sector_loop
  3642                          
  3643                          l_dos_return_error_already_set:
  3644  986e 4c7d92                     jmp dos_return_error_already_set
  3645                          
  3646                          ;;         ========================
  3647                          
  3648                          drfim_sector_loop:
  3649                          
  3650  9871 20ec96                     jsr dos_file_read_current_sector
  3651  9874 903d                       bcc drfim_eof
  3652                          
  3653                                  ;; copy sector to memory
  3654                                  ;;
  3655                          
  3656                                  ;; Work out how many bytes of this page we need to read
  3657  9876 20b998                     jsr dos_load_y_based_on_dos_bytes_remaining
  3658                          
  3659  9879 a200                       ldx #$00
  3660  987b a300                       ldz #$00
  3661                          
  3662                                  ;; Actually write the bytes to memory that have been loaded
  3663                          drfim_rr1:
  3664  987d bd00de                     lda sd_sectorbuffer,x                ;; is $DE00
  3665  9880 ea9218                     sta [<dos_file_loadaddress],z
  3666  9883 1b                         inz ;; dest offset
  3667  9884 e8                         inx ;; src offset
  3668  9885 88                         dey ;; bytes in page to copy
  3669  9886 d0f5                       bne drfim_rr1
  3670                          
  3671  9888 e319                       inw <dos_file_loadaddress+1
  3672                          
  3673                                  ;; Work out how many bytes of this page we need to read
  3674  988a 20b998                     jsr dos_load_y_based_on_dos_bytes_remaining
  3675                          
  3676                                  ;; Actually write the bytes to memory that have been loaded
  3677                          drfim_rr1b:
  3678  988d bd00df                     lda sd_sectorbuffer+$100,x        ;; is $DF00
  3679  9890 ea9218                     sta [<dos_file_loadaddress],z
  3680  9893 1b                         inz ;; dest offset
  3681  9894 e8                         inx ;; src offset
  3682  9895 88                         dey ;; bytes in page to copy
  3683  9896 d0f5                       bne drfim_rr1b
  3684                          
  3685  9898 200997                     jsr dos_file_advance_to_next_sector
  3686  989b 9016                       bcc drfim_eof
  3687                          
  3688                                  ;; We only allow loading into a 16MB space
  3689                                  ;; Provided that we check the load address before starting,
  3690                                  ;; this ensures that a user-land request cannot load a huge file
  3691                                  ;; that eventually overwrites the hypervisor and results in privilege
  3692                                  ;; escalation.
  3693                                  ;; This restriction to a 16MB space is implemented by only incrementing the middle 2 bytes of
  3694                                  ;; the address, instead of all 3 upper bytes.
  3695                                  ;;
  3696  989d e319                       inw <dos_file_loadaddress+1
  3697                          
  3698                                  ;; Increment number of sectors read (16 bit valie)
  3699                                  ;;
  3700  989f eea9bc                     inc dos_sectorsread
  3701  98a2 d0cd                       bne drfim_sector_loop
  3702                          
  3703  98a4 eeaabc                     inc dos_sectorsread+1
  3704                                  ;; see if there is another sector
  3705  98a7 d0c8                       bne drfim_sector_loop
  3706                          
  3707  98a9 206693                     jsr dos_closefile
  3708                          
  3709                                  ;; File is >65535 sectors (32MB), report error
  3710                                  ;;
  3711  98ac a983                       lda #dos_errorcode_file_too_long
  3712  98ae 4c7a92                     jmp dos_return_error
  3713                          
  3714                          ;;         ========================
  3715                          
  3716                          drfim_eof_pop_pc:
  3717  98b1 68                         pla
  3718  98b2 68                         pla
  3719                          
  3720                          drfim_eof:
  3721                          
  3722  98b3 206693                     jsr dos_closefile
  3723  98b6 4c7392                     jmp dos_return_success
  3724                          
  3725                          dos_load_y_based_on_dos_bytes_remaining:
  3726  98b9 a000                       ldy #$00
  3727  98bb adacbc                     lda dos_bytes_remaining+1
  3728  98be 0dadbc                     ora dos_bytes_remaining+2
  3729  98c1 0daebc                     ora dos_bytes_remaining+3
  3730  98c4 d00e                       bne +
  3731  98c6 adabbc                     lda dos_bytes_remaining+0
  3732                                  ;; If no more bytes to read, then jump to EOF
  3733  98c9 f0e6                       beq drfim_eof_pop_pc
  3734  98cb acabbc                     ldy dos_bytes_remaining+0
  3735  98ce a900                       lda #$00
  3736  98d0 8dabbc                     sta  dos_bytes_remaining+0
  3737  98d3 60                         rts
  3738                          +
  3739  98d4 adacbc                     lda dos_bytes_remaining+1
  3740  98d7 38                         sec
  3741  98d8 e901                       sbc #$01
  3742  98da 8dacbc                     sta dos_bytes_remaining+1
  3743  98dd adadbc                     lda dos_bytes_remaining+2
  3744  98e0 e900                       sbc #0
  3745  98e2 8dadbc                     sta dos_bytes_remaining+2
  3746  98e5 adaebc                     lda dos_bytes_remaining+3
  3747  98e8 e900                       sbc #0
  3748  98ea 8daebc                     sta dos_bytes_remaining+3
  3749  98ed 60                         rts
  3750                          
  3751                          
  3752                          dos_readfile:
  3753                          
  3754                          ;; 	ldx dos_bytes_remaining+3 
  3755                          ;; 	jsr checkpoint_bytetohex
  3756                          ;; 	sty lenhex+0
  3757                          ;; 	stx lenhex+1
  3758                          ;; 	ldx dos_bytes_remaining+2
  3759                          ;; 	jsr checkpoint_bytetohex
  3760                          ;; 	sty lenhex+2
  3761                          ;; 	stx lenhex+3
  3762                          ;; 	ldx dos_bytes_remaining+1
  3763                          ;; 	jsr checkpoint_bytetohex
  3764                          ;; 	sty lenhex+4
  3765                          ;; 	stx lenhex+5
  3766                          ;; 	ldx dos_bytes_remaining+0
  3767                          ;; 	jsr checkpoint_bytetohex
  3768                          ;; 	sty lenhex+6
  3769                          ;; 	stx lenhex+7
  3770                          	
  3771                          ;; 	jsr checkpoint
  3772                          ;; 	!8 0
  3773                          ;; 	ascii("$")
  3774                          ;; lenhex:	
  3775                          ;; 	ascii("%%%%%%%% bytes remaining.")
  3776                          ;; 	!8 0
  3777                          	
  3778  98ee adabbc             	lda dos_bytes_remaining+0
  3779  98f1 0dacbc             	ora dos_bytes_remaining+1
  3780  98f4 0dadbc             	ora dos_bytes_remaining+2
  3781  98f7 0daebc             	ora dos_bytes_remaining+3
  3782  98fa d00a               	bne +
  3783                          
  3784                          	;; End of file: So zero bytes returned
  3785  98fc a900               	lda #$00
  3786  98fe 8d41d6             	sta hypervisor_x
  3787  9901 8d42d6             	sta hypervisor_y
  3788  9904 18                 	clc
  3789  9905 60                 	rts
  3790                          	
  3791                          +
  3792                          	;; Indicate how many bytes we are returning
  3793  9906 a200               	ldx #<$0200
  3794  9908 a002               	ldy #>$0200
  3795                          	
  3796  990a adadbc             	lda dos_bytes_remaining+2
  3797  990d 0daebc             	ora dos_bytes_remaining+3
  3798  9910 d017               	bne +   ;; lots more to read
  3799  9912 adacbc             	lda dos_bytes_remaining+1
  3800  9915 c902               	cmp #2
  3801  9917 b010               	bcs +   ;; at least a whole sector more to read
  3802                          
  3803                          	;; Only a fractional part of a sector to read, so zero out remaining
  3804                          
  3805                          	;; Update number of bytes for fractional sector read
  3806  9919 aeabbc             	ldx dos_bytes_remaining+0
  3807  991c acacbc             	ldy dos_bytes_remaining+1
  3808                          	
  3809  991f a900               	lda #$00
  3810  9921 8dabbc             	sta dos_bytes_remaining+0
  3811                          	;; Actually make it look like 1 sector to go, so we decrement that to zero
  3812                          	;; immediately below
  3813  9924 a902               	lda #$02
  3814  9926 8dacbc             	sta dos_bytes_remaining+1
  3815                          	;; FALL THROUGH
  3816                          +
  3817                          	
  3818                          	;; Deduct one sector from the remaining
  3819  9929 adacbc             	lda dos_bytes_remaining+1
  3820  992c 38                 	sec
  3821  992d e902               	sbc #2
  3822  992f 8dacbc             	sta dos_bytes_remaining+1
  3823  9932 adadbc             	lda dos_bytes_remaining+2
  3824  9935 e900               	sbc #0
  3825  9937 8dadbc             	sta dos_bytes_remaining+2
  3826  993a adaebc             	lda dos_bytes_remaining+3
  3827  993d e900               	sbc #0
  3828  993f 8daebc             	sta dos_bytes_remaining+3
  3829                          
  3830                          	;; Store number of bytes read in X and Y for calling process
  3831  9942 8e41d6             	stx hypervisor_x
  3832  9945 8c42d6             	sty hypervisor_y
  3833                          	
  3834                          	;; Now read sector and return
  3835                          	
  3836  9948 20cf9f                     jsr sd_map_sectorbuffer
  3837  994b 20ec96                     jsr dos_file_read_current_sector
  3838  994e b001                       bcs drf_gotsector
  3839  9950 60                 	rts
  3840                          	
  3841                          drf_gotsector:
  3842                          	;; Then advance to next sector.
  3843                          	;; Ignore the error, as the EOF will get picked up on the next call.
  3844                          
  3845  9951 200997             	jsr dos_file_advance_to_next_sector
  3846                          
  3847  9954 38                 	sec
  3848  9955 60                 	rts
  3849                          	
  3850                          	
  3851                          ;;         ========================
  3852                          
  3853                          dos_setname:
  3854                          
  3855                                  ;; INPUT: .X .Y = pointer to filename,
  3856                                  ;;                 filename string must be terminated with $00
  3857                                  ;;                 filename string must be <= $3F chars
  3858                          
  3859  9956 8600                       stx <dos_scratch_vector
  3860  9958 8401                       sty <(dos_scratch_vector+1)
  3861  995a a000                       ldy #$00
  3862                          
  3863  995c b100               lr11:   lda (<dos_scratch_vector),y
  3864  995e 9967bc                     sta dos_requested_filename,y
  3865  9961 f00e                       beq dsn_eon
  3866  9963 c8                         iny
  3867  9964 c040                       cpy #$40
  3868  9966 d0f4                       bne lr11
  3869                          
  3870  9968 a900                       lda #0
  3871  996a 8d66bc                     sta dos_requested_filename_len
  3872  996d a981                       lda #dos_errorcode_name_too_long
  3873  996f 18                         clc
  3874  9970 60                         rts
  3875                          
  3876                          dsn_eon:
  3877  9971 8c66bc                     sty dos_requested_filename_len
  3878                          
  3879  9974 38                         sec
  3880  9975 60                         rts
  3881                          
  3882                          ;;         ========================
  3883                          
  3884                          dos_d81detach:
  3885                          	;; Detaches both drive 0 and drive 1
  3886                          	
  3887  9976 a900                       lda #$00
  3888  9978 8d8bd6                     sta $d68b
  3889                          
  3890                                  ;; Mark it as unmounted (but preserve other flags for remounting, e.g., if it should be write-enabled)
  3891  997b ad11bd                     lda currenttask_d81_image0_flags
  3892  997e 0901                       ora #d81_image_flag_mounted
  3893  9980 4901                       eor #d81_image_flag_mounted
  3894  9982 8d11bd                     sta currenttask_d81_image0_flags
  3895                          
  3896                                  ;; But we leave the file name there, in case someone wants to re-mount the image.
  3897                                  ;; This is exactly what happens when a process is unfrozen: dos_d81detach is called,
  3898                                  ;; followed by dos_d81attach, after first retrieving the filename
  3899  9985 38                         sec
  3900  9986 60                         rts
  3901                          
  3902                          dos_d81attach0:
  3903                          
  3904                          	;;  Always works on drive 0
  3905                          	
  3906                                  ;; Assumes only that D81 file name has been set with dos_setname.
  3907                                  ;;
  3908  9987 20c093                     jsr dos_findfile
  3909  998a b004                       bcs d81a1
  3910                          
  3911  998c a988                       lda #dos_errorcode_file_not_found
  3912  998e 18                         clc
  3913  998f 60                         rts
  3914                          
  3915                          ;;         ========================
  3916                          
  3917                          d81a1:        ;; XXX - Why do we call closefile here?
  3918  9990 206693                     jsr dos_closefile
  3919                          
  3920  9993 20519a                     jsr dos_d81check
  3921  9996 b001                       bcs d81a1a
  3922  9998 60                         rts
  3923                          d81a1a:	
  3924                          
  3925                                  ;; copy sector number from $D681 to $D68c
  3926                                  ;;
  3927  9999 a203                       ldx #$03
  3928  999b bd81d6             l94d:   lda $d681,x		;; resolved sector number
  3929  999e 9d8cd6                     sta $d68c,x  		;; sector number of disk image #0
  3930  99a1 ca                         dex
  3931  99a2 10f7                       bpl l94d
  3932                          	
  3933                                  // disable real floppy 0
  3934  99a4 ada1d6                     lda $d6a1
  3935  99a7 29fe                       and #$fe
  3936  99a9 8da1d6                     sta $d6a1
  3937                                  
  3938                                  // Set flags to indicate it is mounted (and read-write)
  3939                                  // But don't mess up the flags for the 2nd drive
  3940  99ac ad8bd6             	lda $d68b
  3941  99af 29b8               	and #%10111000
  3942  99b1 0907                       ora #$07
  3943  99b3 8d8bd6                     sta $d68b
  3944                          
  3945                          	;; And set the MEGAfloppy flag if the file is ~5.5MiB long
  3946  99b6 ad2ebf             	lda d81_clustercount+1
  3947  99b9 c905               	cmp #$05
  3948  99bb d00a               	bne not_mega_floppy2
  3949                          
  3950  99bd ad8bd6             	lda $d68b
  3951  99c0 29b8               	and #%10111000
  3952  99c2 0947                       ora #$47
  3953  99c4 8d8bd6             	sta $d68b
  3954                          
  3955                          not_mega_floppy2:	
  3956                          
  3957                                  +Checkpoint "dos_d81attach0 <success>"
  3958                          
  3959                                  ;; Save name and set mount flag for disk image in process descriptor block
  3960  99c7 a901                       lda #d81_image_flag_mounted
  3961  99c9 8d11bd                     sta currenttask_d81_image0_flags
  3962                          
  3963  99cc ae66bc                     ldx dos_requested_filename_len
  3964                          
  3965                                  ;; Check if the filename of the disk image is too long
  3966  99cf e020                       cpx #d81_image_max_namelen
  3967  99d1 b013                       bcs @d81NameTooLongForProcessDescriptor
  3968                          
  3969                                  ;; Name not too long, save name and length
  3970  99d3 8e13bd                     stx currenttask_d81_image0_namelen
  3971  99d6 a200                       ldx #0
  3972  99d8 bd67bc             -       lda dos_requested_filename,x
  3973  99db 9d15bd                     sta currenttask_d81_image0_name,x
  3974  99de e8                         inx
  3975  99df ec13bd                     cpx currenttask_d81_image0_namelen
  3976  99e2 d0f4                       bne -
  3977                          
  3978  99e4 38                         sec
  3979  99e5 60                         rts
  3980                          
  3981                          @d81NameTooLongForProcessDescriptor:
  3982                                  ;; Name is too long, so don't save it.
  3983                                  ;; This means that the disk image will unmount on freeze, and will not re-mount after
  3984                                  ;; XXX - This should probably be an error.
  3985  99e6 a900                       lda #0
  3986  99e8 8d13bd                     sta currenttask_d81_image0_namelen
  3987                          
  3988  99eb 38                         sec
  3989  99ec 60                         rts
  3990                          
  3991                          dos_d81attach1:
  3992                          
  3993                                  ;; Assumes only that D81 file name has been set with dos_setname.
  3994                                  ;;
  3995  99ed 20c093                     jsr dos_findfile
  3996  99f0 b004                       bcs d81a1b
  3997                          
  3998  99f2 a988                       lda #dos_errorcode_file_not_found
  3999  99f4 18                         clc
  4000  99f5 60                         rts
  4001                          
  4002                          ;;         ========================
  4003                          
  4004                          d81a1b:        ;; XXX - Why do we call closefile here?
  4005  99f6 206693                     jsr dos_closefile
  4006                          
  4007  99f9 20519a                     jsr dos_d81check
  4008  99fc b001                       bcs d81a1ab
  4009  99fe 60                         rts
  4010                          d81a1ab:	
  4011                          
  4012                                  ;; copy sector number from $D681 to $D690
  4013                                  ;;
  4014  99ff a203                       ldx #$03
  4015  9a01 bd81d6             l94db:   lda $d681,x		;; resolved sector number
  4016  9a04 9d90d6                     sta $d690,x  		;; sector number of disk image #1
  4017  9a07 ca                         dex
  4018  9a08 10f7                       bpl l94db
  4019                          		
  4020                                  // disable real floppy 1
  4021  9a0a ada1d6                     lda $d6a1
  4022  9a0d 29fb                       and #$fb
  4023  9a0f 8da1d6                     sta $d6a1
  4024                          
  4025                                  // Set flags to indicate it is mounted (and read-write)
  4026                                  // But don't mess up the flags for the 1st drive
  4027  9a12 ad8bd6             	lda $d68b
  4028  9a15 2947               	and #%01000111
  4029  9a17 0938                       ora #$38
  4030  9a19 8d8bd6                     sta $d68b
  4031                          
  4032                          	;; And set the MEGAfloppy flag if the file is 5500KB long
  4033  9a1c ad2ebf             	lda d81_clustercount+1
  4034  9a1f c905               	cmp #$05
  4035  9a21 d008               	bne not_mega_floppy2b
  4036                          
  4037  9a23 ad8bd6             	lda $d68b
  4038  9a26 0980                       ora #$80
  4039  9a28 8d8bd6             	sta $d68b
  4040                          
  4041                          not_mega_floppy2b:	
  4042                          	
  4043                                  +Checkpoint "dos_d81attach1 <success>"
  4044                          
  4045                                  ;; Save name and set mount flag for disk image in process descriptor block
  4046  9a2b a901                       lda #d81_image_flag_mounted
  4047  9a2d 8d12bd                     sta currenttask_d81_image1_flags
  4048                          
  4049  9a30 ae66bc                     ldx dos_requested_filename_len
  4050                          
  4051                                  ;; Check if the filename of the disk image is too long
  4052  9a33 e020                       cpx #d81_image_max_namelen
  4053  9a35 b013                       bcs @d81NameTooLongForProcessDescriptor1
  4054                          
  4055                                  ;; Name not too long, save name and length
  4056  9a37 8e14bd                     stx currenttask_d81_image1_namelen
  4057  9a3a a200                       ldx #0
  4058  9a3c bd67bc             -       lda dos_requested_filename,x
  4059  9a3f 9d35bd                     sta currenttask_d81_image1_name,x
  4060  9a42 e8                         inx
  4061  9a43 ec14bd                     cpx currenttask_d81_image1_namelen
  4062  9a46 d0f4                       bne -
  4063                          
  4064  9a48 38                         sec
  4065  9a49 60                         rts
  4066                          
  4067                          @d81NameTooLongForProcessDescriptor1:
  4068                                  ;; Name is too long, so don't save it.
  4069                                  ;; This means that the disk image will unmount on freeze, and will not re-mount after
  4070                                  ;; XXX - This should probably be an error.
  4071  9a4a a900                       lda #0
  4072  9a4c 8d14bd                     sta currenttask_d81_image1_namelen
  4073                          
  4074  9a4f 38                         sec
  4075  9a50 60                         rts
  4076                          
  4077                          	
  4078                          dos_d81check:	
  4079                                  ;; now we need to check that the file is long enough,
  4080                                  ;; and also that the clusters are contiguous.
  4081                          
  4082                                  ;; Start by opening the file
  4083                                  ;;
  4084  9a51 205196                     jsr dos_set_current_file_from_dirent
  4085  9a54 9005                       bcc @fileNotOpenedOk
  4086                          
  4087  9a56 20ac93                     jsr dos_openfile
  4088  9a59 b003                       bcs @fileOpenedOk
  4089                          @fileNotOpenedOk:
  4090  9a5b 4c2c9b                     jmp nod81
  4091                          @fileOpenedOk:
  4092                          
  4093                                  ;; work out how many clusters we need
  4094                                  ;; We need 1600 sectors, so halve for every zero tail
  4095                                  ;; bit in sectors per cluster.  we can do this because
  4096                                  ;; clusters in FAT must be 2^n sectors.
  4097                                  ;;
  4098  9a5e a900                       lda #$00
  4099  9a60 8d2dbf                     sta d81_clustercount
  4100  9a63 8d2ebf                     sta d81_clustercount+1
  4101  9a66 a940                       lda #<1600
  4102  9a68 8d2bbf                     sta d81_clustersneeded
  4103  9a6b a906                       lda #>1600
  4104  9a6d 8d2cbf                     sta d81_clustersneeded+1
  4105                          
  4106                                  ;; get sectors per cluster of disk
  4107                                  ;;
  4108  9a70 ae04bc                     ldx dos_disk_table_offset
  4109  9a73 bd16bb                     lda dos_disk_table+fs_fat32_sectors_per_cluster,x
  4110  9a76 4b                         taz
  4111                          
  4112  9a77 6b                 l94:    tza
  4113  9a78 2901                       and #$01
  4114  9a7a d00c                       bne d81firstcluster
  4115  9a7c 6b                         tza
  4116  9a7d 4a                         lsr
  4117  9a7e 4b                         taz
  4118  9a7f 4e2cbf                     lsr d81_clustersneeded+1
  4119  9a82 6e2bbf                     ror d81_clustersneeded
  4120  9a85 4c779a                     jmp l94
  4121                          
  4122                          d81firstcluster:
  4123                                  ;; Get current cluster of D81 file, so that
  4124                                  ;; we can check that clusters in file are contiguous
  4125                                  ;;
  4126  9a88 aef9bc                     ldx dos_current_file_descriptor_offset
  4127  9a8b a000                       ldy #0
  4128                          
  4129  9a8d bdbebc             l94b:   lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  4130  9a90 9927bf                     sta d81_clusternumber,y
  4131  9a93 e8                         inx
  4132  9a94 c8                         iny
  4133  9a95 c004                       cpy #4
  4134  9a97 d0f4                       bne l94b
  4135                          
  4136                          d81nextcluster:
  4137                                  ;; Now read through clusters and make sure that all is
  4138                                  ;; well.
  4139                          
  4140                                  ;; check that it matches expected cluster number
  4141                                  ;;
  4142  9a99 aef9bc                     ldx dos_current_file_descriptor_offset
  4143  9a9c a000                       ldy #0
  4144                          
  4145  9a9e bdbebc             l94a:   lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  4146  9aa1 d927bf                     cmp d81_clusternumber,y
  4147  9aa4 d07f                       bne d81isfragged
  4148  9aa6 e8                         inx
  4149  9aa7 c8                         iny
  4150  9aa8 c004                       cpy #4
  4151  9aaa d0f2                       bne l94a
  4152                          
  4153                                  ;; increment number of clusters found so far
  4154                                  ;;
  4155  9aac ee2dbf                     inc d81_clustercount
  4156  9aaf d003                       bne l96
  4157  9ab1 ee2ebf                     inc d81_clustercount+1
  4158                          l96:
  4159                          
  4160                                  ;; increment expected cluster number
  4161                                  ;;
  4162  9ab4 18                         clc
  4163  9ab5 ad27bf                     lda d81_clusternumber
  4164  9ab8 6901                       adc #$01
  4165  9aba 8d27bf                     sta d81_clusternumber
  4166  9abd ad28bf                     lda d81_clusternumber+1
  4167  9ac0 6900                       adc #$00
  4168  9ac2 8d28bf                     sta d81_clusternumber+1
  4169  9ac5 ad29bf                     lda d81_clusternumber+2
  4170  9ac8 6900                       adc #$00
  4171  9aca 8d29bf                     sta d81_clusternumber+2
  4172  9acd ad2abf                     lda d81_clusternumber+3
  4173  9ad0 6900                       adc #$00
  4174  9ad2 8d2abf                     sta d81_clusternumber+3
  4175                          
  4176  9ad5 202f97                     jsr dos_file_advance_to_next_cluster
  4177  9ad8 b0bf                       bcs d81nextcluster
  4178                          
  4179                                  ;; The above continues until EOF is reached, so clear DOS
  4180                                  ;; error after.
  4181                                  ;;
  4182  9ada a900                       lda #$00
  4183  9adc 8dfabc                     sta dos_error_code
  4184                          
  4185                                  +Checkpoint "dos_d81attach <measured end of image>"
  4186                          
  4187  9adf 206693                     jsr dos_closefile
  4188                          
  4189                                  ;; we have read to end of D81 file, and it is contiguous
  4190                                  ;; now check that it is the right length
  4191                          
  4192                          	;; First check if we read enough for 85 tracks x 64 sectors x 2 sides = 5,570,560 bytes
  4193                          	;; = 1,360 clusters = $0550 clusters
  4194                          	;; XXX - This currently assumes 8 sectors per cluster = 4KB sectors
  4195  9ae2 ad2dbf             	lda d81_clustercount
  4196  9ae5 c950               	cmp #$50
  4197  9ae7 d00f               	bne not_mega_floppy
  4198  9ae9 ad2ebf             	lda d81_clustercount+1
  4199  9aec c905               	cmp #$05
  4200  9aee d008               	bne not_mega_floppy
  4201  9af0 ad2fbf             	lda d81_clustercount+2
  4202  9af3 0d30bf             	ora d81_clustercount+3
  4203  9af6 f010               	beq is_mega_floppy
  4204                          
  4205                          not_mega_floppy:	
  4206                          	;; Is a 5.5MiB MEGA Floppy?
  4207                          	;; (These behave as double-sided 85-track 64-sector disks of 512 byte sectors,
  4208                          	;;  but with normal D81 directory format on side 0 of track 40.)
  4209                          	
  4210  9af8 ad2bbf                     lda d81_clustersneeded
  4211  9afb cd2dbf                     cmp d81_clustercount
  4212  9afe d01e                       bne d81wronglength
  4213                          
  4214  9b00 ad2cbf                     lda d81_clustersneeded+1
  4215  9b03 cd2ebf                     cmp d81_clustercount+1
  4216  9b06 d016                       bne d81wronglength
  4217                          is_mega_floppy:	
  4218                          
  4219                          d81_is_good:	
  4220                                  ;; D81 is good.
  4221                          
  4222                                  ;; Get cluster number again, convert to sector, and copy to
  4223                                  ;; SD controller FDC emulation disk image offset registers
  4224                                  ;;
  4225  9b08 aef9bc                     ldx dos_current_file_descriptor_offset
  4226  9b0b a000                       ldy #0
  4227                          
  4228  9b0d bdbabc             l94c:   lda dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
  4229  9b10 99b3bc                     sta dos_current_cluster,y
  4230  9b13 e8                         inx
  4231  9b14 c8                         iny
  4232  9b15 c004                       cpy #4
  4233  9b17 d0f4                       bne l94c
  4234                          
  4235  9b19 20b992                     jsr dos_cluster_to_sector
  4236                          
  4237  9b1c 38                 	sec
  4238  9b1d 60                 	rts
  4239                          	
  4240                          
  4241                          ;;         ========================
  4242                          
  4243                          d81wronglength:
  4244                                  +Checkpoint "dos_d81attach <wrong length>"
  4245                          
  4246  9b1e a98a                       lda #dos_errorcode_image_wrong_length
  4247  9b20 8dfabc                     sta dos_error_code
  4248  9b23 18                         clc
  4249  9b24 60                         rts
  4250                          
  4251                          ;;         ========================
  4252                          
  4253                          d81isfragged:
  4254                                  +Checkpoint "dos_d81attach <fragmented>"
  4255                          
  4256  9b25 a98b                       lda #dos_errorcode_image_fragmented
  4257  9b27 8dfabc                     sta dos_error_code
  4258  9b2a 18                         clc
  4259  9b2b 60                         rts
  4260                          
  4261                          ;;         ========================
  4262                          
  4263                          nod81:
  4264                                  +Checkpoint "dos_d81attach <file not found>"
  4265                          
  4266  9b2c 18                         clc
  4267  9b2d 60                         rts
  4268                          
  4269                          ;;         ========================
  4270                          
  4271                          sdsector_add_uint8:
  4272                          
  4273  9b2e 48                         pha
  4274  9b2f a900                       lda #0
  4275  9b31 aa                         tax
  4276  9b32 a8                         tay
  4277  9b33 4b                         taz
  4278  9b34 68                         pla
  4279                                  ;; FALL THROUGH to sdsector_add_uint32
  4280                          
  4281                          sdsector_add_uint32:
  4282                          
  4283                                  ;; Add the 32-bit value contained in A,X,Y,Z to
  4284                                  ;; $D681-$D684, the SD card sector number.
  4285                                  ;;
  4286  9b35 18                         clc
  4287  9b36 6d81d6                     adc $D681
  4288  9b39 8d81d6                     sta $D681
  4289  9b3c 8a                         txa
  4290  9b3d 6d82d6                     adc $d682
  4291  9b40 8d82d6                     sta $d682
  4292  9b43 98                         tya
  4293  9b44 6d83d6                     adc $d683
  4294  9b47 8d83d6                     sta $d683
  4295  9b4a 6b                         tza
  4296  9b4b 6d84d6                     adc $d684
  4297  9b4e 8d84d6                     sta $d684
  4298  9b51 a300                       ldz #$00
  4299  9b53 60                         rts
  4300                          
  4301                          ;;         ========================
  4302                          
  4303                          sdsector_add_uint32_from_disktable:
  4304                          
  4305  9b54 0d04bc                     ora dos_disk_table_offset
  4306  9b57 a8                         tay
  4307  9b58 a200                       ldx #$00
  4308  9b5a 18                         clc
  4309  9b5b 08                         php
  4310  9b5c 28                 l23:    plp
  4311  9b5d bd81d6                     lda $D681,x
  4312  9b60 7900bb                     adc dos_disk_table,y
  4313  9b63 9d81d6                     sta $D681,x
  4314  9b66 08                         php
  4315  9b67 c8                         iny
  4316  9b68 e8                         inx
  4317  9b69 e004                       cpx #$04
  4318  9b6b d0ef                       bne l23
  4319  9b6d 28                         plp
  4320  9b6e 60                         rts
  4321                          
  4322                          ;;         ========================
  4323                          
  4324                          makeprintable:
  4325                                  ;; Convert unprintable ASCII characters to question marks
  4326                          
  4327  9b6f c920                       cmp #$20
  4328  9b71 9005                       bcc unprintable
  4329  9b73 c97f                       cmp #$7f
  4330  9b75 b001                       bcs unprintable
  4331  9b77 60                         rts
  4332                          
  4333                          unprintable:
  4334  9b78 a93f                       lda #$3f
  4335  9b7a 60                         rts
  4336                          
  4337                          ;;         ========================

; ******** Source: src/hyppo/main.asm

; ******** Source: dos_write.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          
     5                          ;;     Routines for writing to FAT file system.
     6                          ;;     ---------------------------------------------------------------- */
     7                          
     8                          dos_find_contiguous_free_space:
     9                                  ;; Find a piece of free space in the specified file system
    10                                  ;; (dos_default_disk), and return the first cluster number
    11                                  ;; if it can be found.
    12                                  ;;
    13                                  ;; INPUT: dos_dirent_length = # of clusters required
    14                                  ;; OUTPUT: dos_opendir_cluster = first cluster
    15                                  ;; C flag set on success, clear on failure.
    16                                  ;;
    17                                  ;; FAT32 file systems have the expected first cluster free
    18                                  ;; stored in the 2nd sector of the file system at offset
    19                                  ;; $1EC (actually, this may point to the last allocated cluster).
    20                                  ;; This field is only a suggestion however, to accelerate allocation,
    21                                  ;; and thus should not be relied upon, but rather to allow quick
    22                                  ;; skipping of the already allocated area of disk.
    23                                  ;;
    24                                  ;; The number of clusters we need to allocate is to be provided in
    25                                  ;; dos_opendir_cluster as a 32-bit value, thus allowing for files
    26                                  ;; upto 2^32 * cluster size bytes long to be created.
    27                                  ;; (Note that in practice files are limited to 2GiB - 1 bytes for
    28                                  ;; total compatibility, and 4GiB -1 for fairly decent compatibility,
    29                                  ;; and 256GiB - 1 if we implement the FAT+ specification
    30                                  ;; (http:;;www.fdos.org/kernel/fatplus.txt.1) in the appropriate places
    31                                  ;; at some point, which we will likely do, as it is really very simple.
    32                                  ;; Mostly we just have to use 40 bit offsets for file lengths.
    33                          
    34                                  ;; Let's start with a completely naive algorithm:
    35                                  ;; 1. Begin at cluster 2. Reset # of contiguous clusters found to zero.
    36                                  ;;    Remember this cluster as candidatee starting point.
    37                                  ;; 2. If current cluster not free, advance to next cluster number, reset
    38                                  ;;    contiguous free cluster count.  Remember the newly advanced cluster
    39                                  ;;    number as candidate starting point.
    40                                  ;; 3. If current cluster is free, increase contiguous free clusters found.
    41                                  ;;    If equal to desired number, return candidate cluster number.
    42                                  ;; 4. Repeat 2 and 3 above until end of file system is reached (and return
    43                                  ;;    an error), or until step 3 has returned success.
    44                                  ;;
    45                                  ;; This algorithm can be made more efficient by using the last allocated
    46                                  ;; cluster number field as an alternative starting point, and only if that
    47                                  ;; fails, retrying beginning at cluster 2.
    48                          
    49                                  ;; So the state we need to keep track of is:
    50                                  ;; dos_opendir_cluster = current cluster we are considering as candidate starting point.
    51                                  ;; dos_file_loadaddress = current cluster being tested for vacancy.
    52                                  ;; dos_dirent_length = number of clusters required, in total.
    53                                  ;; dos_dirent_cluster = number of clusters required, from this point
    54                                  ;; (i.e., the total minus the number we have already found contiguously free).
    55                                  ;; current_disk[fs_fat32_cluster_count] = number of clusters in disk
    56                                  ;; (and thus the end point of our search).
    57                                  ;;
    58                                  ;; Other than that, we just need to advance our way linearly through the FAT sectors.
    59                                  ;; This is straight forward, as we can just read the first FAT sector, and then progress
    60                                  ;; our way through, until we reach the end.
    61                          
    62                                  ;; First, make sure we can see the sector buffer at $DE00-$DFFF
    63  9b7b 20cf9f                     jsr sd_map_sectorbuffer
    64                          
    65                                  ;; 1. Start at cluster 2
    66  9b7e a902                       lda #$02
    67  9b80 8d09bc                     sta dos_opendir_cluster+0
    68  9b83 8d18bf                     sta dos_file_loadaddress+0
    69  9b86 a900                       lda #$00
    70  9b88 8d0abc                     sta dos_opendir_cluster+1
    71  9b8b 8d0bbc                     sta dos_opendir_cluster+2
    72  9b8e 8d0cbc                     sta dos_opendir_cluster+3
    73  9b91 8d19bf                     sta dos_file_loadaddress+1
    74  9b94 8d1abf                     sta dos_file_loadaddress+2
    75  9b97 8d1bbf                     sta dos_file_loadaddress+3
    76                          
    77                          @tryNewStartingPointCandidate:
    78                          
    79                                  ;; Reset # of clusters still required
    80  9b9a a203                       ldx #$03
    81  9b9c bd61bc             @ll74:  lda dos_dirent_length, X
    82  9b9f 9d5dbc                     sta dos_dirent_cluster, X
    83  9ba2 ca                         dex
    84  9ba3 10f7                       bpl @ll74
    85                          
    86                          @testIfClusterEmptyAfterReadingFATSector:
    87                                  ;; Read the appropriate sector of the FAT
    88                                  ;; To do this, we copy the target cluster number to
    89                                  ;; dos_current_cluster, and call dos_cluster_to_fat_sector.
    90                                  ;; This leaves the absolute sector number in
    91                                  ;; dos_current_cluster.
    92  9ba5 a203                       ldx #$03
    93  9ba7 bd18bf             @ll78:  lda dos_file_loadaddress, X
    94  9baa 9db3bc                     sta dos_current_cluster, X
    95  9bad ca                         dex
    96  9bae 10f7                       bpl @ll78
    97  9bb0 200c98                     jsr dos_cluster_to_fat_sector
    98                                  ;; Now we have the sector # in dos_current_cluster
    99                                  ;; Copy to the SD card sector register, and do the read
   100  9bb3 a203                       ldx #$03
   101  9bb5 bdb3bc             @ll83:  lda dos_current_cluster, X
   102  9bb8 9d81d6                     sta $D681, X
   103  9bbb ca                         dex
   104  9bbc 10f7                       bpl @ll83
   105                          
   106                                  ;; Finally, do the read
   107  9bbe a920                       lda #dos_errorcode_read_error
   108  9bc0 8dfabc                     sta dos_error_code
   109  9bc3 20e49f                     jsr sd_readsector
   110                                  ;; XXX - Fail on error
   111  9bc6 b001                       bcs @ll93
   112  9bc8 60                         rts
   113                          @ll93:
   114                          
   115                          @testIfClusterEmpty:
   116                                  ;; Here we have the sector read, and do the test on the contents of the cluster
   117                                  ;; entry.
   118                          
   119                                  ;; But first, check that the cluster number is valid:
   120                                  ;; 1. Get dos_disk_table_offset pointing correctly
   121  9bc9 ae03bc                     ldx dos_disk_current_disk
   122  9bcc 207f92                     jsr dos_set_current_disk
   123  9bcf ae04bc                     ldx dos_disk_table_offset
   124                                  ;; 2. Compare cluster count to current cluster
   125  9bd2 a000                       ldy #$00
   126  9bd4 bd12bb             @ll128: lda dos_disk_table + fs_fat32_cluster_count + 0, X
   127  9bd7 d918bf                     cmp dos_file_loadaddress, Y
   128  9bda d00d                       bne @notLastClusterOfFileSystem
   129  9bdc e8                         inx
   130  9bdd c8                         iny
   131  9bde c004                       cpy #$04
   132  9be0 d0f2                       bne @ll128
   133                          
   134                                  ;; Return error due to lack of space
   135  9be2 a98c                       lda #dos_errorcode_no_space
   136  9be4 8dfabc                     sta dos_error_code
   137  9be7 18                         clc
   138  9be8 60                         rts
   139                          
   140                          @notLastClusterOfFileSystem:
   141                          
   142                                  ;; The offset in the sector is computed from the bottom
   143                                  ;; 7 bits of the cluster number * 4, to give an offset
   144                                  ;; in the 512 byte sector. Once we have the offset, OR the
   145                                  ;; four bytes of the cluster number together to test if = 0,
   146                                  ;; and thus empty.
   147  9be9 ad18bf                     lda dos_file_loadaddress+0
   148  9bec 0a                         asl
   149  9bed 0a                         asl
   150  9bee a8                         tay
   151  9bef ad18bf                     lda dos_file_loadaddress+0
   152  9bf2 2940                       and #$40
   153  9bf4 f00e                       beq @lowMoby
   154  9bf6 b900df                     lda $df00, y
   155  9bf9 1901df                     ora $df01, y
   156  9bfc 1902df                     ora $df02, y
   157  9bff 1903df                     ora $df03, y
   158  9c02 800c                       bra @ll120
   159                          @lowMoby:
   160  9c04 b900de                     lda $De00, y
   161  9c07 1901de                     ora $De01, y
   162  9c0a 1902de                     ora $de02, y
   163  9c0d 1903de                     ora $de03, y
   164                          @ll120:
   165                                  ;; Remember result of free-test
   166  9c10 aa                         tax
   167                          
   168                                  ;; Increment next cluster number we will look at
   169  9c11 ad18bf                     lda dos_file_loadaddress+0
   170  9c14 18                         clc
   171  9c15 6901                       adc #$01
   172  9c17 8d18bf                     sta dos_file_loadaddress+0
   173  9c1a ad19bf                     lda dos_file_loadaddress+1
   174  9c1d 6900                       adc #$00
   175  9c1f ad19bf                     lda dos_file_loadaddress+1
   176  9c22 ad1abf                     lda dos_file_loadaddress+2
   177  9c25 6900                       adc #$00
   178  9c27 ad1abf                     lda dos_file_loadaddress+2
   179  9c2a ad1bbf                     lda dos_file_loadaddress+3
   180  9c2d 6900                       adc #$00
   181  9c2f ad1bbf                     lda dos_file_loadaddress+3
   182                          
   183                                  ;; If the cluster was not free, then reset search point
   184  9c32 e000                       cpx #$00
   185  9c34 f00e                       beq @thisClusterWasFree
   186  9c36 a203                       ldx #$03
   187  9c38 bd18bf             @ll160: lda dos_file_loadaddress, X
   188  9c3b 9d09bc                     sta dos_opendir_cluster, X
   189  9c3e ca                         dex
   190  9c3f 10f7                       bpl @ll160
   191  9c41 4c9a9b                     jmp @tryNewStartingPointCandidate
   192                          
   193                          @thisClusterWasFree:
   194                                  ;; Decrement # of clusters still required
   195  9c44 ad5dbc                     lda dos_dirent_cluster+0
   196  9c47 38                         sec
   197  9c48 e901                       sbc #$01
   198  9c4a 8d5dbc                     sta dos_dirent_cluster+0
   199  9c4d ad5ebc                     lda dos_dirent_cluster+1
   200  9c50 e900                       sbc #$00
   201  9c52 8d5ebc                     sta dos_dirent_cluster+1
   202  9c55 ad5fbc                     lda dos_dirent_cluster+2
   203  9c58 e900                       sbc #$00
   204  9c5a 8d5fbc                     sta dos_dirent_cluster+2
   205  9c5d ad60bc                     lda dos_dirent_cluster+3
   206  9c60 e900                       sbc #$00
   207  9c62 8d60bc                     sta dos_dirent_cluster+3
   208                                  ;; Now see if zero
   209  9c65 0d5fbc                     ora dos_dirent_cluster+2
   210  9c68 0d5ebc                     ora dos_dirent_cluster+1
   211  9c6b 0d5dbc                     ora dos_dirent_cluster+0
   212  9c6e f00d                       beq @foundFreeSpace
   213                          
   214                                  ;; Nope, we still need more, so continue the search
   215                          
   216                                  ;; Then check if this next cluster is unallocated?
   217                                  ;; (If the cluster entry in the FAT will be in the same
   218                                  ;;  sector as the last, then don't waste time recomputing
   219                                  ;;  and reading the FAT sector number).
   220  9c70 ad18bf                     lda dos_file_loadaddress+0
   221  9c73 297f                       and #$7F
   222  9c75 d003                       bne @sameSector
   223  9c77 4ca59b                     jmp @testIfClusterEmptyAfterReadingFATSector
   224                          @sameSector:
   225  9c7a 4cc99b                     jmp @testIfClusterEmpty
   226                          
   227                          @foundFreeSpace:
   228                                  ;; Found the requested space
   229  9c7d 38                         sec
   230  9c7e 60                         rts

; ******** Source: src/hyppo/main.asm
   378                          
   379                          ;; /*  -------------------------------------------------------------------
   380                          ;;     Virtual memory and memory management
   381                          ;;     ---------------------------------------------------------------- */

; ******** Source: mem.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          ;; Display error and infinite loop on page fault
     7                          page_fault:
     8  9c7f 2056a2                     jsr reset_machine_state
     9  9c82 a2af                       ldx #<msg_pagefault
    10  9c84 a09c                       ldy #>msg_pagefault
    11  9c86 2074a8                     jsr printmessage
    12  9c89 a000                       ldy #$00
    13                                  ;; Print PC
    14  9c8b ab49d6                     ldz $d649
    15  9c8e 20eda8                     jsr printhex
    16  9c91 ab48d6                     ldz $d648
    17  9c94 20eda8                     jsr printhex
    18                                  ;; and MAPLO state
    19  9c97 ab4fd6                     ldz $d64f
    20  9c9a 20eda8                     jsr printhex
    21  9c9d ab4ad6                     ldz $d64a
    22  9ca0 20eda8                     jsr printhex
    23  9ca3 ab49d6                     ldz $d649
    24  9ca6 20eda8                     jsr printhex
    25                          
    26  9ca9 ee20d0             pf1:    inc $d020
    27  9cac 4ca99c                     jmp pf1
    28                          
    29                          msg_pagefault:
    30  9caf 5041474520464155...        !text "PAGE FAULT: PC=$$$$, MAP=$$.$$$$.00     "
    31                          
    32                          memory_trap:
    33  9cd7 78                         sei
    34  9cd8 d8                         cld
    35  9cd9 29fe                       and #$fe
    36  9cdb aa                         tax
    37  9cdc 7cdf9c                     jmp (memory_trap_table,x)
    38                          
    39                          memory_trap_table:
    40                                  ;; $00-$0E
    41  9cdf 679d                       !16 rom_writeprotect
    42  9ce1 5f9d                       !16 rom_writeenable
    43  9ce3 2f82                       !16 invalid_subfunction
    44  9ce5 2f82                       !16 invalid_subfunction
    45  9ce7 2f82                       !16 invalid_subfunction
    46  9ce9 2f82                       !16 invalid_subfunction
    47  9ceb 2f82                       !16 invalid_subfunction
    48  9ced 2f82                       !16 invalid_subfunction
    49                          
    50                                  ;; $10-$1E
    51  9cef 2f82                       !16 invalid_subfunction
    52  9cf1 2f82                       !16 invalid_subfunction
    53  9cf3 2f82                       !16 invalid_subfunction
    54  9cf5 2f82                       !16 invalid_subfunction
    55  9cf7 2f82                       !16 invalid_subfunction
    56  9cf9 2f82                       !16 invalid_subfunction
    57  9cfb 2f82                       !16 invalid_subfunction
    58  9cfd 2f82                       !16 invalid_subfunction
    59                          
    60                                  ;; $20-$2E
    61  9cff 2f82                       !16 invalid_subfunction
    62  9d01 2f82                       !16 invalid_subfunction
    63  9d03 2f82                       !16 invalid_subfunction
    64  9d05 2f82                       !16 invalid_subfunction
    65  9d07 2f82                       !16 invalid_subfunction
    66  9d09 2f82                       !16 invalid_subfunction
    67  9d0b 2f82                       !16 invalid_subfunction
    68  9d0d 2f82                       !16 invalid_subfunction
    69                          
    70                                  ;; $30-$3E
    71  9d0f 2f82                       !16 invalid_subfunction
    72  9d11 2f82                       !16 invalid_subfunction
    73  9d13 2f82                       !16 invalid_subfunction
    74  9d15 2f82                       !16 invalid_subfunction
    75  9d17 2f82                       !16 invalid_subfunction
    76  9d19 2f82                       !16 invalid_subfunction
    77  9d1b 2f82                       !16 invalid_subfunction
    78  9d1d 2f82                       !16 invalid_subfunction
    79                          
    80                                  ;; $40-$4E
    81  9d1f 2f82                       !16 invalid_subfunction
    82  9d21 2f82                       !16 invalid_subfunction
    83  9d23 2f82                       !16 invalid_subfunction
    84  9d25 2f82                       !16 invalid_subfunction
    85  9d27 2f82                       !16 invalid_subfunction
    86  9d29 2f82                       !16 invalid_subfunction
    87  9d2b 2f82                       !16 invalid_subfunction
    88  9d2d 2f82                       !16 invalid_subfunction
    89                          
    90                                  ;; $50-$5E
    91  9d2f 2f82                       !16 invalid_subfunction
    92  9d31 2f82                       !16 invalid_subfunction
    93  9d33 2f82                       !16 invalid_subfunction
    94  9d35 2f82                       !16 invalid_subfunction
    95  9d37 2f82                       !16 invalid_subfunction
    96  9d39 2f82                       !16 invalid_subfunction
    97  9d3b 2f82                       !16 invalid_subfunction
    98  9d3d 2f82                       !16 invalid_subfunction
    99                          
   100                                  ;; $60-$6E
   101  9d3f 2f82                       !16 invalid_subfunction
   102  9d41 2f82                       !16 invalid_subfunction
   103  9d43 2f82                       !16 invalid_subfunction
   104  9d45 2f82                       !16 invalid_subfunction
   105  9d47 2f82                       !16 invalid_subfunction
   106  9d49 2f82                       !16 invalid_subfunction
   107  9d4b 2f82                       !16 invalid_subfunction
   108  9d4d 2f82                       !16 invalid_subfunction
   109                          
   110                                  ;; $70-$7E
   111  9d4f 2f82                       !16 invalid_subfunction
   112  9d51 2f82                       !16 invalid_subfunction
   113  9d53 2f82                       !16 invalid_subfunction
   114  9d55 2f82                       !16 invalid_subfunction
   115  9d57 2f82                       !16 invalid_subfunction
   116  9d59 2f82                       !16 invalid_subfunction
   117  9d5b 2f82                       !16 invalid_subfunction
   118  9d5d 2f82                       !16 invalid_subfunction
   119                          
   120                          rom_writeenable:
   121  9d5f a904                       lda #$04
   122  9d61 1c7dd6                     trb hypervisor_feature_enables
   123  9d64 4c1082                     jmp return_from_trap_with_success
   124                          
   125                          rom_writeprotect:
   126  9d67 a904                       lda #$04
   127  9d69 0c7dd6                     tsb hypervisor_feature_enables
   128  9d6c 4c1082                     jmp return_from_trap_with_success
   129                          

; ******** Source: src/hyppo/main.asm
   383                          
   384                          ;; /*  -------------------------------------------------------------------
   385                          ;;     Task (process) management
   386                          ;;     ---------------------------------------------------------------- */

; ******** Source: task.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; Return the next free task ID
     7                                  ;; XXX - Task ID $FF is hypervisor/operating system
     8                                  ;; XXX - For now just lie, and always say task $00 is next.
     9                                  ;; We should have a process allocation table that we consult.
    10                                  ;; (actual suspended processes should be held on SD card in files)
    11                          
    12                          task_get_next_taskid:
    13                          
    14  9d6f a900                       lda #$00
    15  9d71 60                         rts
    16                          
    17                          ;;         ========================
    18                          
    19                          task_set_c64_memorymap:
    20                          
    21                                  ;; set contents of CPU registers for exit from hypervisor mode
    22                          
    23  9d72 a900                       lda #$00
    24  9d74 8d40d6                     sta hypervisor_a
    25  9d77 8d41d6                     sta hypervisor_x
    26  9d7a 8d42d6                     sta hypervisor_y
    27  9d7d 8d43d6                     sta hypervisor_z
    28  9d80 8d44d6                     sta hypervisor_b
    29  9d83 a9ff                       lda #$ff
    30  9d85 8d45d6                     sta hypervisor_spl
    31  9d88 a901                       lda #$01
    32  9d8a 8d46d6                     sta hypervisor_sph
    33  9d8d a9f7                       lda #$f7     ;; All flags except decimal mode
    34  9d8f 8d47d6                     sta hypervisor_flags
    35  9d92 a900                       lda #$00
    36  9d94 8d4ad6                     sta hypervisor_maplolo
    37  9d97 8d4bd6                     sta hypervisor_maplohi
    38  9d9a 8d4cd6                     sta hypervisor_maphilo
    39  9d9d 8d4dd6                     sta hypervisor_maphihi
    40  9da0 8d4ed6                     sta hypervisor_maplomb
    41  9da3 8d4fd6                     sta hypervisor_maphimb
    42  9da6 a93f                       lda #$3f
    43  9da8 8d50d6                     sta hypervisor_cpuport00
    44  9dab 8d51d6                     sta hypervisor_cpuport01
    45                          
    46  9dae a900                       lda #$00
    47  9db0 8d52d6                     sta hypervisor_iomode    ;; C64 IO map
    48                          
    49                                  ;; Unmap SD sector buffer
    50  9db3 a982                       lda #$82
    51  9db5 8d80d6                     sta $D680
    52                          
    53                                  ;; Unmap 2nd KB colour RAM
    54  9db8 a901                       lda #$01
    55  9dba 1c30d0                     trb $d030
    56                          
    57                          	;; Clear 16-bit text mode, but keep CRT emulation and horizontal filter settings
    58  9dbd a9d7               	lda #$d7
    59  9dbf 1c54d0                     trb $d054	
    60                          	
    61                                  ;; 40 column mode normal C64 screen
    62  9dc2 a900                       lda #$00
    63  9dc4 8d30d0                     sta $d030
    64  9dc7 8d31d0                     sta $d031
    65  9dca ad00dd                     lda $dd00
    66  9dcd 0903                       ora #$03
    67  9dcf 8d00dd                     sta $dd00
    68  9dd2 a9c0                       lda #$c0    ;; also enable raster delay to match rendering with interrupts more correctly
    69  9dd4 8d5dd0                     sta $d05d
    70  9dd7 a91b                       lda #$1b
    71  9dd9 8d11d0                     sta $d011
    72  9ddc a9c8                       lda #$c8
    73  9dde 8d16d0                     sta $d016
    74  9de1 a914                       lda #$14
    75  9de3 8d18d0                     sta $d018
    76                          
    77                                  ;; XXX - disable C65 ROM maps
    78  9de6 60                         rts
    79                          
    80                          ;;         ========================
    81                          
    82                          task_set_pc_to_reset_vector:
    83                          
    84                                  ;; Set PC from $FFFC in ROM, i.e., $802FFFC
    85  9de7 a2fc                       ldx #<reset_vector
    86  9de9 a0ff                       ldy #>reset_vector
    87  9deb a302                       ldz #$02
    88  9ded a900                       lda #$00
    89  9def 20f0a9                     jsr longpeek
    90  9df2 ad00bc                     lda hyppo_scratchbyte0
    91  9df5 8d48d6                     sta hypervisor_pcl
    92  9df8 a2fc                       ldx #<reset_vector
    93  9dfa e8                         inx
    94  9dfb a0ff                       ldy #>reset_vector
    95  9dfd a302                       ldz #$02
    96  9dff a900                       lda #$00
    97  9e01 20f0a9                     jsr longpeek
    98  9e04 ad00bc                     lda hyppo_scratchbyte0
    99  9e07 8d49d6                     sta hypervisor_pch
   100                          
   101  9e0a 60                         rts
   102                          
   103                          ;;         ========================
   104                          
   105                                  ;; Set dummy C64 NMI vector
   106                                  ;; This avoid a nasty crash if NMI is called during hyppo
   107                                  ;; Points to a RTI instruction in $FEC1
   108                          
   109                          task_dummy_nmi_vector:
   110                          
   111  9e0b a9c1                       lda #<$FEC1
   112  9e0d 8d1803                     sta $0318
   113  9e10 a9fe                       lda #>$FEC1
   114  9e12 8d1903                     sta $0319
   115  9e15 60                         rts
   116                          
   117                          ;;         ========================
   118                          
   119                                  ;; Set all page entries and current page number to all zeroes
   120                                  ;; so that we don't think any page is loaded.
   121                                  ;; XXX - Is all zeroes the best value here?  Physical page 0 is $00000000, which
   122                                  ;; is in chipram. It might be legitimate to try to map that.  Perhaps we should set
   123                                  ;; the pages to $FFFF instead (but that would reduce available VM space by 16KB).
   124                                  ;; Physical page 0 is probably reasonable for now. We can revisit as required.
   125                          
   126                          task_clear_pagetable:
   127                          
   128  9e16 a900                       lda #$00
   129  9e18 a25d                       ldx #<hypervisor_vm_currentpage_lo
   130  9e1a 9d00d6             tcp1:   sta $d600,x
   131  9e1d e8                         inx
   132  9e1e e070                       cpx #<hypervisor_vm_pagetable3_physicalpage_hi+1
   133  9e20 d0f8                       bne tcp1
   134  9e22 60                         rts
   135                          
   136                          ;;         ========================
   137                          
   138                          task_erase_processcontrolblock:
   139                          
   140                                  ;; Erase process control block
   141                                  ;;
   142  9e23 a200                       ldx #$00
   143  9e25 8a                         txa
   144  9e26 9d00bd             tabs1:        sta currenttask_block,x
   145  9e29 e8                         inx
   146  9e2a d0fa                       bne tabs1
   147  9e2c 20169e                     jsr task_clear_pagetable
   148                          
   149                                  ;; Mark all files as closed
   150                          
   151  9e2f 4cce8f                     jmp dos_clear_filedescriptors
   152                          
   153                          ;;         ========================
   154                          
   155                          task_new_processcontrolblock:
   156                          
   157  9e32 20239e                     jsr task_erase_processcontrolblock
   158  9e35 206f9d                     jsr task_get_next_taskid
   159  9e38 8d00bd                     sta currenttask_id
   160  9e3b 60                         rts
   161                          
   162                          ;;         ========================
   163                          
   164                                  ;; Initialise memory to indicate a new blank task.
   165                                  ;; (actually, it will be a task preconfigured for C64/C65 mode)
   166                          
   167                          task_asblankslate:
   168                          
   169  9e3c 20329e                     jsr task_new_processcontrolblock
   170                          
   171  9e3f 20729d                     jsr task_set_c64_memorymap
   172  9e42 60                         rts
   173                          
   174                          ;;         ========================
   175                          
   176                          unstable_illegal_opcode_trap:
   177                          kill_opcode_trap:
   178                          	;; For now, just launch the freezer if an illegal opcode is hit that
   179                          	;; we can't work with.
   180                          	;; (Ideally later we will allow some clever tricks with at least the KIL
   181                          	;; opcodes, e.g., to call the hypervisor from C64 mode)
   182                          
   183                          	;; FALL THROUGH
   184                          	
   185                          restore_press_trap:
   186                          
   187                                  ;; Clear colour RAM at $DC00 flag, as it causes no end of trouble
   188  9e43 a901                       lda #$01
   189  9e45 1c30d0                     trb $D030
   190                          	;; and DMA audio
   191  9e48 a900               	lda #$00
   192  9e4a 8d11d7             	sta $d711
   193                          
   194                                  ;; Freeze to slot 0
   195  9e4d aa                 	tax ;;   <- uses $00 in A from above
   196  9e4e a8                 	tay ;;   <- uses $00 in A from above
   197  9e4f 205286                     jsr freeze_to_slot
   198                          
   199                                  ;; Load freeze program
   200  9e52 2047a5                     jsr attempt_loadcharrom
   201  9e55 2061a5                     jsr attempt_loadc65rom
   202                          
   203  9e58 a2c3                       ldx #<txt_FREEZER
   204  9e5a a0b2                       ldy #>txt_FREEZER
   205  9e5c 205699                     jsr dos_setname
   206                          
   207                                  ;; Prepare 32-bit pointer for loading freezer program ($000007FF)
   208                                  ;; (i.e. $0801 - 2 byte header, so we can use a normal PRG file)
   209                                  ;;
   210  9e5f a900                       lda #$00
   211  9e61 851a                       sta <dos_file_loadaddress+2
   212  9e63 851b                       sta <dos_file_loadaddress+3
   213  9e65 a907                       lda #$07
   214  9e67 8519                       sta <dos_file_loadaddress+1
   215  9e69 a9ff                       lda #$ff
   216  9e6b 8518                       sta <dos_file_loadaddress+0
   217                          
   218                          @tryAgain:
   219  9e6d 205198                     jsr dos_readfileintomemory
   220  9e70 ee20d0                     inc $d020
   221  9e73 90f8                       bcc @tryAgain
   222  9e75 ce20d0                     dec $d020
   223                          
   224  9e78 20729d                     jsr task_set_c64_memorymap
   225  9e7b 200b9e                     jsr task_dummy_nmi_vector
   226                          
   227                                  ;; set entry point and memory config
   228  9e7e a90d                       lda #<2061
   229  9e80 8d48d6                     sta hypervisor_pcl
   230  9e83 a908                       lda #>2061
   231  9e85 8d49d6                     sta hypervisor_pch
   232                          
   233                                  ;; Make $FFD2 vector at $0326 point to an RTS, so that if the freezer
   234                                  ;; is built using CC65's C64 profile, the call to $FFD2 to set lower-case mode
   235                                  ;; doesn't do something terrible.
   236  9e88 a9ff                       lda #<$03FF
   237  9e8a 8d2603                     sta $0326
   238  9e8d a903                       lda #>$03FF
   239  9e8f 8d2703                     sta $0327
   240  9e92 a960                       lda #$60 ;; = RTS
   241  9e94 8dff03                     sta $03FF
   242                          
   243                                  ;; Similarly neuter IRQ/BRK and NMI vectors, in part because the call to $FFD2 above
   244                                  ;; will do a CLI, and thus any pending IRQ will immediately trigger, and since the freezer
   245                                  ;; is running without the kernal initialising things, it would otherwise use the IRQ
   246                                  ;; vector from whatever was being frozen.  Clearly this is a bad thing.
   247  9e97 a9fc                       lda #<$03FC
   248  9e99 8d1403                     sta $0314
   249  9e9c 8d1603                     sta $0316
   250  9e9f 8d1803                     sta $0318
   251  9ea2 a903                       lda #>$03FC
   252  9ea4 8d1503                     sta $0315
   253  9ea7 8d1703                     sta $0317
   254  9eaa 8d1903                     sta $0319
   255  9ead a94c                       lda #$4C   ;; JMP $EA81
   256  9eaf 8dfc03                     sta $03FC
   257  9eb2 a981                       lda #<$EA81
   258  9eb4 8dfd03                     sta $03FD
   259  9eb7 a9ea                       lda #>$EA81
   260  9eb9 8dfe03                     sta $03FE
   261                          
   262                                  ;; Disable IRQ/NMI sources
   263  9ebc a97f                       lda #$7f
   264  9ebe 8d0ddc                     sta $DC0D
   265  9ec1 8d0ddd                     sta $DD0D
   266  9ec4 a900                       lda #$00
   267  9ec6 8d1ad0                     sta $D01A
   268                          
   269                                  ;; return from hypervisor, causing freeze menu to start
   270                                  ;;
   271  9ec9 8d7fd6                     sta hypervisor_enterexit_trigger
   272                          
   273                          ;;         ========================
   274                          
   275                          protected_hardware_config:
   276                          
   277                                  ;; store config info passed from register a
   278  9ecc ad40d6                     lda hypervisor_a
   279  9ecf 8d72d6                     sta hypervisor_secure_mode_flags
   280                          
   281                                  ;; bump border colour so that we know something has happened
   282                                  ;;
   283                          
   284  9ed2 8d7fd6                     sta hypervisor_enterexit_trigger
   285                          
   286                          ;;         ========================
   287                          
   288                          matrix_mode_toggle:
   289                          
   290  9ed5 ad72d6                     lda hypervisor_secure_mode_flags
   291                                  ;; We want to toggle bit 6 only.
   292  9ed8 4940                       eor #$40
   293  9eda 8d72d6                     sta hypervisor_secure_mode_flags
   294                          
   295  9edd 8d7fd6                     sta hypervisor_enterexit_trigger

; ******** Source: src/hyppo/main.asm
   388                          
   389                          ;; /*  -------------------------------------------------------------------
   390                          ;;     Secure mode / compartmentalised operation management
   391                          ;;     ---------------------------------------------------------------- */

; ******** Source: securemode.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          securemode_trap:
     7                          
     8                                  ;; XXX - The following is what we SHOULD do for the complete system to work:
     9                                  ;; XXX Freeze current process to slot
    10                                  ;; XXX Find the requested service
    11                                  ;; XXX Load the requested service
    12                          
    13                                  ;; Set secure mode flag, and set PC and memory map in the secure service
    14                          
    15                                  ;; XXX - What we WILL do for now, is just enable secure mode, and set the PC to
    16                                  ;; $8000.
    17                          
    18                                  ;; First, disable access to cartridge, force 50MHz mode and 4502 CPU personality
    19  9ee0 a932                       lda #$32
    20  9ee2 8d7dd6                     sta hypervisor_feature_enables
    21                          
    22                                  ;; Second, disable all protecteed IO access, and mark matrix mode and secure mode.
    23                                  ;; This also freezes the CPU until the monitor acknowledges that the CPU is in
    24                                  ;; secure mode.  Only after that will the remainder of this routine proceed,
    25                                  ;; and thus allow the secure program to run.
    26                                  ;; XXX - This means that a little piece of the hypervisor is still running when we
    27                                  ;; go into the secure compartment.  For this reason, the CPU needs to be blocked
    28                                  ;; from writing to hypervisor_secure_mode_flags when in that state.
    29  9ee5 a9c0                       lda #$c0
    30  9ee7 8d72d6                     sta hypervisor_secure_mode_flags
    31                          
    32                          
    33                                  ;; At this point, the monitor detects that we have asked for secure mode, and will
    34                                  ;; ask for the user to either accept or reject.  If they accept, the CPU will be
    35                                  ;; resumed into the loaded service.  If not, all memory will be erased, before the
    36                                  ;; CPU is resumed.  For now, a rejected action will just require a reboot. But
    37                                  ;; later, we will have the monitor tell the hypervisor by synthesising an appropriate
    38                                  ;; trap after wiping memory, presumbly by causing a write to a $D65x register.
    39  9eea 4c0082                     jmp nosuchtrap
    40                          
    41                          
    42                          leave_securemode_trap:
    43                          
    44                                  ;; If we get here, we have left a secure compartment, with either memory erased
    45                                  ;; or intact.  Either way, we should hand control back to the user, and disable
    46                                  ;; matrix mode display.
    47                          
    48                                  ;; XXX - Debug
    49  9eed ee21d0                     inc $d021
    50                          
    51  9ef0 a900                       lda #$00
    52  9ef2 8d72d6                     sta hypervisor_secure_mode_flags
    53                          
    54  9ef5 4c0082                     jmp nosuchtrap

; ******** Source: src/hyppo/main.asm
   393                          
   394                          ;; /*  -------------------------------------------------------------------
   395                          ;;     SD-Card and FAT related functions
   396                          ;;     ---------------------------------------------------------------- */

; ******** Source: sdfat.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          
     5                          ;;     These routines provide support for FAT32 and SDCARD support.
     6                          ;;     ---------------------------------------------------------------- */
     7                          
     8                          ;; /*  -------------------------------------------------------------------
     9                          ;;     FAT file system routines
    10                          ;;     ---------------------------------------------------------------- */
    11                          toupper:
    12                                  ;; convert ASCII character to upper case
    13                                  ;;
    14                                  ;; INPUT:  .A is the ASCII char to convert up uppercase
    15                                  ;; OUTPUT: .A will hold the resulting uppersace
    16  9ef8 c961                       cmp #$61  ; #$60 = ` char (just before lower-case 'a')
    17  9efa 9006                       bcc tu1   ; branch if < #$60
    18  9efc c97b                       cmp #$7b  ; #$7a = 'z' char
    19  9efe b002                       bcs tu1   ; branch if > #$7a
    20  9f00 295f                       and #$5f  ; 's' = %01110011 & %01011111 = 'S' = %01010011
    21  9f02 60                 tu1:    rts
    22                          
    23                          ;; /*  -------------------------------------------------------------------
    24                          ;;     MBP / partition routines
    25                          
    26                          ;;     Read master boot record. Does not sanity check anything.
    27                          ;;     ---------------------------------------------------------------- */
    28                          readmbr:
    29                                  ;; begin by resetting SD card
    30                                  ;;
    31                          
    32                                  +Checkpoint "Resetting SDCARD"
    33                          
    34  9f03 207b9f                     jsr sd_resetsequence
    35  9f06 b001                       bcs l7
    36                                  +Checkpoint "FAILED resetting SDCARD"
    37                          
    38  9f08 60                         rts
    39                          
    40                          l7:     ;; MBR is sector 0
    41                                  ;;
    42  9f09 a900                       lda #$00
    43  9f0b 8d81d6                     sta sd_address_byte0 ;; is $D681
    44  9f0e 8d82d6                     sta sd_address_byte1 ;; is $d682
    45  9f11 8d83d6                     sta sd_address_byte2 ;; is $d683
    46  9f14 8d84d6                     sta sd_address_byte3 ;; is $d684
    47                          
    48                                  ;; Work out if SD card or SDHC card
    49                                  ;; SD cards only read on 512 byte aligned addresses.
    50                                  ;; SDHC addresses by sector, so all addresses are valid
    51                          
    52                                  ;; Clear SDHC flag to begin with (flag persists through reset)
    53  9f17 a940                       lda #$40
    54  9f19 8d80d6                     sta $d680
    55                          
    56                                  ;; Attempt non-aligned read
    57  9f1c a902                       lda #$02
    58  9f1e 8d81d6                     sta sd_address_byte0
    59  9f21 8d80d6                     sta $d680
    60                          
    61                          sdhccheckwait:
    62  9f24 20b39f                     jsr sdreadytest
    63  9f27 b017                       bcs issdhc
    64  9f29 d0f9                       bne sdhccheckwait
    65                          
    66                                  ;; Normal SD (SDSC) card
    67                          
    68  9f2b a900                       lda #$00
    69  9f2d 8d81d6                     sta sd_address_byte0
    70                          
    71                                  ;; Reset after SDHC test for normal SD mode
    72  9f30 207b9f                     jsr sd_resetsequence
    73                          
    74                                  ;; XXX - We no longer support standard SD cards, so
    75                                  ;; we display an error and infinite loop.
    76                          
    77  9f33 a2cf                       ldx #<msg_foundsdcard
    78  9f35 a0ae                       ldy #>msg_foundsdcard
    79  9f37 2074a8                     jsr printmessage
    80                          
    81                          @unsupportedcard:
    82  9f3a ee20d0                     inc $D020
    83  9f3d 4c3a9f                     jmp @unsupportedcard
    84                          
    85                          issdhc:
    86  9f40 a2f2                       ldx #<msg_foundsdhccard
    87  9f42 a0ae                       ldy #>msg_foundsdhccard
    88  9f44 2074a8                     jsr printmessage
    89                          
    90                                  ;; set SDHC flag
    91  9f47 a941                       lda #$41
    92  9f49 8d80d6                     sta $d680
    93                          
    94  9f4c 4ce49f                     jmp sd_readsector
    95                          
    96                          ;; /*  -------------------------------------------------------------------
    97                          ;;     SD Card access routines
    98                          ;;     ---------------------------------------------------------------- */
    99                          
   100                          sd_open_write_gate:	
   101  9f4f a957               	lda #$57
   102  9f51 8d80d6             	sta $d680
   103  9f54 60                 	rts
   104                          
   105                          write_non_mbr_sector:
   106  9f55 204f9f             	jsr sd_open_write_gate
   107  9f58 4c609f             	jmp write_sector_trigger
   108                          write_mbr_sector:
   109  9f5b a94d               	lda #$4D
   110  9f5d 8d80d6             	sta $d680
   111                          write_sector_trigger:	
   112  9f60 a903               	lda #$03
   113  9f62 8d80d6             	sta $d680
   114  9f65 60                 	rts
   115                          	
   116                          
   117                          sd_wait_for_ready:
   118  9f66 20a59f                     jsr sdtimeoutreset
   119  9f69 20b39f             @loop:  jsr sdreadytest
   120  9f6c 90fb                       bcc @loop
   121  9f6e 60                         rts
   122                          
   123                          sd_wait_for_ready_reset_if_required:
   124                                  ;; Wait until the SD card is ready. If it doesn't get ready,
   125                                  ;; then continuously reset it until it does become ready.
   126  9f6f 20669f                     jsr sd_wait_for_ready
   127  9f72 b006                       bcs @isReady
   128  9f74 207b9f                     jsr sd_resetsequence
   129  9f77 4c6f9f                     jmp sd_wait_for_ready_reset_if_required
   130                          @isReady:
   131  9f7a 60                         rts
   132                          
   133                          sd_resetsequence:
   134                                  ;; write $00 to $D680 to start reset
   135                                  ;;
   136                          
   137                                  ;; Assert and release reset
   138  9f7b a900                       lda #$00
   139  9f7d 8d80d6                     sta $D680
   140  9f80 a901                       lda #$01
   141  9f82 8d80d6                     sta $D680
   142                          
   143                                  ;; Wait for SD card to become ready
   144  9f85 20669f             re2:    jsr sd_wait_for_ready
   145  9f88 b003                       bcs re2done        ;; success, so return
   146  9f8a d0f9                       bne re2                ;; not timed out, so keep trying
   147  9f8c 60                         rts                ;; timeout, so return
   148                          
   149                          re2done:
   150  9f8d 20cf9f                     jsr sd_map_sectorbuffer
   151                          
   152                          redone:
   153  9f90 38                         sec
   154  9f91 60                         rts
   155                          
   156                          ;;         ========================
   157                          
   158                                  ;; Watch for ethernet packets while waiting for the SD card.
   159                                  ;; this allows loading of code into the hypervisor for testing and
   160                                  ;; bare-metal operation.
   161                                  ;;
   162                          sdwaitawhile:
   163  9f92 20a59f                     jsr sdtimeoutreset
   164                          
   165  9f95 ee1cbf             sw1:    inc sdcounter+0
   166  9f98 d0fb                       bne sw1
   167  9f9a ee1dbf                     inc sdcounter+1
   168  9f9d d0f6                       bne sw1
   169  9f9f ee1ebf                     inc sdcounter+2
   170  9fa2 d0f1                       bne sw1
   171  9fa4 60                         rts
   172                          
   173                          ;;         ========================
   174                          
   175                          sdtimeoutreset:
   176                                  ;; count to timeout value when trying to read from SD card
   177                                  ;; (if it is too short, the SD card won't reset)
   178                                  ;;
   179  9fa5 a900                       lda #$00
   180  9fa7 8d1cbf                     sta sdcounter+0
   181  9faa 8d1dbf                     sta sdcounter+1
   182  9fad a9f3                       lda #$f3
   183  9faf 8d1ebf                     sta sdcounter+2
   184  9fb2 60                         rts
   185                          
   186                          ;;         ========================
   187                          
   188                          sdreadytest:
   189                                  ;; check if SD card is ready, or if timeout has occurred
   190                                  ;; C is set if ready.
   191                                  ;; Z is set if timeout has occurred.
   192                                  ;;
   193  9fb3 ad80d6                     lda $d680
   194  9fb6 2903                       and #$03
   195  9fb8 f013                       beq sdisready
   196  9fba ee1cbf                     inc sdcounter+0
   197  9fbd d00c                       bne sr1
   198  9fbf ee1dbf                     inc sdcounter+1
   199  9fc2 d007                       bne sr1
   200  9fc4 ee1ebf                     inc sdcounter+2
   201  9fc7 d002                       bne sr1
   202                          
   203                                  ;; timeout
   204                                  ;;
   205  9fc9 a900                       lda #$00 ;; set Z
   206                          
   207  9fcb 18                 sr1:    clc
   208  9fcc 60                         rts
   209                          
   210                          sdisready:
   211  9fcd 38                         sec
   212  9fce 60                         rts
   213                          
   214                          ;;         ========================
   215                          
   216                          sd_map_sectorbuffer:
   217                          
   218                                  ;; BG this clobbers .A, maybe we should protect .A as the UNMAP-function does? (see below)
   219                          
   220                                  ;; Clear colour RAM at $DC00 flag, as this prevents mapping of sector buffer at $DE00
   221  9fcf a901                       lda #$01
   222  9fd1 1c30d0                     trb $D030
   223                          
   224                                  ;; Actually map the sector buffer
   225  9fd4 a981                       lda #$81
   226  9fd6 8d80d6                     sta $D680
   227  9fd9 38                         sec
   228  9fda 60                         rts
   229                          
   230                          ;;         ========================
   231                          
   232                          sd_unmap_sectorbuffer:
   233                          
   234  9fdb 48                         pha
   235  9fdc a982                       lda #$82
   236  9fde 8d80d6                     sta $D680
   237  9fe1 68                         pla
   238  9fe2 38                         sec
   239  9fe3 60                         rts
   240                          
   241                          
   242                          ;;         ========================
   243                          
   244                          ;; /*  -------------------------------------------------------------------
   245                          ;;     Below function is self-contained
   246                          ;;     ---------------------------------------------------------------- */
   247                          
   248                          sd_readsector:
   249                                  ;; Assumes fixed sector number (or byte address in case of SD cards)
   250                                  ;; is loaded into $D681 - $D684
   251                          
   252                          !if DEBUG_HYPPO {
   253                                  ;; print out debug info
   254                                  ;;
   255                          ;;         jsr printsectoraddress        ; to screen
   256                                  jsr dumpsectoraddress        ;; checkpoint message
   257                          }
   258                          
   259                                  ;; check if sd card is busy
   260                                  ;;
   261  9fe4 ad80d6                     lda $d680
   262  9fe7 2901                       and #$01
   263  9fe9 d032                       bne rsbusyfail
   264                          
   265                                  ;;
   266  9feb 4c04a0                     jmp rs4                ;; skipping the redoread-delay below
   267                          
   268                          ;;         ========================
   269                          
   270                          redoread:
   271                                  ;; redo-read delay
   272                                  ;;
   273                                  ;; when retrying, introduce a delay.  This seems to be needed often
   274                                  ;; when reading the first sector after SD card reset.
   275                                  ;;
   276                                  ;; print out a debug message to indicate RE-reading (ie previous read failed)
   277                                  ;;
   278  9fee a227                       ldx #<msg_sdredoread
   279  9ff0 a0af                       ldy #>msg_sdredoread
   280  9ff2 2074a8                     jsr printmessage
   281                          
   282                                  +Checkpoint "ERROR redoread:"
   283                          
   284  9ff5 a2f0                       ldx #$f0
   285  9ff7 a000                       ldy #$00
   286  9ff9 a300                       ldz #$00
   287  9ffb 1b                 r1:     inz
   288  9ffc d0fd                       bne r1
   289  9ffe c8                         iny
   290  9fff d0fa                       bne r1
   291  a001 e8                         inx
   292  a002 d0f7                       bne r1
   293                          
   294                          rs4:
   295                                  ;; ask for sector to be read
   296                                  ;;
   297  a004 a902                       lda #$02
   298  a006 8d80d6                     sta $d680
   299                          
   300                                  ;; wait for sector to be read
   301                                  ;;
   302  a009 20a59f                     jsr sdtimeoutreset
   303                          rs3:
   304  a00c 20b39f                     jsr sdreadytest
   305  a00f b004                       bcs rsread        ;; yes, sdcard is ready
   306  a011 d0f9                       bne rs3                ;; not ready, so check if ready now?
   307  a013 f002                       beq rereadsector        ;; Z was set, ie timeout
   308                          rsread:
   309  a015 38                         sec
   310  a016 60                         rts
   311                          
   312                          ;;         ========================
   313                          
   314                          rereadsector:
   315                                  ;; reset sd card and try again
   316                                  ;;
   317                          
   318                                  +Checkpoint "ERROR rereadsector:"
   319                          
   320  a017 207b9f                     jsr sd_resetsequence
   321  a01a 4c04a0                     jmp rs4
   322                          
   323                          rsbusyfail:     ;; fail
   324                                  ;;
   325  a01d a907                       lda #dos_errorcode_read_timeout
   326  a01f 8dfabc                     sta dos_error_code
   327                                  +Checkpoint "ERROR rsbusyfail:"
   328                          
   329  a022 18                         clc
   330  a023 60                         rts
   331                          
   332                          ;; /*  -------------------------------------------------------------------
   333                          ;;     Above function is self-contained
   334                          ;;     ---------------------------------------------------------------- */
   335                          
   336                          sd_inc_sectornumber:
   337                          
   338                                  ;; PGS 20190225 - SD SC card support deprecated. Only SD HC supported.
   339                          
   340                                  ;; SDHC card mode: add 1
   341                                  ;;
   342                          
   343  a024 ee81d6                     inc sd_address_byte0
   344  a027 d00d                       bne s1
   345  a029 ee82d6                     inc sd_address_byte1
   346  a02c d008                       bne s1
   347  a02e ee83d6                     inc sd_address_byte2
   348  a031 d003                       bne s1
   349  a033 ee84d6                     inc sd_address_byte3
   350  a036 60                 s1:     rts
   351                          
   352                          ;;         ========================

; ******** Source: src/hyppo/main.asm
   398                          
   399                          ;; /*  -------------------------------------------------------------------
   400                          ;;     Virtualised F011 access (used for disk over serial monitor)
   401                          ;;     ---------------------------------------------------------------- */

; ******** Source: virtual_f011.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          f011_virtual_read:
     7                          
     8                                  ;; Reset buffer pointers and stop SD card from reading
     9                                  ;; from card and overwriting what we load
    10  a037 a901                       lda #$01
    11  a039 8d81d0                     sta $D081
    12                          
    13  a03c a980                       lda #$80
    14  a03e 0c86d0                     tsb $D086
    15                          
    16                                  ;; We write the job details to the uart monitor interface.
    17                                  ;; Assume uart monitor interface is at 2mbits = 20 cycles
    18                                  ;; per char, so we need to add a short delay between each char
    19  a041 ad84d0                     lda $d084
    20  a044 0980                       ora #$80
    21  a046 8d7cd6                     sta $d67C
    22                          
    23  a049 2074a0                     jsr wait5usec
    24  a04c ad85d0                     lda $d085
    25  a04f 0980                       ora #$80
    26  a051 8d7cd6                     sta $D67C
    27                          
    28  a054 2074a0                     jsr wait5usec
    29  a057 ad86d0                     lda $D086
    30  a05a 0980                       ora #$80
    31  a05c 8d7cd6                     sta $D67C
    32                          
    33  a05f 2074a0                     jsr wait5usec
    34  a062 a921                       lda #$21
    35  a064 8d7cd6                     sta $D67C
    36                          
    37                                  ;; Wait for monitor_load to clear bit 7 of side register to indicate that
    38                                  ;; it has done the job
    39  a067 ad86d0             fvr3:   lda $d086
    40  a06a 30fb                       bmi fvr3
    41                          
    42                          fvr_same_as_last_time:
    43                                  ;; Set floppy flags as appropriate to look like FDC has just successfully read a
    44                                  ;; sector
    45  a06c a935                       lda #$35
    46  a06e 8dafd6                     sta f011_flag_stomp
    47                          
    48  a071 8d7fd6                     sta hypervisor_enterexit_trigger
    49                          
    50                          wait5usec:
    51                                  ;; 40MHz = 40 cycles / usec, so we need 200 cycles
    52                                  ;; JSR/RTS is ~10 cycles
    53                                  ;; 64 iterations of 3 cycles = ~192 cycles
    54                                  ;; so should be about right
    55  a074 a240                       ldx #$40
    56  a076 ca                 -       dex
    57  a077 d0fd                       bne -
    58  a079 60                         rts
    59                          
    60                          f011_virtual_write:
    61                          
    62                                  ;; Reset buffer pointers and stop SD card from reading
    63                                  ;; from card and overwriting what we load
    64  a07a a901                       lda #$01
    65  a07c 8d81d0                     sta $D081
    66                          
    67  a07f a940                       lda #$40
    68  a081 0c86d0                     tsb $D086
    69                          
    70                                  ;; We write the job details to the uart monitor interface.
    71                                  ;; Assume uart monitor interface is at 2mbits = 20 cycles
    72                                  ;; per char, so we need to add a short delay between each char
    73  a084 ad84d0                     lda $d084
    74  a087 0980                       ora #$80
    75  a089 8d7cd6                     sta $d67C
    76                          
    77  a08c 2074a0                     jsr wait5usec
    78  a08f ad85d0                     lda $d085
    79  a092 0980                       ora #$80
    80  a094 8d7cd6                     sta $D67C
    81                          
    82  a097 2074a0                     jsr wait5usec
    83  a09a ad86d0                     lda $D086
    84  a09d 0980                       ora #$80
    85  a09f 8d7cd6                     sta $D67C
    86                          
    87  a0a2 2074a0                     jsr wait5usec
    88  a0a5 a95c                       lda #$5C
    89  a0a7 8d7cd6                     sta $D67C
    90                          
    91  a0aa ad86d0             fvw1:   lda $d086
    92  a0ad 29c0                       and #$c0
    93  a0af d0f9                       bne fvw1
    94                          
    95  a0b1 a916                       lda #$16
    96  a0b3 8dafd6                     sta f011_flag_stomp
    97                          
    98                                  ;; Return from hypervisor
    99                                  ;;
   100  a0b6 8d7fd6             fvw2:   sta hypervisor_enterexit_trigger
   101                          

; ******** Source: src/hyppo/main.asm
   403                          
   404                          ;; /*  -------------------------------------------------------------------
   405                          ;;     Audio mixer control functions
   406                          ;;     ---------------------------------------------------------------- */

; ******** Source: audiomix.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          audiomix_setup:
     6                          
     7                                  ;; Set all audio mixer coefficients to silent by default
     8  a0b9 a200                       ldx #$00
     9  a0bb 8a                         txa 
    10                          aml1:
    11  a0bc 207aa1                     jsr audiomix_setcoefficient
    12  a0bf e8                         inx
    13  a0c0 d0fa                       bne aml1
    14                          
    15                                  ;; Set master volume to max for L & R channels on M65R2 audio jack
    16  a0c2 a9ff                       lda #$ff
    17  a0c4 a2fe                       ldx #$fe
    18  a0c6 2095a1                     jsr audiomix_set2coefficients
    19  a0c9 a2de                       ldx #$de
    20  a0cb 2095a1                     jsr audiomix_set2coefficients
    21                          	;; And also for speaker / HDMI audio outputs
    22                          	;; Now we have a fun problem: Internal speakers need it MUCH louder than HDMI
    23                          	;; and we wouldn't be able to set the two independently.
    24  a0ce a9ff               	lda #$ff
    25  a0d0 a21e                       ldx #$1e
    26  a0d2 2095a1                     jsr audiomix_set2coefficients
    27  a0d5 a23e                       ldx #$3e
    28  a0d7 2095a1                     jsr audiomix_set2coefficients
    29                          
    30  a0da 2066a1                     jsr audio_set_stereo
    31                          
    32                          	;; Set OPL / FM / SFX / Adlib volume to max on all channels
    33  a0dd a90c               	lda #$0c
    34                          fmvolloop:
    35  a0df aa                 	tax
    36  a0e0 a9ff               	lda #$ff
    37  a0e2 2095a1             	jsr audiomix_set2coefficients
    38  a0e5 8a                 	txa
    39  a0e6 18                 	clc
    40  a0e7 6920               	adc #$20
    41  a0e9 90f4               	bcc fmvolloop
    42                          	
    43                          
    44                          audio_set_mono:
    45                                  ;; Left and right SID volume levels
    46                                  ;; for stereo operation
    47  a0eb a9be                       lda #$be
    48  a0ed a2c0                       ldx #$c0
    49  a0ef 208da1                     jsr audiomix_set4coefficients
    50  a0f2 a2d0                       ldx #$d0
    51  a0f4 208da1                     jsr audiomix_set4coefficients
    52  a0f7 a2f0                       ldx #$f0
    53  a0f9 208da1                     jsr audiomix_set4coefficients
    54  a0fc a2e0                       ldx #$e0
    55  a0fe 208da1                     jsr audiomix_set4coefficients
    56  a101 a200                       ldx #$00
    57  a103 208da1                     jsr audiomix_set4coefficients
    58  a106 a210                       ldx #$10
    59  a108 208da1                     jsr audiomix_set4coefficients
    60  a10b a220                       ldx #$20
    61  a10d 208da1                     jsr audiomix_set4coefficients
    62  a110 a230                       ldx #$30
    63  a112 208da1                     jsr audiomix_set4coefficients
    64  a115 60                         rts
    65                          
    66                          audiomix_set_sid_lr_coefficients:
    67  a116 a2c0                       ldx #$c0
    68  a118 2095a1                     jsr audiomix_set2coefficients
    69  a11b a2d0                       ldx #$d0
    70  a11d 2095a1                     jsr audiomix_set2coefficients
    71  a120 a2e2                       ldx #$e2
    72  a122 2095a1                     jsr audiomix_set2coefficients
    73  a125 a2f2                       ldx #$f2
    74  a127 2095a1                     jsr audiomix_set2coefficients
    75  a12a a200                       ldx #$00
    76  a12c 2095a1                     jsr audiomix_set2coefficients
    77  a12f a210                       ldx #$10
    78  a131 2095a1                     jsr audiomix_set2coefficients
    79  a134 a222                       ldx #$22
    80  a136 2095a1                     jsr audiomix_set2coefficients
    81  a139 a232                       ldx #$32
    82  a13b 4c95a1                     jmp audiomix_set2coefficients
    83                          
    84                          audiomix_set_sid_rl_coefficients:	
    85  a13e a2c2                       ldx #$c2
    86  a140 2095a1                     jsr audiomix_set2coefficients
    87  a143 a2d2                       ldx #$d2
    88  a145 2095a1                     jsr audiomix_set2coefficients
    89  a148 a2e0                       ldx #$e0
    90  a14a 2095a1                     jsr audiomix_set2coefficients
    91  a14d a2f0                       ldx #$f0
    92  a14f 2095a1                     jsr audiomix_set2coefficients
    93  a152 a202                       ldx #$02
    94  a154 2095a1                     jsr audiomix_set2coefficients
    95  a157 a212                       ldx #$12
    96  a159 2095a1                     jsr audiomix_set2coefficients
    97  a15c a220                       ldx #$20
    98  a15e 2095a1                     jsr audiomix_set2coefficients
    99  a161 a230                       ldx #$30
   100  a163 4c95a1                     jmp audiomix_set2coefficients        	
   101                          	
   102                          audio_set_stereo:
   103                                  ;; Left and right SID volume levels
   104                                  ;; for stereo operation
   105  a166 a9be                       lda #$be
   106  a168 2016a1             	jsr audiomix_set_sid_lr_coefficients
   107  a16b a940                       lda #$40
   108  a16d 4c3ea1             	jmp audiomix_set_sid_rl_coefficients
   109                          
   110                          audio_set_stereomirrored:
   111                                  ;; Left and right SID volume levels
   112                                  ;; for stereo operation
   113  a170 a940                       lda #$40
   114  a172 2016a1             	jsr audiomix_set_sid_lr_coefficients
   115  a175 a9be                       lda #$be
   116  a177 4c3ea1             	jmp audiomix_set_sid_rl_coefficients
   117                          
   118                          audiomix_setcoefficient:
   119  a17a 8ef4d6                     stx audiomix_addr
   120                          
   121                                  ;; wait 17 cycles before writing (16 + start of read instruction)
   122                                  ;; to give time to audio mixer to fetch the 16-bit coefficient, before
   123                                  ;; we write to half of it (which requires the other half loaded, so that the
   124                                  ;; write to the 16-bit register gets the correct other half).
   125                                  ;; note that bit $1234 gets replaced in hyppo by monitor_load when doing
   126                                  ;; hot-patching, so we can't use that instruction for the delay
   127                          
   128                                  ;; simple solution: write to address register several times to spend the time.
   129                                  ;; 16 cycles here. then the sta of the data gives us 3 more cycles, so we are fine.
   130  a17d 8ef4d6                     stx audiomix_addr
   131  a180 8ef4d6                     stx audiomix_addr
   132  a183 8ef4d6                     stx audiomix_addr
   133  a186 8ef4d6                     stx audiomix_addr
   134                          
   135                                  ;; update coefficient
   136  a189 8df5d6                     sta audiomix_data
   137  a18c 60                         rts
   138                          
   139                          audiomix_set4coefficients:
   140  a18d 207aa1                     jsr audiomix_setcoefficient
   141  a190 e8                         inx
   142  a191 207aa1                     jsr audiomix_setcoefficient
   143  a194 e8                         inx
   144                          audiomix_set2coefficients:
   145  a195 207aa1                     jsr audiomix_setcoefficient
   146  a198 e8                         inx
   147  a199 4c7aa1                     jmp audiomix_setcoefficient

; ******** Source: src/hyppo/main.asm
   408                          
   409                          ;; /*  -------------------------------------------------------------------
   410                          ;;     Target-specific register setup
   411                          ;;     ---------------------------------------------------------------- */

; ******** Source: targetsetup.asm
     1                                  ;; Setup functions for MEGAphone.
     2                                  ;; Basically setup the I2C IO expanders with sensible values, turning
     3                                  ;; all peripherals on.
     4                          
     5                          targetspecific_setup:
     6                          
     7                          	;; Setup common I2C area 32-bit pointer
     8  a19c a900                       lda #<$7000
     9  a19e 8d10bf                     sta zptempv32+0
    10  a1a1 a970                       lda #>$7000
    11  a1a3 8d11bf                     sta zptempv32+1
    12  a1a6 a9fd                       lda #<$0FFD
    13  a1a8 8d12bf                     sta zptempv32+2
    14  a1ab a90f                       lda #>$0FFD
    15  a1ad 8d13bf                     sta zptempv32+3
    16                          	
    17                          	;; Apply I2C settings based on target ID
    18  a1b0 ad29d6             	lda $d629
    19  a1b3 c903               	cmp #$03
    20  a1b5 f00a               	beq mega65r3_i2c_setup
    21  a1b7 ad29d6             	lda $d629
    22  a1ba 29e0               	and #$e0
    23  a1bc c920               	cmp #$20
    24  a1be f02b               	beq megaphone_i2c_setup
    25  a1c0 60                 	rts
    26                          	
    27                          mega65r3_i2c_setup:	
    28                          
    29  a1c1 a971                       lda #>$7100
    30  a1c3 8d11bf                     sta zptempv32+1
    31  a1c6 a900                       lda #$00
    32  a1c8 8d20d0                     sta $d020
    33  a1cb a000                       ldy #$00
    34                          
    35                          mps3_loop:
    36  a1cd b93ca2                     lda mega65r3_i2c_settings,y
    37  a1d0 c9ff                       cmp #$ff
    38  a1d2 d003                       bne +
    39  a1d4 a300                       ldz #$00
    40                          
    41  a1d6 60                         rts
    42                          +
    43  a1d7 4b                         taz
    44  a1d8 c8                         iny
    45  a1d9 b93ca2                     lda mega65r3_i2c_settings,y
    46  a1dc c8                         iny
    47                          
    48                          
    49                                  ;; Keep writing it until it gets written
    50                          -
    51  a1dd ea9210              	sta [<zptempv32],z
    52                          
    53  a1e0 ee20d0             	inc $d020	
    54  a1e3 ead210                     cmp [<zptempv32],z
    55  a1e6 d0f5                       bne -
    56                          
    57  a1e8 4ccda1                     jmp mps3_loop
    58                          	
    59                          megaphone_i2c_setup:
    60                          
    61                                  ;; Start with backscreen very dim, to avoid inrush current
    62                                  ;; causing FGPA power rail to sag.
    63  a1eb a901                       lda #$01
    64  a1ed 8df0d6                     sta $d6f0
    65                          	
    66  a1f0 a900                       lda #$00
    67  a1f2 8d20d0                     sta $d020
    68  a1f5 a000                       ldy #$00
    69                          mps_loop:
    70  a1f7 b91aa2                     lda megaphone_i2c_settings,y
    71  a1fa c9ff                       cmp #$ff
    72  a1fc d008                       bne +
    73  a1fe a300                       ldz #$00
    74                          
    75                                  ;; Set full brightness on LCD on exit
    76  a200 a9ff                       lda #$ff
    77  a202 8df0d6                     sta $d6f0
    78                          
    79  a205 60                         rts
    80                          +
    81  a206 4b                         taz
    82  a207 c8                         iny
    83  a208 b91aa2                     lda megaphone_i2c_settings,y
    84  a20b c8                         iny
    85                          
    86                          
    87                                  ;; Keep writing it until it gets written
    88                          -
    89  a20c ea9210                     sta [<zptempv32],z
    90                          
    91                                  ;; Wait for I2C register to get written
    92                          
    93  a20f ee20d0                     inc $d020
    94                          
    95  a212 ead210                     cmp [<zptempv32],z
    96  a215 d0f5                       bne -
    97                          
    98                          
    99  a217 4cf7a1                     jmp mps_loop
   100                          
   101                          
   102                          megaphone_i2c_settings:
   103                                  ;; LCD panel
   104  a21a 1640                       !8 $16,$40 ;; Port 0 to output, except LCD backlight line, that we now control via an FPGA pin
   105  a21c 1700                       !8 $17,$00 ;; Port 1 to output
   106  a21e 12bf                       !8 $12,$bf ;; Enable power to all sub-systems ($BF = $FF - $40)
   107  a220 1320                       !8 $13,$20 ;; Power up headphones amplifier
   108                          
   109                                  ;; Speaker amplifier configuration
   110  a222 35ff                       !8 $35,$FF   ;; Left volume initial mute
   111  a224 36ff                       !8 $36,$FF   ;; Right volume initial mute
   112  a226 3020                       !8 $30,$20
   113  a228 3100                       !8 $31,$00
   114  a22a 3202                       !8 $32,$02
   115  a22c 3300                       !8 $33,$00
   116  a22e 3410                       !8 $34,$10
   117  a230 3780                       !8 $37,$80
   118  a232 380c                       !8 $38,$0C
   119  a234 3999                       !8 $39,$99
   120  a236 3560                       !8 $35,$60   ;; Left volume set ($FF = mute, $40 = full volume)
   121  a238 3660                       !8 $36,$60   ;; Right volume set ($FF = mute, $40 = full volume)
   122                          
   123                          
   124  a23a ffff                       !8 $FF,$FF ;; End of list marker
   125                          
   126                          mega65r3_i2c_settings:	
   127                                  ;; Speaker amplifier configuration
   128  a23c e1ff                       !8 $e1,$FF   ;; Left volume initial mute
   129  a23e e2ff                       !8 $e2,$FF   ;; Right volume initial mute
   130  a240 dc20                       !8 $dc,$20
   131  a242 dd00                       !8 $dd,$00
   132  a244 de02                       !8 $de,$02
   133  a246 df00                       !8 $df,$00
   134  a248 e010                       !8 $e0,$10
   135  a24a e380                       !8 $e3,$80
   136  a24c e40c                       !8 $e4,$0C
   137  a24e e599                       !8 $e5,$99
   138  a250 e120                       !8 $e1,$20   ;; Left volume set ($FF = mute, $40 = full volume, $00 = +24dB)
   139  a252 e220                       !8 $e2,$20   ;; Right volume set ($FF = mute, $40 = full volume, $00 = +24dB)
   140                          
   141                          
   142  a254 ffff                       !8 $FF,$FF ;; End of list marker

; ******** Source: src/hyppo/main.asm
   413                          
   414                          ;; /*  -------------------------------------------------------------------
   415                          ;;     CPU Hypervisor Entry Point on reset
   416                          ;;     ---------------------------------------------------------------- */
   417                          
   418                          reset_machine_state:
   419                                  ;; get CPU state sensible
   420  a256 78                         sei
   421  a257 d8                         cld
   422  a258 03                         see
   423                          
   424                                  ;; ;; Disable reset watchdog (this happens simply by writing anything to
   425                                  ;; ;; this register)
   426                                  ;; ;; Enable /EXROM and /GAME from cartridge port (bit 0)
   427                                  ;; ;; enable flat 32-bit addressing (bit 1)
   428                                  ;; ;; do not engage ROM write protect (yet) (bit 2)
   429                                  ;; ;; do make ASC/DIN / CAPS LOCK control CPU speed (bit 3)
   430                                  ;; ;; do not force CPU to full speed (bit 4)
   431                                  ;; ;; also force 4502 CPU personality (6502 personality is still incomplete) (bit 5)
   432                                  ;; ;; and clear any pending IRQ or NMI event (bit 6)
   433                                  ;; ;;
   434                                  ;; ;; (The watchdog was added to catch reset problems where the machine
   435                                  ;; ;; would run off somewhere odd instead of resetting properly. Now it
   436                                  ;; ;; will auto-reset after 65535 cycles if the watchdog is not cleared).
   437                                  ;; ;;
   438                          
   439  a259 a96b                       lda #$6b    ;; 01101011
   440  a25b 8d7dd6                     sta hypervisor_feature_enables
   441                          
   442                          	;; Enable cartridge /EXROM and /GAME lines in CPU addressing
   443  a25e a902               	lda #$02
   444  a260 0cfbd7             	tsb $d7fb
   445                          	
   446                          	;; /EXROM and /GAME follow cartridge port
   447  a263 a93f                       lda #$3f
   448  a265 8dfdd7                     sta $d7fd
   449                          
   450  a268 20b9a0                     jsr audiomix_setup
   451                                  ;; enable audio amplifier
   452  a26b a901                       lda #$01
   453  a26d 8dfed6                     sta audioamp_ctl
   454                          
   455                                  ;; Return keyboard LEDs to automatic control
   456  a270 a900               	lda #$00
   457  a272 8d1dd6             	sta $d61d
   458                          	;; Disable VIC-IV debug modes
   459  a275 8d66d0             	sta $d066
   460                                  ;; Clear system partition present flag
   461  a278 8dfcbc                     sta syspart_present
   462                                  ;; disable IRQ/NMI sources
   463  a27b 8d1ad0                     sta $D01A
   464  a27e a97f                       lda #$7f
   465  a280 8d7fd0             	sta $d07f   		; Hide VIC-IV cross-hairs
   466  a283 8d0ddc                     sta $DC0D
   467  a286 8d0ddd                     sta $DD0D
   468                          
   469  a289 38                         sec
   470                                  ;; determine VIC mode and set it accordingly in VICIV_MAGIC
   471  a28a 2070aa                     jsr enhanced_io
   472                          
   473                                  ;; clear UART interrupt status
   474  a28d ad06d6                     lda uart65_irq_flag
   475                          
   476                                  ;; switch to fast mode
   477                                  ;; 1. C65 fast-mode enable, and disable extended attributes
   478  a290 a940               	lda #$40
   479  a292 8d31d0                     sta $d031
   480                                  ;; 2. MEGA65 48MHz enable (requires C65 or C128 fast mode to truly enable, hence the above)
   481  a295 a9c5                       lda #$c5
   482  a297 0c54d0                     tsb $d054
   483                          
   484                                  ;; Setup I2C peripherals on the MEGAphone platform
   485  a29a 209ca1                     jsr targetspecific_setup
   486                          
   487                                  ;; sprites off, and normal mode, 256-colour char data from chipram
   488  a29d a900                       lda #$00
   489  a29f 8d15d0                     sta $d015
   490  a2a2 8d63d0             	sta $d063
   491  a2a5 8d55d0                     sta $d055
   492  a2a8 8d6bd0                     sta $d06b
   493  a2ab 8d57d0                     sta $d057
   494  a2ae a9f0                       lda #$f0
   495  a2b0 aa                 	tax
   496  a2b1 1c49d0             	trb $d049
   497  a2b4 8a                 	txa
   498  a2b5 1c4bd0             	trb $d04b
   499  a2b8 8a                 	txa
   500  a2b9 1c4dd0             	trb $d04d
   501  a2bc 8a                 	txa
   502  a2bd 1c4fd0             	trb $d04f
   503                          
   504                                  ;; We DO NOT need to mess with $01, because
   505                                  ;; the 4510 starts up with hyppo mapped at $8000-$BFFF
   506                                  ;; enhanced ($FFD3xxx) IO page mapped at $D000,
   507                                  ;; and fast RAM elsewhere.
   508                          
   509                                  ;; Map SD card sector buffer to SD card, not floppy drive
   510  a2c0 a980                       lda #$80
   511  a2c2 8d89d6                     sta sd_buffer_ctrl
   512                          
   513                                  ;; Access cartridge IO area to force EXROM probe on R1 PCBs
   514                                  ;; XXX DONT READ $DExx ! This is a known crash causer for Action Replay
   515                                  ;; cartridges.  $DF00 should be okay, however.
   516                                  ;; XXX $DFxx can also be a problem for other cartridges, so we shouldn't do either.
   517                                  ;; this will mean cartridges don't work on the R1 PCB, but as that is no longer being
   518                                  ;; developed for, we can just ignore that now, and not touch anything.
   519                                  ;;lda $df00
   520                          
   521  a2c5 207fa6                     jsr resetdisplay
   522  a2c8 20caa7                     jsr erasescreen
   523  a2cb 20e5a6                     jsr resetpalette
   524                          
   525                                  ;; note that this first message does not get displayed correctly
   526                                  +Checkpoint "reset_machine_state"
   527                                  ;; but this second message does
   528                                  +Checkpoint "reset_machine_state"
   529                          
   530  a2ce 60                         rts
   531                          
   532                          ;; /*  -------------------------------------------------------------------
   533                          ;;     CPU Hypervisor reset/trap routines
   534                          ;;     ---------------------------------------------------------------- */
   535                          reset_entry:
   536  a2cf 78                         sei
   537                          
   538                           	;; Put ZP and stack back where they belong
   539  a2d0 a9bf               	lda #$bf
   540  a2d2 5b                 	tab
   541  a2d3 a0be               	ldy #$be
   542  a2d5 2b                 	tys
   543  a2d6 a2ff               	ldx #$ff
   544  a2d8 9a                 	txs
   545                          
   546                          	;; Clear mapping of lower memory area
   547  a2d9 a200               	ldx #$00
   548  a2db a900               	lda #$00
   549  a2dd a000               	ldy #$00
   550  a2df a33f               	ldz #$3f
   551  a2e1 5c                 	map
   552  a2e2 ea                 	eom
   553                          
   554                          !if DEBUG_HYPPO {
   555                                  !src "debugtests.asm"
   556                          }
   557                          
   558  a2e3 2056a2                     jsr reset_machine_state
   559                          
   560                                  ;; display welcome screen
   561                                  ;;
   562  a2e6 a2ed                       ldx #<msg_hyppo
   563  a2e8 a0ad                       ldy #>msg_hyppo
   564  a2ea 2074a8                     jsr printmessage
   565                          
   566                                  ;; leave a blank line below hyppo banner
   567                                  ;;
   568  a2ed a277                       ldx #<msg_blankline
   569  a2ef a0b2                       ldy #>msg_blankline
   570  a2f1 2074a8                     jsr printmessage
   571                          
   572                                  ;; Display GIT commit
   573                                  ;;
   574  a2f4 a258                       ldx #<msg_gitcommit
   575  a2f6 a0b2                       ldy #>msg_gitcommit
   576  a2f8 2074a8                     jsr printmessage
   577                          
   578                                  ;; Magic instruction used by monitor_load to work out where
   579                                  ;; to patch. Monitor_load changes bit to JMP when patching for
   580                                  ;; SD-cardless operation
   581  a2fb 2c14a9                     bit go64
   582  a2fe 2c3412                     bit $1234
   583                          	
   584                                  ;; Display help text
   585  a301 ad19a3             	lda first_boot_flag_instruction
   586  a304 c94c               	cmp #$4c
   587  a306 f00a               	beq not_first_boot_message
   588  a308 a20d                       ldx #<msg_hyppohelpfirst
   589  a30a a0ae                       ldy #>msg_hyppohelpfirst
   590  a30c 2074a8                     jsr printmessage
   591  a30f 4c19a3             	jmp first_boot_flag_instruction
   592                          	
   593                          not_first_boot_message:	
   594  a312 a233                       ldx #<msg_hyppohelpnotfirst
   595  a314 a0ae                       ldy #>msg_hyppohelpnotfirst
   596  a316 2074a8                     jsr printmessage
   597                          	
   598                          	;; Work out if we are on first reset.  If so, then try switching to bitstream in 2nd slot.
   599                          
   600                          first_boot_flag_instruction:
   601                          try_flash_menu:	
   602                          	
   603                          	;; Use first boot code path only once
   604                          	;; WARNING: Self modifying code!
   605  a319 2c77a3             	bit dont_launch_flash_menu
   606                          
   607                          	;; On first boot, we start the flash menu regardless
   608                          	;; (The flash menu will work out whether to switch bitstream or not)
   609  a31c 4c30a3             	jmp launch_flash_menu
   610                          	
   611                          	;; On ALT or either joystick button, enter flash menu.
   612                          	;; But only on first boot, while flash menu program can still be relied upon to be in memory.
   613  a31f ad10d6             	lda $d610
   614  a322 c909               	cmp #$09
   615  a324 f00a               	beq launch_flash_menu
   616  a326 ad00dc             	lda $dc00
   617  a329 2d01dc             	and $dc01
   618  a32c 2910               	and #$10
   619  a32e d047               	bne dont_launch_flash_menu
   620                          	
   621                          launch_flash_menu:
   622                          
   623                          	;; Disable digital audio when launching flash menu
   624  a330 2033ab             	jsr safe_video_mode
   625                          	
   626                          	;; Store where the flash menu should jump to if it doesn't need to do anything.
   627  a333 a940               	lda #<return_from_flashmenu
   628  a335 8d80cf             	sta $cf80
   629  a338 a9a3               	lda #>return_from_flashmenu
   630  a33a 8d81cf             	sta $cf81
   631                          	;; Then actually start it.
   632                          	;; NOTE: Flash menu runs in hypervisor mode, so can't use memory beyond $7FFF etc.
   633                          
   634  a33d 4c1bac             	jmp flash_menu
   635                          
   636                          return_from_flashmenu:	
   637                          
   638                          	;; Here we have been given control back from the flash menu program.
   639                          	;; So we have to put some things back to continue the kickstart boot process.
   640                          
   641                          	;; Put ZP and stack back where they belong
   642  a340 a9bf               	lda #$bf
   643  a342 5b                 	tab
   644  a343 a0be               	ldy #$be
   645  a345 2b                 	tys
   646  a346 a2ff               	ldx #$ff
   647  a348 9a                 	txs
   648                          	
   649  a349 a9ff                       lda #$ff
   650  a34b 8d02d7                     sta $d702
   651  a34e a9ff                       lda #$ff
   652  a350 8d04d7                     sta $d704  ;; dma list is in top MB of address space
   653                          
   654                          	;; Don't forget to reset colour RAM also
   655  a353 a901               	lda #$01
   656  a355 0c30d0             	tsb $d030
   657  a358 a9a8                       lda #>erasescreendmalist
   658  a35a 8d01d7                     sta $d701
   659                                  ;; set bottom 8 bits of address and trigger DMA.
   660                                  ;;
   661  a35d a959                       lda #<erasescreendmalist
   662  a35f 8d05d7                     sta $d705
   663  a362 a901               	lda #$01
   664  a364 1c30d0             	trb $d030
   665                          	
   666                          	;; And finally, the screen data
   667  a367 a9ac                       lda #>screenrestore_dmalist
   668  a369 8d01d7                     sta $d701
   669                                  ;; Trigger enhanced DMA
   670  a36c a99e                       lda #<screenrestore_dmalist
   671  a36e 8d05d7                     sta $d705
   672                          
   673  a371 207fa6             	jsr resetdisplay
   674                          		
   675  a374 4c77a3             	jmp dont_launch_flash_menu
   676                          	
   677                          dont_launch_flash_menu:
   678  a377 ad10d6             	lda ascii_key_in
   679  a37a c909               	cmp #$09
   680  a37c d00d               	bne fpga_has_been_reconfigured
   681                          
   682                          	;; Tell user what to do if they can't access the flash menu
   683                          noflash_menu:
   684  a37e a2b0                       ldx #<msg_noflashmenu
   685  a380 a0ad                       ldy #>msg_noflashmenu
   686  a382 2074a8                     jsr printmessage
   687  a385 ee20d0             	inc $d020
   688                          nfm1:
   689  a388 4c88a3             	jmp nfm1
   690                          	
   691                          
   692                          fpga_has_been_reconfigured:	
   693                          
   694                          	;; We can't trust that the flash menu is still in memory by this point, so do nothing.
   695                          	;; (This also means if you choose "safe mode" factory bitstream, and then reset, it
   696                          	;; won't try to run upgraded bitstream again.)
   697                          	
   698                                  ;; wait 0.1 msec for things to settle after power-up
   699  a38b 20929f                     jsr sdwaitawhile
   700                          
   701                                  ;; check keyboard for 0-9 down to select alternate rom
   702                                  ;;
   703  a38e 20baaa                     jsr keyboardread
   704                          
   705                          ;;         ========================
   706                          
   707                          normalboot:
   708                          
   709                          !if DEBUG_HYPPO {
   710                                  jsr dump_disk_count        ;; debugging to Checkpoint
   711                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
   712                          }
   713                          
   714                                  ;; Try to read the MBR from the SD card to ensure SD card is happy
   715                                  ;;
   716  a391 a2b0                       ldx #<msg_tryingsdcard
   717  a393 a0ae                       ldy #>msg_tryingsdcard
   718  a395 2074a8                     jsr printmessage
   719                          
   720                                  ;; Work out if we are using primary or secondard SD card
   721                          
   722                                  ;; First try resetting card 1 (external)
   723                          	;; so that if you have an external card, it will be used in preference
   724  a398 a9c1                       lda #$c1
   725  a39a 8d80d6                     sta $d680
   726  a39d a900                       lda #$00
   727  a39f 8d80d6                     sta $d680
   728  a3a2 a901                       lda #$01
   729  a3a4 8d80d6                     sta $d680
   730                          
   731  a3a7 a203                       ldx #$03
   732                          morewaiting:
   733  a3a9 20929f                     jsr sdwaitawhile
   734                          
   735  a3ac ad80d6                     lda $d680
   736  a3af 2903                       and #$03
   737  a3b1 d00c                       bne trybus0
   738                          
   739  a3b3 da                         phx
   740                          
   741  a3b4 a221                       ldx #<msg_usingcard1
   742  a3b6 a0b2                       ldy #>msg_usingcard1
   743  a3b8 2074a8                     jsr printmessage
   744                          
   745  a3bb fa                         plx
   746                          
   747  a3bc 4ceca3                     jmp tryreadmbr
   748                          trybus0:
   749  a3bf ca                         dex
   750  a3c0 d0e7                       bne morewaiting
   751                          
   752  a3c2 a9c0                       lda #$c0
   753  a3c4 8d80d6                     sta $d680
   754                          
   755  a3c7 a20d                       ldx #<msg_tryingcard0
   756  a3c9 a0b2                       ldy #>msg_tryingcard0
   757  a3cb 2074a8                     jsr printmessage
   758                          
   759                                  ;; Try resetting card 0
   760  a3ce a900                       lda #$00
   761  a3d0 8d80d6                     sta $d680
   762  a3d3 a901                       lda #$01
   763  a3d5 8d80d6                     sta $d680
   764                          
   765  a3d8 20929f                     jsr sdwaitawhile
   766                          
   767  a3db ad80d6                     lda $d680
   768  a3de 2903                       and #$03
   769  a3e0 f00a                       beq tryreadmbr
   770                          
   771                                  ;; No working SD card -- we can just try booting to BASIC, since we
   772                                  ;; now include our open-source ROM
   773  a3e2 a239                       ldx #<msg_nosdcard
   774  a3e4 a0af                       ldy #>msg_nosdcard
   775  a3e6 2074a8                     jsr printmessage
   776  a3e9 4c14a9                     jmp go64
   777                          
   778                          tryreadmbr:
   779  a3ec 20039f                     jsr readmbr
   780  a3ef b01b                       bcs gotmbr
   781                          
   782                                  ;; check for keyboard input to jump to utility menu
   783  a3f1 208eaa                     jsr scankeyboard
   784  a3f4 b007                       bcs nokey2
   785  a3f6 c920                       cmp #$20
   786  a3f8 d003                       bne nokey2
   787  a3fa 4c3eab                     jmp utility_menu
   788                          nokey2:
   789                          
   790                                  ;; Oops, cant read MBR
   791                                  ;; display debug message to screen
   792                                  ;;
   793  a3fd a2d7                       ldx #<msg_retryreadmbr
   794  a3ff a0ad                       ldy #>msg_retryreadmbr
   795  a401 2074a8                     jsr printmessage
   796                          
   797                                  ;; put sd card sector buffer back after scanning
   798                                  ;; keyboard
   799  a404 a981                       lda #$81
   800  a406 0c80d6                     tsb sd_ctrl
   801                          
   802                                  ;; display debug message to uart
   803                                  ;;
   804                                  +Checkpoint "re-try reading MBR of sdcard"
   805                          
   806  a409 4ceca3                     jmp tryreadmbr
   807                          
   808                          ;;         ========================
   809                          
   810                          gotmbr:
   811                                  ;; good, was able to read the MBR
   812                          
   813                                  ;; Scan SD card for partitions and mount them.
   814                                  ;;
   815  a40c 204c93                     jsr dos_clearall
   816  a40f 20ea8f                     jsr dos_read_partitiontable
   817                          
   818                                  ;; then print out some useful information
   819                                  ;;
   820  a412 a2be                       ldx #<msg_diskcount
   821  a414 a0af                       ldy #>msg_diskcount
   822  a416 2074a8                     jsr printmessage
   823                                  ;;
   824  a419 a000                       ldy #$00
   825  a41b ab01bc                     ldz dos_disk_count
   826  a41e 20eda8                     jsr printhex
   827                                  ;;
   828  a421 a000                       ldy #$00
   829  a423 ab02bc                     ldz dos_default_disk
   830  a426 20eda8                     jsr printhex
   831                          
   832                          !if DEBUG_HYPPO {
   833                                  jsr dump_disk_count     ;; debugging to Checkpoint
   834                                  jsr dumpcurrentfd       ;; debugging to Checkpoint
   835                          ;;             jsr print_disk_table        ; debugging to Screen
   836                          }
   837                          
   838                          ;;         ========================
   839                          
   840                                  ;; If we have no disks, offer the utility menu
   841  a429 ad01bc                     lda dos_disk_count
   842  a42c d003                       bne @thereIsADisk
   843  a42e 4c3eab                     jmp utility_menu
   844                          @thereIsADisk:
   845                          
   846                                  ;; Go to root directory on default disk
   847                                  ;;
   848  a431 ae02bc                     ldx dos_default_disk
   849  a434 209a92                     jsr dos_cdroot
   850  a437 b00f                       bcs mountsystemdiskok
   851                          
   852                                  ;; failed
   853                                  ;;
   854  a439 a2ed                       ldx #<msg_cdrootfailed
   855  a43b a0b1                       ldy #>msg_cdrootfailed
   856  a43d 2074a8                     jsr printmessage
   857  a440 a000                       ldy #$00
   858  a442 abfabc                     ldz dos_error_code
   859  a445 20eda8                     jsr printhex
   860                          
   861                                  +Checkpoint "FAILED CDROOT"
   862                                  ;;
   863                                  ;; BG: should probably JMP to reset or something, and not fall through
   864                          
   865                          
   866                          mountsystemdiskok:
   867                          
   868                                  ;; Load and display boot logo
   869                                  ;; Prepare 32-bit pointer for loading boot logo @ $0057D00
   870                                  ;; (palette is $57D00-$57FFF, logo $58000-$5CFFF)
   871  a448 a900                       lda #$00
   872  a44a 8518                       sta <dos_file_loadaddress+0
   873  a44c a97d                       lda #$7d
   874  a44e 8519                       sta <dos_file_loadaddress+1
   875  a450 a905                       lda #$05
   876  a452 851a                       sta <dos_file_loadaddress+2
   877  a454 a900                       lda #$00
   878  a456 851b                       sta <dos_file_loadaddress+3
   879                          
   880  a458 a2b8                       ldx #<txt_BOOTLOGOM65
   881  a45a a0b2                       ldy #>txt_BOOTLOGOM65
   882  a45c 205699                     jsr dos_setname
   883                          
   884                                  ;; print debug message
   885                                  ;;
   886                                  +Checkpoint "  try-loading BOOTLOGO"
   887                          
   888  a45f 205198                     jsr dos_readfileintomemory
   889  a462 b00f                       bcs logook
   890                          
   891                          ;;         ========================
   892                          
   893                                  ;; FAILED: print debug message
   894                                  ;;
   895                                  +Checkpoint "  FAILED-loading BOOTLOGO"
   896                          
   897                                  ;; print debug message
   898                                  ;;
   899  a464 a2c8                       ldx #<msg_nologo
   900  a466 a0b1                       ldy #>msg_nologo
   901  a468 2074a8                     jsr printmessage
   902  a46b a000                       ldy #$00
   903  a46d abfabc                     ldz dos_error_code
   904  a470 20eda8                     jsr printhex
   905                          
   906                                  +Checkpoint "FAILED loading BOOTLOGO"
   907                          
   908                          ;;         ========================
   909                          
   910                          logook:
   911                                  ;; Loaded banner, so copy palette into place
   912  a473 202ea8                     jsr setbannerpalette
   913                          
   914                                  ;; iterate through directory entries looking for ordinary file
   915                                  ;; HICKUP.M65 to load into hypervisor memory ...
   916                                  ;; ... but only if we are not running a hick-up'd hyppo now.
   917                                  ;;
   918  a476 ad7ed6                     lda hypervisor_hickedup_flag        ;; $d67e = register for hickup-state (00=virgin, else already-hicked)
   919  a479 100a                       bpl allowhickup
   920                          
   921                                  ;; already hicked
   922                                  ;;
   923  a47b a28e                       ldx #<msg_alreadyhicked
   924  a47d a0b1                       ldy #>msg_alreadyhicked
   925  a47f 2074a8                     jsr printmessage
   926                          
   927  a482 4cf4a4                     jmp posthickup
   928                          
   929                          ;;         ========================
   930                          
   931                          allowhickup:        ;; BG was label nextdirectoryentry3:
   932                          
   933                                  ;; Prepare 32-bit pointer for loading hickup @ $0004000
   934                                  ;;
   935                                  ;; We load it at $4000, which is mapped to first 64KB RAM, and then
   936                                  ;; have a routine also in RAM that we use to copy the loaded data
   937                                  ;; back onto the Hyppo "ROM" space, so that there are no problems
   938                                  ;; with the copying code being changed while it being replaced.
   939                                  ;;
   940  a485 a900                       lda #$00
   941  a487 8518                       sta <dos_file_loadaddress+0
   942  a489 a940                       lda #$40
   943  a48b 8519                       sta <dos_file_loadaddress+1
   944  a48d a900                       lda #$00
   945  a48f 851a                       sta <dos_file_loadaddress+2
   946  a491 a900                       lda #$00
   947  a493 851b                       sta <dos_file_loadaddress+3
   948                          
   949  a495 a2ad                       ldx #<txt_HICKUPM65
   950  a497 a0b2                       ldy #>txt_HICKUPM65
   951  a499 205699                     jsr dos_setname
   952                          
   953                                  ;; print debug message
   954                                  ;;
   955                                  +Checkpoint "  try-loading HICKUP"
   956                          
   957  a49c 205198                     jsr dos_readfileintomemory
   958  a49f 9053                       bcc nohickup
   959                          
   960                          ;;         ========================
   961                          
   962                                  ;; We have loaded a hickup file, so jump into it.
   963                          
   964                                  ;; print debug message
   965                                  ;;
   966                                  +Checkpoint "  loaded OK HICKUP"
   967                          
   968                          ;;                 ldx #<msg_hickuploaded
   969                          ;;                 ldy #>msg_hickuploaded
   970                          ;;                 jsr printmessage
   971                          
   972  a4a1 a000                       ldy #$00
   973  a4a3 ab1300                     ldz <zptempv32+3        ;; BG what is in this register? Where is the data set?
   974  a4a6 20eda8                     jsr printhex
   975  a4a9 ab1200                     ldz <zptempv32+2
   976  a4ac 20eda8                     jsr printhex
   977  a4af ab1100                     ldz <zptempv32+1
   978  a4b2 20eda8                     jsr printhex
   979  a4b5 ab1000                     ldz <zptempv32+0
   980  a4b8 20eda8                     jsr printhex
   981                          
   982                          dohickup:
   983                                  ;; Use DMAgic to copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
   984                                  ;; (We have to copy the routine to do this to RAM, since we will
   985                                  ;; be replacing ourselves)
   986  a4bb a200                       ldx #$00
   987  a4bd bdc9a4             krc:        lda hickuproutine,x
   988  a4c0 9d0030                     sta $3000,x
   989  a4c3 e8                         inx
   990  a4c4 d0f7                       bne krc
   991  a4c6 4c0030                     jmp $3000
   992                          
   993                          ;;         ========================
   994                          
   995                          hickuproutine:
   996                                  ;; The following routine gets copied as-is to $3000 and run from there.
   997                                  ;; The DMA list is still available in the hyppo ROM when it gets
   998                                  ;; called, so we can just use it there, instead of working out where
   999                                  ;; it gets copied to
  1000                          
  1001                                  ;; NOTE that only 256-bytes are copied, so the hickuproutine and hickupdmalist
  1002                                  ;;      cannot exceed this limit, else revise the krc routine.
  1003                          
  1004                                  ;; Set bottom 22 bits of DMA list address as for C65
  1005                                  ;; (8MB address range).  Hyppo ROM is at $FFF8000, so $FF goes
  1006                                  ;; in high-byte area
  1007                                  ;;
  1008  a4c9 a9ff                       lda #$ff
  1009  a4cb 8d02d7                     sta $d702
  1010  a4ce a9ff                       lda #$ff
  1011  a4d0 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  1012  a4d3 a9a4                       lda #>hickupdmalist
  1013  a4d5 8d01d7                     sta $d701
  1014                                  ;; Trigger enhanced DMA
  1015  a4d8 a9e3                       lda #<hickupdmalist
  1016  a4da 8d05d7                     sta $d705
  1017                          
  1018                                  ;; copy complete, so mark ourselves upgraded, and jump into hypervisor
  1019                                  ;; as though we were just reset.
  1020                          
  1021                                  ;; (it doesn't matter what gets written to this register, it is just the fact that it has been
  1022                                  ;; written to, that sets the flag).
  1023                                  ;;
  1024  a4dd 8d7ed6                     sta hypervisor_hickedup_flag        ;; mark ourselves as having hicked up, (00=virgin, else already-hicked)
  1025  a4e0 4c0081                     jmp $8100
  1026                          
  1027                          ;;         ========================
  1028                          
  1029                          hickupdmalist:
  1030                                  ;; MEGA65 Enhanced DMA options
  1031  a4e3 0a                         !8 $0A  ;; Request format is F018A
  1032  a4e4 8000                       !8 $80,$00 ;; Source is $00xxxxx
  1033  a4e6 81ff                       !8 $81,$FF ;; Destination is $FF
  1034  a4e8 00                         !8 $00  ;; No more options
  1035                                  ;; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
  1036                                  ;; F018A DMA list
  1037                                  ;; (MB offsets get set in routine)
  1038  a4e9 00                         !8 $00 ;; copy + last request in chain
  1039  a4ea 0040                       !16 $4000 ;; size of copy is 16KB
  1040  a4ec 0040                       !16 $4000 ;; starting at $4000
  1041  a4ee 00                         !8 $00   ;; of bank $0
  1042  a4ef 0080                       !16 $8000 ;; destination address is $8000
  1043  a4f1 0f                         !8 $0F   ;; of bank $F
  1044  a4f2 0000                       !16 $0000 ;; modulo (unused)
  1045                          
  1046                          ;;         ========================
  1047                          
  1048                          couldntopenhickup:
  1049                          
  1050                          nohickup:
  1051                          ;;                 ldx #<msg_nohickup
  1052                          ;;                 ldy #>msg_nohickup
  1053                          ;;                 jsr printmessage
  1054                          
  1055                          posthickup:
  1056                          
  1057                                  ;; MILESTONE: Have file system properties.
  1058                          
  1059                                  ;; Look for MEGA65.D81 to mount for F011 emulation
  1060                          
  1061                                  ;; print debug message
  1062                                  ;;
  1063                          !if DEBUG_HYPPO {
  1064                                  +Checkpoint "  Here we are POST-HICKUP"
  1065                          
  1066                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1067                          }
  1068                          
  1069                                  ;; for now indicate that there is no disk in drive
  1070                                  ;; (unless we notice that floppy access has been virtualised)
  1071  a4f4 ad59d6                     lda hypervisor_hardware_virtualisation
  1072  a4f7 2901                       and #$01
  1073  a4f9 d005                       bne f011Virtualised
  1074  a4fb a900                       lda #$00
  1075  a4fd 8d8bd6                     sta sd_f011_en        ;; f011 emulation
  1076                          f011Virtualised:
  1077                          
  1078                                  ;; Go to root directory on default disk
  1079                                  ;;
  1080  a500 ae02bc                     ldx dos_default_disk
  1081  a503 209a92                     jsr dos_cdroot
  1082  a506 b003                       bcs @notSDCardError
  1083  a508 4c65a6                     jmp sdcarderror
  1084                          @notSDCardError:
  1085                          
  1086                                  ;; Re-set virtual screen row length after touching $D06F
  1087  a50b a950                       lda #80
  1088  a50d 8d58d0                     sta $d058
  1089                          
  1090                          	;; Check internal drive / SD card status, and don't mount D81 if set to use internal drive
  1091                          	;; Not only would this be a waste of time, it also stomps the $D6A1 bit 0 that indicates
  1092                          	;; to use the internal drive.
  1093  a510 ada1d6             	lda $d6a1
  1094  a513 2901               	and #$01
  1095  a515 d01b               	bne @dontMountD81
  1096                          	
  1097                                  ;; set name of file we are looking for
  1098                                  ;;
  1099  a517 a29c                       ldx #<txt_MEGA65D81
  1100  a519 a0b2                       ldy #>txt_MEGA65D81
  1101  a51b 205699                     jsr dos_setname
  1102                          
  1103                                  ;; print debug message
  1104                                  ;;
  1105                                  +Checkpoint "  try-mounting MEGA65.D81"
  1106                          
  1107  a51e 20c093                     jsr dos_findfile
  1108  a521 9012                       bcc d81attachfail
  1109  a523 206693                     jsr dos_closefile
  1110                          
  1111  a526 208799                     jsr dos_d81attach0
  1112  a529 900a                       bcc d81attachfail
  1113                          
  1114  a52b a2cc                       ldx #<msg_d81mounted
  1115  a52d a0b0                       ldy #>msg_d81mounted
  1116  a52f 2074a8                     jsr printmessage
  1117                          
  1118                                  ;; print debug message
  1119                                  ;;
  1120                                  +Checkpoint "  mounted MEGA65.D81"
  1121                          
  1122                          @dontMountD81:
  1123                                  ;; all done, move on to loading the ROM
  1124                                  ;;
  1125  a532 4c91a5                     jmp loadrom
  1126                          
  1127                          ;;         ========================
  1128                          
  1129                          d81attachfail:
  1130                                  ;; we couldn't find the D81 file, so tell the user
  1131                                  ;;
  1132  a535 a2ad                       ldx #<msg_nod81
  1133  a537 a0b0                       ldy #>msg_nod81
  1134  a539 2074a8                     jsr printmessage
  1135  a53c a000                       ldy #$00
  1136  a53e abfabc                     ldz dos_error_code
  1137  a541 20eda8                     jsr printhex
  1138                          
  1139                                  ;; debug
  1140                                  +Checkpoint "couldnt mount/attach MEGA65.D81"
  1141                          
  1142  a544 4c91a5             	jmp loadrom
  1143                          	
  1144                          ;;         ========================
  1145                          
  1146                          attempt_loadcharrom:
  1147                                  ;; Load CHARROM.M65 into character ROM
  1148                                  ;;
  1149  a547 a284                       ldx #<txt_CHARROMM65
  1150  a549 a0b2                       ldy #>txt_CHARROMM65
  1151  a54b 205699                     jsr dos_setname
  1152                          
  1153                                  ;; Prepare 32-bit pointer for loading whole ROM ($FF7E000)
  1154                                  ;;
  1155  a54e a900                       lda #$00
  1156  a550 8518                       sta <dos_file_loadaddress+0
  1157  a552 a9e0                       lda #$E0
  1158  a554 8519                       sta <dos_file_loadaddress+1
  1159  a556 a9f7                       lda #$F7
  1160  a558 851a                       sta <dos_file_loadaddress+2
  1161  a55a a90f                       lda #$0F
  1162  a55c 851b                       sta <dos_file_loadaddress+3
  1163                          
  1164  a55e 4c5198                     jmp dos_readfileintomemory
  1165                          
  1166                          attempt_loadc65rom:
  1167  a561 a290                       ldx #<txt_MEGA65ROM
  1168  a563 a0b2                       ldy #>txt_MEGA65ROM
  1169  a565 205699                     jsr dos_setname
  1170                          
  1171                                  ;; Prepare 32-bit pointer for loading whole ROM ($0020000)
  1172                                  ;;
  1173  a568 a900                       lda #$00
  1174  a56a 8518                       sta <dos_file_loadaddress+0
  1175  a56c 8519                       sta <dos_file_loadaddress+1
  1176  a56e 851b                       sta <dos_file_loadaddress+3
  1177  a570 a902                       lda #$02
  1178  a572 851a                       sta <dos_file_loadaddress+2
  1179                          
  1180  a574 4c5198                     jmp dos_readfileintomemory
  1181                          
  1182                          attempt_load1541rom:
  1183  a577 a278                       ldx #<txt_1541ROM
  1184  a579 a0b2                       ldy #>txt_1541ROM
  1185  a57b 205699                     jsr dos_setname
  1186                          
  1187                                  ;; Prepare 32-bit pointer for loading whole ROM ($FFDC000)
  1188                                  ;;
  1189  a57e a900                       lda #$00
  1190  a580 8518                       sta <dos_file_loadaddress+0
  1191  a582 a9c0                       lda #$C0
  1192  a584 8519                       sta <dos_file_loadaddress+1
  1193  a586 a9fd                       lda #$FD
  1194  a588 851a                       sta <dos_file_loadaddress+2
  1195  a58a a90f                       lda #$0F
  1196  a58c 851b                       sta <dos_file_loadaddress+3
  1197                          
  1198  a58e 4c5198                     jmp dos_readfileintomemory
  1199                          
  1200                          loadrom:
  1201                          
  1202                          !if DEBUG_HYPPO {
  1203                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1204                          }
  1205                          
  1206                                  ;; ROMs are not loaded, so try to load them, or prompt
  1207                                  ;; for user to insert SD card
  1208                                  ;;
  1209                          ;;                 ldx #<msg_rombad
  1210                          ;;                 ldy #>msg_rombad
  1211                          ;;                 jsr printmessage
  1212                          
  1213                                  ;; print debug message
  1214                                  ;;
  1215                                  +Checkpoint "  try-loading CHAR-ROM"
  1216                          
  1217  a591 2047a5                     jsr attempt_loadcharrom
  1218  a594 b003                       bcs loadedcharromok
  1219                          
  1220  a596 4ca0a5                     jmp loadc65rom
  1221                          
  1222                          ;;         ========================
  1223                          
  1224                          loadedcharromok:
  1225                          !if DEBUG_HYPPO {
  1226                                  ;; print debug message
  1227                                  ;;
  1228                                  +Checkpoint "  OK-loading CHARROM"
  1229                          
  1230                                  ;; prepare debug message
  1231                                  ;;
  1232                                  ldx dos_current_file_descriptor_offset
  1233                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
  1234                                  sta file_pagesread
  1235                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
  1236                                  sta file_pagesread+1
  1237                          }
  1238                          
  1239  a599 a271                       ldx #<msg_charromloaded
  1240  a59b a0ae                       ldy #>msg_charromloaded
  1241  a59d 2074a8                     jsr printmessage
  1242                          
  1243                          
  1244                          !if DEBUG_HYPPO {
  1245                                  ldy #$00
  1246                                  ldz file_pagesread+1
  1247                                  jsr printhex
  1248                                  ldz file_pagesread
  1249                                  jsr printhex
  1250                          }
  1251                          
  1252                          loadc65rom:
  1253                          
  1254                          !if DEBUG_HYPPO {
  1255                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1256                          }
  1257                          
  1258                                  ;; print debug message
  1259                                  ;;
  1260                                  +Checkpoint "  try-loading MEGA65-ROM"
  1261                          
  1262  a5a0 2061a5                     jsr attempt_loadc65rom
  1263  a5a3 b021                       bcs loadedok
  1264                          
  1265                          ;;         ========================
  1266                          
  1267                                  ;; ROM not found: indicate which ROM we were looking for
  1268                                  ;;
  1269  a5a5 a20b                       ldx #$0b
  1270  a5a7 bd90b2             l17d:   lda txt_MEGA65ROM,x
  1271  a5aa 9d44b1                     sta msg_romnotfound+19,x
  1272  a5ad ca                         dex
  1273  a5ae d0f7                       bne l17d
  1274  a5b0 a231                       ldx #<msg_romnotfound
  1275  a5b2 a0b1                       ldy #>msg_romnotfound
  1276  a5b4 2074a8                     jsr printmessage
  1277                          
  1278  a5b7 20929f                     jsr sdwaitawhile
  1279  a5ba 20929f                     jsr sdwaitawhile
  1280  a5bd 20929f                     jsr sdwaitawhile
  1281  a5c0 20929f                     jsr sdwaitawhile
  1282                          
  1283  a5c3 4c65a6                     jmp sdcarderror
  1284                          
  1285                          ;;         ========================
  1286                          
  1287                                  ;; ROM was found and loaded
  1288                          loadedok:
  1289  a5c6 aef9bc                     ldx dos_current_file_descriptor_offset
  1290  a5c9 bdc5bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +0,x
  1291  a5cc 8d25bf                     sta file_pagesread
  1292  a5cf bdc6bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +1,x
  1293  a5d2 8d26bf                     sta file_pagesread+1
  1294                          
  1295                                  ;; check the size of the loaded file
  1296                                  ;; i.e., that we have loaded $0200 x $100 = $20000 = 128KiB
  1297  a5d5 ad26bf                     lda file_pagesread+1
  1298  a5d8 c900                       cmp #$00
  1299  a5da d003                       bne @romFileNotTooShort
  1300                          @romFileIsTooShort:
  1301  a5dc 4c51a6                     jmp romfiletooshort
  1302                          @romFileNotTooShort:
  1303  a5df c901                       cmp #$01
  1304  a5e1 f0f9                       beq @romFileIsTooShort
  1305  a5e3 c902                       cmp #$02
  1306  a5e5 d005                       bne @romFileIsTooLong
  1307  a5e7 ad25bf                     lda file_pagesread
  1308  a5ea f003                       beq @romFileNotTooLong
  1309                          @romFileIsTooLong:
  1310  a5ec 4c44a6                     jmp romfiletoolong
  1311                          @romFileNotTooLong:
  1312                          
  1313                                  ;; the loaded ROM was OK in size
  1314                          
  1315  a5ef 20bf84                     jsr syspart_dmagic_autoset
  1316                          
  1317                                  ;; copy character ROM portion into place
  1318                                  ;; i.e., copy $2Dxxx to $FF7Exxx
  1319                          
  1320  a5f2 a9ff                       lda #$ff
  1321  a5f4 8d02d7                     sta $d702
  1322  a5f7 8d04d7                     sta $d704
  1323  a5fa a900                       lda #$00
  1324  a5fc a9a6                       lda #>charromdmalist
  1325  a5fe 8d01d7                     sta $d701
  1326  a601 a909                       lda #<charromdmalist
  1327  a603 8d05d7                     sta $d705
  1328                          
  1329  a606 4c18a6                     jmp loadedmegaromok
  1330                          
  1331                          charromdmalist:
  1332                                  ;; M65 DMA options
  1333  a609 0a                         !8 $0A    ;; Request format is F018A
  1334  a60a 81ff                       !8 $81,$FF ;; destination is $FFxxxxx
  1335  a60c 00                         !8 $00 ;; no more options
  1336                                  ;; F018A DMA list
  1337  a60d 00                         !8 $00
  1338  a60e 0010                       !16 $1000
  1339  a610 00d0                       !16 $D000
  1340  a612 02                         !8 $02
  1341  a613 00e0                       !16 $E000
  1342  a615 07                         !8 $07
  1343  a616 0000                       !16 $0000
  1344                          
  1345                          loadedmegaromok:
  1346                          
  1347                          !if DEBUG_HYPPO {
  1348                                  ;; prepare debug message
  1349                                  ;;
  1350                                  ldx dos_current_file_descriptor_offset
  1351                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
  1352                                  sta file_pagesread
  1353                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
  1354                                  sta file_pagesread+1
  1355                          }
  1356                          
  1357  a618 a291                       ldx #<msg_megaromloaded
  1358  a61a a0ae                       ldy #>msg_megaromloaded
  1359  a61c 2074a8                     jsr printmessage
  1360                          
  1361                          !if DEBUG_HYPPO {
  1362                                  ldy #$00
  1363                                  ldz file_pagesread+1
  1364                                  jsr printhex
  1365                                  ldz file_pagesread
  1366                                  jsr printhex
  1367                          }
  1368                          
  1369                                  ;; ROM file loaded, transfer control
  1370                                  ;;
  1371  a61f a257                       ldx #<msg_romok
  1372  a621 a0ae                       ldy #>msg_romok
  1373  a623 2074a8                     jsr printmessage
  1374                          
  1375                                  ;; print debug message
  1376                                  ;;
  1377                                  +Checkpoint "  OK-loaded MEGA65-ROM"
  1378                          
  1379  a626 2077a5                     jsr attempt_load1541rom
  1380  a629 b007                       bcs loaded1541rom
  1381                          
  1382                                  +Checkpoint "  FAIL loading 1541 ROM"
  1383                          
  1384  a62b a273                       ldx #<msg_no1541rom
  1385  a62d a0b1                       ldy #>msg_no1541rom
  1386  a62f 2074a8                     jsr printmessage
  1387                          
  1388                          loaded1541rom:
  1389                          !if DEBUG_HYPPO {
  1390                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1391                          }
  1392                                  ;; check for keyboard input to jump to utility menu
  1393  a632 209aaa                     jsr utility_menu_check
  1394  a635 208eaa                     jsr scankeyboard
  1395  a638 b007                       bcs nokey4
  1396  a63a c920                       cmp #$20
  1397  a63c d003                       bne nokey4
  1398  a63e 4c3eab                     jmp utility_menu
  1399                          nokey4:
  1400  a641 4c14a9                     jmp go64
  1401                          
  1402                          ;;         ========================
  1403                          
  1404                          romfiletoolong:
  1405  a644 a23a                       ldx #<msg_romfilelongerror
  1406  a646 a0b0                       ldy #>msg_romfilelongerror
  1407  a648 2074a8                     jsr printmessage
  1408                          !if DEBUG_HYPPO {
  1409                                  ldz file_pagesread+1
  1410                                  jsr printhex
  1411                                  ldz file_pagesread
  1412                                  jsr printhex
  1413                          }
  1414  a64b 20929f                     jsr sdwaitawhile
  1415  a64e 4ccfa2                     jmp reset_entry
  1416                          
  1417                          romfiletooshort:
  1418  a651 a25a                       ldx #<msg_romfileshorterror
  1419  a653 a0b0                       ldy #>msg_romfileshorterror
  1420  a655 2074a8                     jsr printmessage
  1421                          !if DEBUG_HYPPO {
  1422                                  ldz file_pagesread+1
  1423                                  jsr printhex
  1424                                  ldz file_pagesread
  1425                                  jsr printhex
  1426                          }
  1427  a658 20929f                     jsr sdwaitawhile
  1428  a65b 4ccfa2                     jmp reset_entry
  1429                          
  1430                          ;;         ========================
  1431                          
  1432                          fileopenerror:
  1433  a65e a202                       ldx #<msg_fileopenerror
  1434  a660 a0b0                       ldy #>msg_fileopenerror
  1435  a662 2074a8                     jsr printmessage
  1436                          
  1437                          sdcarderror:
  1438  a665 a20c                       ldx #<msg_sdcarderror
  1439  a667 a0af                       ldy #>msg_sdcarderror
  1440  a669 2074a8                     jsr printmessage
  1441                          
  1442  a66c 20929f                     jsr sdwaitawhile
  1443  a66f 4ccfa2                     jmp reset_entry
  1444                          
  1445                          ;;         ========================
  1446                          
  1447                          badfs:
  1448  a672 a258                       ldx #<msg_badformat
  1449  a674 a0af                       ldy #>msg_badformat
  1450  a676 2074a8                     jsr printmessage
  1451                          
  1452  a679 20929f                     jsr sdwaitawhile
  1453  a67c 4ccfa2                     jmp reset_entry
  1454                          
  1455                          ;; /*  -------------------------------------------------------------------
  1456                          ;;     Display and basic IO routines
  1457                          ;;     ---------------------------------------------------------------- */
  1458                          
  1459                          resetdisplay:
  1460                                  ;; reset screen
  1461                                  ;;
  1462  a67f a940                       lda #$40        ;; 0100 0000 = choose charset
  1463  a681 8d30d0                     sta $d030        ;; VIC-III Control Register A
  1464                          
  1465  a684 ad31d0                     lda $d031        ;; VIC-III Control Register B
  1466  a687 2940                       and #$40        ;; bit-6 is 4mhz
  1467  a689 8d31d0                     sta $d031
  1468                          
  1469  a68c a900                       lda #$00        ;; black
  1470  a68e 8d20d0                     sta $D020       ;; border
  1471  a691 8d21d0                     sta $D021       ;; background
  1472  a694 8d11d7             	sta $D711 	;; Disable DMA audio
  1473                          
  1474                                  ;; Start in 60Hz mode, since most monitors support it
  1475                                  ;; (Also required to make sure matrix mode pixels aren't ragged on first boot).
  1476                          	;; The label here is used so that the syspartition settings can be used to
  1477                          	;; change the default video mode on reset.
  1478                          pal_ntsc_minus_1:	
  1479  a697 a980                       lda #$80
  1480  a699 8d6fd0                     sta $d06f
  1481                          
  1482                                  ;; disable test pattern and various other strange video things that might be hanging around
  1483  a69c a980                       lda #$80
  1484  a69e 1c66d0                     trb $d066
  1485  a6a1 a900                       lda #$00
  1486  a6a3 8d6ad0                     sta $d06a ;; bank# for screen address
  1487  a6a6 8d6bd0                     sta $d06b ;; 16-colour sprites
  1488  a6a9 8d78d0                     sta $d078 ;; sprite Y super MSBs
  1489  a6ac 8d5fd0                     sta $d05f ;; sprite X super MSBs
  1490  a6af a978                       lda #$78
  1491  a6b1 8d5ad0                     sta $d05a ;; correct horizontal scaling
  1492  a6b4 a9c0                       lda #$C0
  1493  a6b6 8d5dd0                     sta $D05D ;; enable hot registers, raster delay
  1494  a6b9 a950                       lda #80
  1495  a6bb 8d5cd0                     sta $D05C ;; Side border width LSB
  1496                          
  1497                                  ;; point VIC-IV to bottom 16KB of display memory
  1498                                  ;;
  1499  a6be a9ff                       lda #$ff
  1500  a6c0 8d01dd                     sta $DD01
  1501  a6c3 8d00dd                     sta $DD00
  1502                          
  1503                                  ;; We use VIC-II style registers as this resets video frame in
  1504                                  ;; least instructions, and 40 columns is fine for us.
  1505                                  ;;
  1506  a6c6 a914                       lda #$14        ;; 0001 0100
  1507  a6c8 8d18d0                     sta $D018        ;; VIC-II Character/Screen location
  1508                          
  1509  a6cb a91b                       lda #$1B        ;; 0001 1011
  1510  a6cd 8d11d0                     sta $D011        ;; VIC-II Control Register
  1511                          
  1512  a6d0 a9c8                       lda #$C8        ;; 1100 1000
  1513  a6d2 8d16d0                     sta $D016        ;; VIC-II Control Register
  1514                          
  1515                                  ;; Now switch to 16-bit text mode so that we can use proportional
  1516                                  ;; characters and full-colour characters for chars >$FF for the logo
  1517                          	;; Also enable CRT emulation by default.
  1518                                  ;;
  1519  a6d5 a9e5                       lda #$e5
  1520  a6d7 8d54d0                     sta $d054        ;; VIC-IV Control Register C
  1521                          
  1522                                  ;; and 80 bytes (40 16-bit characters) per row.
  1523                                  ;;
  1524  a6da a950                       lda #<80
  1525  a6dc 8d58d0                     sta $d058
  1526  a6df a900                       lda #>80
  1527  a6e1 8d59d0                     sta $d059
  1528                          
  1529  a6e4 60                         rts
  1530                          
  1531                          ;;         ========================
  1532                          
  1533                          resetpalette:
  1534                                  ;; reset VIC-IV palette to sensible defaults.
  1535                                  ;; load C64 colours into palette bank 3 for use when
  1536                                  ;; PAL bit in $D030 is set.
  1537                                  ;;
  1538  a6e5 a904                       lda #$04
  1539  a6e7 0c30d0                     tsb $D030        ;; enable PAL bit in $D030
  1540                          
  1541  a6ea 202ea8             	jsr setbannerpalette
  1542                          	
  1543                                  ;; C64 colours designed to look like C65 colours on an
  1544                                  ;; RGBI screen.
  1545                                  ;;
  1546                                  ;; formatted in ASM to help visualise what each code is for.
  1547                                  ;;
  1548  a6ed a900                       lda #$00
  1549  a6ef 8d00d1                         sta $D100
  1550  a6f2 8d00d2                         sta $D200
  1551  a6f5 8d00d3                         sta $D300
  1552                          
  1553  a6f8 a9ff                       lda #$ff
  1554  a6fa 8d01d1                         sta $D101
  1555  a6fd 8d01d2                         sta $D201
  1556  a700 8d01d3                         sta $D301
  1557                          
  1558  a703 a9ba                       lda #$ba
  1559  a705 8d02d1                                 sta $D102
  1560  a708 a913                               lda #$13
  1561  a70a 8d02d2                                 sta $D202
  1562  a70d a962                               lda #$62
  1563  a70f 8d02d3                                 sta $D302
  1564                          
  1565  a712 a966                               lda #$66
  1566  a714 8d03d1                                 sta $D103
  1567  a717 a9ad                               lda #$ad
  1568  a719 8d03d2                                 sta $D203
  1569  a71c a9ff                               lda #$ff
  1570  a71e 8d03d3                                 sta $D303
  1571                          
  1572  a721 a9bb                               lda #$bb
  1573  a723 8d04d1                                 sta $D104
  1574  a726 a9f3                               lda #$f3
  1575  a728 8d04d2                                 sta $D204
  1576  a72b a98b                               lda #$8b
  1577  a72d 8d04d3                                 sta $D304
  1578                          
  1579  a730 a955                               lda #$55
  1580  a732 8d05d1                                 sta $D105
  1581  a735 a9ec                               lda #$ec
  1582  a737 8d05d2                                 sta $D205
  1583  a73a a985                               lda #$85
  1584  a73c 8d05d3                                 sta $D305
  1585                          
  1586  a73f a9d1                               lda #$d1
  1587  a741 8d06d1                                 sta $D106
  1588  a744 a9e0                               lda #$e0
  1589  a746 8d06d2                                 sta $D206
  1590  a749 a979                               lda #$79
  1591  a74b 8d06d3                                 sta $D306
  1592                          
  1593  a74e a9ae                               lda #$ae
  1594  a750 8d07d1                                 sta $D107
  1595  a753 a95f                               lda #$5f
  1596  a755 8d07d2                                 sta $D207
  1597  a758 a9c7                               lda #$c7
  1598  a75a 8d07d3                                 sta $D307
  1599                          
  1600  a75d a99b                               lda #$9b
  1601  a75f 8d08d1                                 sta $D108
  1602  a762 a947                               lda #$47
  1603  a764 8d08d2                                 sta $D208
  1604  a767 a981                               lda #$81
  1605  a769 8d08d3                                 sta $D308
  1606                          
  1607  a76c a987                               lda #$87
  1608  a76e 8d09d1                                 sta $D109
  1609  a771 a937                               lda #$37
  1610  a773 8d09d2                                 sta $D209
  1611  a776 a900                               lda #$00
  1612  a778 8d09d3                                 sta $D309
  1613                          
  1614  a77b a9dd                               lda #$dd
  1615  a77d 8d0ad1                                 sta $D10a
  1616  a780 a939                               lda #$39
  1617  a782 8d0ad2                                 sta $D20a
  1618  a785 a978                               lda #$78
  1619  a787 8d0ad3                                 sta $D30a
  1620                          
  1621  a78a a9b5                               lda #$b5
  1622  a78c 8d0bd1                                 sta $D10b
  1623  a78f 8d0bd2                                 sta $D20b
  1624  a792 8d0bd3                                 sta $D30b
  1625                          
  1626  a795 a9b8                               lda #$b8
  1627  a797 8d0cd1                                 sta $D10c
  1628  a79a 8d0cd2                                 sta $D20c
  1629  a79d 8d0cd3                                 sta $D30c
  1630                          
  1631  a7a0 a90b                               lda #$0b
  1632  a7a2 8d0dd1                                 sta $D10d
  1633  a7a5 a94f                               lda #$4f
  1634  a7a7 8d0dd2                                 sta $D20d
  1635  a7aa a9ca                               lda #$ca
  1636  a7ac 8d0dd3                                 sta $D30d
  1637                          
  1638  a7af a9aa                               lda #$aa
  1639  a7b1 8d0ed1                                 sta $D10e
  1640  a7b4 a9d9                               lda #$d9
  1641  a7b6 8d0ed2                                 sta $D20e
  1642  a7b9 a9fe                               lda #$fe
  1643  a7bb 8d0ed3                                 sta $D30e
  1644                          
  1645  a7be a98b                               lda #$8b
  1646  a7c0 8d0fd1                                 sta $D10f
  1647  a7c3 8d0fd2                                 sta $D20f
  1648  a7c6 8d0fd3                                 sta $D30f
  1649                          
  1650                          
  1651  a7c9 60                     rts
  1652                          
  1653                          ;;         ========================
  1654                          
  1655                          ;; erase standard 40-column screen
  1656                          ;;
  1657                          erasescreen:
  1658                                  ;; bank in 2nd KB of colour RAM
  1659                                  ;;
  1660  a7ca a901                       lda #$01
  1661  a7cc 0c30d0                     tsb $D030
  1662                          
  1663                                  ;; use DMA to clear screen and colour RAM
  1664                                  ;; The screen is in 16-bit bit mode, so we actually need to fill
  1665                                  ;; with $20,$00, ...
  1666                                  ;;
  1667                                  ;; We will cheat by setting the first four bytes, and then copying from
  1668                                  ;; there, and it will then read from the freshly written bytes.
  1669                                  ;; (two bytes might not be enough to allow the write from the last DMA
  1670                                  ;;  action to be avaialble for reading because of how the DMAgic is
  1671                                  ;;  pipelined).
  1672                                  ;;
  1673  a7cf a920                       lda #$20
  1674  a7d1 8d0004                     sta $0400
  1675  a7d4 8d0204                     sta $0402
  1676  a7d7 a900                       lda #$00
  1677  a7d9 8d0104                     sta $0401
  1678  a7dc 8d0304                     sta $0403
  1679                          
  1680                                  ;; Set bottom 22 bits of DMA list address as for C65
  1681                                  ;; (8MB address range)
  1682                                  ;;
  1683  a7df a9ff                       lda #$ff
  1684  a7e1 8d02d7                     sta $d702
  1685                          
  1686                                  ;; Hyppo ROM is at $FFFE000 - $FFFFFFF, so
  1687                                  ;; we need to tell DMAgic that DMA list is in $FFxxxxx.
  1688                                  ;; this has to be done AFTER writing to $d702, as $d702
  1689                                  ;; clears bits 27 - 22 of the DMA list address to help with
  1690                                  ;; compatibility.
  1691                                  ;;
  1692  a7e4 a9ff                       lda #$ff
  1693  a7e6 8d04d7                     sta $d704
  1694                          
  1695  a7e9 a9a8                       lda #>erasescreendmalist
  1696  a7eb 8d01d7                     sta $d701
  1697                          
  1698                                  ;; set bottom 8 bits of address and trigger DMA.
  1699                                  ;;
  1700  a7ee a959                       lda #<erasescreendmalist
  1701  a7f0 8d05d7                     sta $d705
  1702                          
  1703                                  ;; bank 2nd KB of colour RAM back out
  1704                                  ;;
  1705  a7f3 a901                       lda #$01
  1706  a7f5 1c30d0                     trb $D030
  1707                          
  1708                          ;;         ========================
  1709                          
  1710                                  ;; move cursor back to top of the screen
  1711                                  ;; (but leave 8 rows for logo and banner text)
  1712                                  ;;
  1713  a7f8 a908                       lda #$08
  1714  a7fa 8d20bf                     sta screenrow
  1715                          
  1716                                  ;; draw 40x8 char block for banner
  1717                                  ;;
  1718  a7fd a000                       ldy #$00
  1719  a7ff a900                       lda #$00
  1720                          logo1:
  1721  a801 990004                     sta $0400,y
  1722  a804 1a                         inc
  1723  a805 c8                         iny
  1724  a806 c8                         iny
  1725  a807 d0f8                       bne logo1
  1726                          logo1a:
  1727  a809 990005                     sta $0500,y
  1728  a80c 1a                         inc
  1729  a80d c8                         iny
  1730  a80e c8                         iny
  1731  a80f d0f8                       bne logo1a
  1732                          logo1b:
  1733  a811 990006                     sta $0600,y
  1734  a814 1a                         inc
  1735  a815 c8                         iny
  1736  a816 c8                         iny
  1737  a817 c080                       cpy #$80
  1738  a819 d0f6                       bne logo1b
  1739                          
  1740                                  ;; then write the high bytes for these (all $01, so char range will be
  1741                                  ;; $100-$140. $100 x $40 = $4000-$4FFF
  1742                                  ;;
  1743  a81b a200                       ldx #$00
  1744  a81d a916                       lda #$16     ;; $1600 x $40 = $58000 where banner tiles sit
  1745                          logo2:
  1746  a81f 9d0104                     sta $0401,x
  1747  a822 1a                         inc
  1748  a823 9d8105                     sta $0581,x
  1749  a826 3a                         dec
  1750  a827 9d0105                     sta $0501,x
  1751  a82a e8                         inx
  1752  a82b e8                         inx
  1753  a82c d0f1                       bne logo2
  1754                          
  1755                                  ;; finally set palette for banner using contents of memory at $57D00-$57FFF
  1756                          setbannerpalette:
  1757  a82e a9ff                       lda #$ff
  1758  a830 8d70d0                     sta $D070        ;; select palette bank 3 for display and edit
  1759                          
  1760                          	;; Set DMA list address
  1761                                  ;;
  1762  a833 a9a8                       lda #>bannerpalettedmalist
  1763  a835 8d01d7                     sta $d701
  1764  a838 a90f                       lda #$0f
  1765  a83a 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  1766  a83d a9ff                       lda #$ff
  1767  a83f 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  1768                          
  1769                                  ;; set bottom bits of DMA list address and trigger enhanced DMA
  1770                                  ;;
  1771  a842 a948                       lda #<bannerpalettedmalist
  1772  a844 8d05d7                     sta $d705
  1773                          
  1774  a847 60                         rts
  1775                          
  1776                          bannerpalettedmalist:
  1777                                  ;; MEGA65 enhanced DMA options
  1778  a848 0a                         !8 $0A      ;; Request format is F018A
  1779  a849 800081ff                   !8 $80,$00,$81,$FF ;; src = $00xxxxx, dst=$FFxxxxx
  1780  a84d 00                         !8 $00 ;; no more options
  1781                                  ;; F018A DMA list
  1782  a84e 00                         !8 $00   ;; COPY + no chained request
  1783  a84f 0003                       !16 $0300
  1784  a851 007d                       !16 $7D00 ;;
  1785  a853 05                         !8 $05   ;; source bank 05
  1786  a854 0031                       !16 $3100 ;; ; $xxx3100
  1787  a856 0d                         !8 $0D   ;; ; $xxDxxxx
  1788  a857 0000                       !16 $0000 ;; modulo (unused)
  1789                          
  1790                          
  1791                          
  1792                          ;;         ========================
  1793                          
  1794                          erasescreendmalist:
  1795                                  ;; Clear screen RAM
  1796                                  ;;
  1797                                  ;; MEGA65 enhanced DMA options
  1798  a859 0a                         !8 $0A      ;; Request format is F018A
  1799  a85a 00                         !8 $00 ;; no more options
  1800                                  ;; F018A DMA list
  1801  a85b 04                         !8 $04   ;; COPY + chained request
  1802  a85c cc07                       !16 1996  ;; 40x25x2-4 = 1996
  1803  a85e 0004                       !16 $0400 ;; copy from start of screen at $0400
  1804  a860 00                         !8 $00   ;; source bank 00
  1805  a861 0404                       !16 $0404 ;; ... to screen at $0402
  1806  a863 00                         !8 $00   ;; screen is in bank $00
  1807  a864 0000                       !16 $0000 ;; modulo (unused)
  1808                          
  1809                                  ;; Clear colour RAM
  1810                                  ;;
  1811                                  ;; MEGA65 DMA options
  1812  a866 81ff                       !8 $81,$FF ;; Destination is $FFxxxxx
  1813  a868 00                         !8 $00     ;; no more options
  1814                                  ;; F018A dma list
  1815  a869 03                         !8 $03     ;; FILL + no more chained requests
  1816  a86a d007                       !16 2000    ;; 40x25x2 = 2000
  1817  a86c 01                         !8 $01     ;; fill with white = $01
  1818  a86d 0000                       !8 $00,$00 ;; rest of source address is ignored in fill
  1819  a86f 0000                       !16 $0000   ;; destination address
  1820  a871 08                         !8 $08     ;; destination bank
  1821  a872 0000                       !16 $0000   ;; modulo (unused)
  1822                          
  1823                          
  1824                          ;;         ========================
  1825                          
  1826                          printmessage:        ;; HELPER routine
  1827                                  ;;
  1828                                  ;; This subroutine takes inputs from the X and Y registers,
  1829                                  ;; so set these registers before calling this subroutine,
  1830                                  ;; The X and Y registers need to point to a message as shown below:
  1831                                  ;;
  1832                                  ;;         ldx #<msg_foundsdcard
  1833                                  ;;         ldy #>msg_foundsdcard
  1834                                  ;;         jsr printmessage
  1835                                  ;;
  1836                                  ;; Ie: the X is the high-byte of the 16-bit address, and
  1837                                  ;;     the Y is the low-byte  of the 16-bit address.
  1838                          
  1839  a874 860c                       stx <zptempp        ;; zptempp is 16-bit pointer to message
  1840  a876 840d                       sty <zptempp+1
  1841                          
  1842  a878 a900                       lda #$00
  1843  a87a 850e                       sta <zptempp2        ;; zptempp2 is 16-bit pointer to screen
  1844  a87c a904                       lda #$04
  1845  a87e 850f                       sta <zptempp2+1
  1846                          
  1847  a880 ae20bf                     ldx screenrow
  1848                          
  1849                                  ;; Makesure we can't accidentally write on row zero
  1850  a883 d002                       bne pm22
  1851  a885 a208                       ldx #$08
  1852                          pm22:
  1853                                  ;; if we have reached the bottom of the screen, start writing again
  1854                                  ;; from the top of the screen (but don't touch the top 8 rows for
  1855                                  ;; logo and banner)
  1856  a887 e019                       cpx #25
  1857  a889 d008                       bne pm2
  1858                          
  1859  a88b 20aeac             	jsr scroll_screen
  1860  a88e a218               	ldx #24
  1861  a890 8e20bf             	stx screenrow
  1862                          
  1863                                  ;; work out the screen address
  1864                                  ;;
  1865                          pm2:
  1866  a893 e000               	cpx #$00
  1867  a895 f010                       beq pm1
  1868                          	
  1869  a897 18                         clc
  1870  a898 a50e                       lda <zptempp2
  1871  a89a 6950                       adc #$50          ;; 40 columns x 16 bit
  1872  a89c 850e                       sta <zptempp2
  1873  a89e a50f                       lda <zptempp2+1
  1874  a8a0 6900                       adc #$00
  1875  a8a2 850f                       sta <zptempp2+1
  1876                          
  1877  a8a4 ca                 pm5:    dex
  1878  a8a5 d0ec                       bne pm2
  1879                          pm1:
  1880                          
  1881                                  ;; Clear line (16-bit chars, so write #$0020 to each word
  1882                                  ;;
  1883  a8a7 a000                       ldy #$00
  1884  a8a9 a920               pm1b:   lda #$20
  1885  a8ab 910e                       sta (<zptempp2),y
  1886  a8ad c8                         iny
  1887  a8ae a900                       lda #$00
  1888  a8b0 910e                       sta (<zptempp2),y
  1889  a8b2 c8                         iny
  1890  a8b3 c050                       cpy #$50
  1891  a8b5 d0f2                       bne pm1b
  1892                          
  1893                          writestring:
  1894  a8b7 db                         phz
  1895  a8b8 a000                       ldy #$00
  1896  a8ba a300                       ldz #$00
  1897  a8bc b10c               pm3:    lda (<zptempp),y
  1898  a8be f013                       beq endofmessage
  1899                          
  1900                                  ;; convert ASCII/PETSCII to screen codes
  1901                                  ;;
  1902  a8c0 c940                       cmp #$40
  1903  a8c2 9002                       bcc pm4
  1904  a8c4 291f                       and #$1f
  1905                          
  1906                          pm4:                ;; write 16-bit character code
  1907                                  ;;
  1908  a8c6 920e                       sta (<zptempp2),z
  1909  a8c8 1b                         inz
  1910  a8c9 48                         pha
  1911  a8ca a900                       lda #$00
  1912  a8cc 920e                       sta (<zptempp2),z
  1913  a8ce 68                         pla
  1914  a8cf c8                         iny
  1915  a8d0 1b                         inz
  1916  a8d1 d0e9                       bne pm3
  1917                          endofmessage:
  1918  a8d3 ee20bf                     inc screenrow
  1919                          
  1920                          !if DEBUG_HYPPO {
  1921                          	;; XXX DEBUG
  1922                          	;; Require key press after each line displayed.
  1923                          ;;	jsr debug_wait_on_key
  1924                          }
  1925                          
  1926  a8d6 fb                 	plz
  1927  a8d7 60                 	rts
  1928                          
  1929                          printbanner:
  1930  a8d8 860c                       stx <zptempp
  1931  a8da 840d                       sty <zptempp+1
  1932  a8dc a904                       lda #<$0504
  1933  a8de 8d0ebf                     sta zptempp2
  1934  a8e1 a905                       lda #>$0504
  1935  a8e3 8d0fbf                     sta zptempp2+1
  1936  a8e6 20b7a8                     jsr writestring
  1937  a8e9 ce20bf                     dec screenrow
  1938  a8ec 60                         rts
  1939                          
  1940                          ;;         ========================
  1941                          
  1942                          printhex:
  1943                                  ;; helper function
  1944                                  ;;
  1945                                  ;; seems to want to print the value if the z-reg onto the previous line written to the screen,
  1946                                  ;; so currently the screen consists of say "mounted $$ images"
  1947                                  ;; and this routine will go and change the "$$" to the value in the z-reg
  1948                                  ;;
  1949                                  ;; BG: surely this can be replaced with updating the "$$" before printing the string
  1950                                  ;;
  1951                                  ;; INPUT: .Y, BG seems to be an offset, should be set to zero?
  1952                                  ;; INPUT: .Z, value in Z-reg to be displayed omn the screen
  1953                                  ;;
  1954  a8ed 6b                         tza
  1955  a8ee 4a                         lsr
  1956  a8ef 4a                         lsr
  1957  a8f0 4a                         lsr
  1958  a8f1 4a                         lsr
  1959  a8f2 20f8a8                     jsr printhexdigit
  1960  a8f5 6b                         tza
  1961  a8f6 290f                       and #$0f
  1962                          printhexdigit:
  1963                                  ;; find next $ sign to replace with hex digit
  1964                                  ;;
  1965  a8f8 aa                         tax
  1966  a8f9 b10e               phd3:   lda (<zptempp2),y
  1967  a8fb c924                       cmp #$24
  1968  a8fd f007                       beq phd2
  1969  a8ff c8                         iny
  1970  a900 c8                         iny
  1971  a901 c050                       cpy #$50
  1972  a903 90f4                       bcc phd3
  1973  a905 60                         rts
  1974                          
  1975  a906 8a                 phd2:   txa
  1976  a907 0930                       ora #$30
  1977  a909 c93a                       cmp #$3a
  1978  a90b 9002                       bcc phd1
  1979  a90d e939                       sbc #$39
  1980  a90f 910e               phd1:   sta (<zptempp2),y
  1981  a911 c8                         iny
  1982  a912 c8                         iny
  1983  a913 60                         rts
  1984                          
  1985                          ;;         ========================
  1986                          
  1987                          go64:
  1988                          
  1989                          ;; Transfer control to C64 kernel.
  1990                          ;; (This also allows entry to C65 mode, because the
  1991                          ;;  C64-mode kernel on the C65 checks if C65 mode
  1992                          ;;  should be entered.)
  1993                          
  1994                          	;; Prevent utility menu from being launched
  1995  a914 a94c               	lda #$4c
  1996  a916 8d3eab             	sta utility_menu
  1997                          
  1998                          	;; Prevent flash menu from being launched
  1999  a919 a94c               	lda #$4c
  2000  a91b 8d19a3             	sta first_boot_flag_instruction
  2001                          
  2002                          	;; Warn user if dipswitch 3 is on
  2003  a91e ad9dd6             	lda $d69d
  2004  a921 2904               	and #$04
  2005  a923 f014               	beq l41
  2006  a925 a20a                       ldx #<msg_dipswitch3on
  2007  a927 a0b1                       ldy #>msg_dipswitch3on
  2008  a929 2074a8                     jsr printmessage
  2009                          l40a:
  2010                          	;; Wait for user to press RUN/STOP to continue booting
  2011  a92c ad10d6             	lda $d610
  2012  a92f c903               	cmp #$03
  2013  a931 f006               	beq l41
  2014  a933 ee20d0             	inc $d020
  2015  a936 4c2ca9             	jmp l40a
  2016                          l41:
  2017                          	;; remove RUN/STOP from key queue
  2018  a939 8d10d6             	sta $d610
  2019                          	
  2020                                  ;; Check if hold boot switch is set (control-key)
  2021                                  ;;
  2022  a93c ad11d6             	lda buckykey_status
  2023  a93f 2914                       and #$14
  2024  a941 f011                       beq l42      ;; no, so continue
  2025                          
  2026                                  ;; yes, display message
  2027                                  ;;
  2028  a943 a2e5                       ldx #<msg_releasectrl
  2029  a945 a0b0                       ldy #>msg_releasectrl
  2030  a947 2074a8                     jsr printmessage
  2031                          
  2032                          l41a:
  2033                                  ;; check for ALT key to jump to utility menu
  2034  a94a 209aaa                     jsr utility_menu_check
  2035                          
  2036                                  ;; and otherwise wait until CTRL is released
  2037  a94d ad11d6                     lda buckykey_status
  2038  a950 2904                       and #$04
  2039  a952 d0f6                       bne l41a
  2040                          l42:
  2041                                  ;; unmap sector buffer so C64 can see CIAs
  2042                                  ;;
  2043  a954 a982                       lda #$82
  2044  a956 8d80d6                     sta sd_ctrl
  2045                          
  2046                                  ;; copy routine to stack to switch to
  2047                                  ;; C64 memory map and enter via reset
  2048                                  ;; vector.
  2049                          
  2050                                  ;; erase hyppo ROM copy from RAM
  2051                                  ;; (well, at least enough so that BASIC doesn't get upset)
  2052                                  ;; XXX - use DMA
  2053                                  ;;
  2054  a959 a200                       ldx #$00
  2055  a95b 8a                         txa
  2056  a95c 9d0008             g61:    sta $0800,x
  2057  a95f e8                         inx
  2058  a960 d0fa                       bne g61
  2059                          
  2060  a962 a928                       lda #<40
  2061  a964 8d58d0                     sta $d058
  2062  a967 a900                       lda #>40
  2063  a969 8d59d0                     sta $d059
  2064                          
  2065                                  ;; write protect ROM RAM
  2066  a96c a904                       lda #$04
  2067  a96e 0c7dd6                     tsb hypervisor_feature_enables
  2068                          
  2069  a971 20729d                     jsr task_set_c64_memorymap
  2070  a974 20e79d                     jsr task_set_pc_to_reset_vector
  2071  a977 200b9e                     jsr task_dummy_nmi_vector
  2072                          
  2073                                  ;; This must happen last, so that the ultimax cartridge
  2074                                  ;; reset vector is used, instead of the one in the loaded ROM
  2075  a97a 20a9a9                     jsr setup_for_ultimax_cartridge
  2076                          
  2077                                  ;; Apply RESET to cartridge for a little while so that cartridges
  2078                                  ;; with capacitors tied to EXROM or GAME are visible.
  2079                                  ;; Do this last, because some cartridges remain visible for as little
  2080                                  ;; as 512 usec.
  2081  a97d 2083a9                     jsr reset_cartridge
  2082                          
  2083                                  ;; exit from hypervisor to start machine
  2084  a980 8d7fd6                     sta hypervisor_enterexit_trigger
  2085                          

; ******** Source: ultimax.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          reset_cartridge:
     6  a983 a300                       ldz #$00
     7  a985 a900                       lda #<$0000
     8  a987 8d10bf                     sta zptempv32+0
     9  a98a 8d11bf                     sta zptempv32+1
    10  a98d a901                       lda #<$0701
    11  a98f 8d12bf                     sta zptempv32+2
    12  a992 a907                       lda #>$0701
    13  a994 8d13bf                     sta zptempv32+3
    14  a997 a920                       lda #$20
    15  a999 ea9210                     sta [<zptempv32],z
    16  a99c a000                       ldy #$00
    17                          charge_delay:
    18  a99e 1b                         inz
    19  a99f d0fd                       bne charge_delay
    20  a9a1 c8                         iny
    21  a9a2 d0fa                       bne charge_delay
    22  a9a4 6b                         tza
    23  a9a5 ea9210                     sta [<zptempv32],z
    24  a9a8 60                         rts
    25                          
    26                          setup_for_ultimax_cartridge:
    27  a9a9 ad7ed6                     lda hypervisor_cartridge_flags
    28  a9ac 2960                       and #$60
    29  a9ae c940                       cmp #$40
    30  a9b0 f001                       beq is_ultimax_cartridge
    31  a9b2 60                         rts
    32                          
    33                          is_ultimax_cartridge:
    34                                  ;; It's an ultimax cartridge, so we have a couple of things to
    35                                  ;; handle differently.
    36                                  ;;
    37                                  ;; 1. Read reset vector directly from $FFFx, where it will be
    38                                  ;;    currently visible.
    39                                  ;; 2. Copy $F000-$FFFF to $3xxx, $7xxx, $Bxxx and $Fxxx in 1st
    40                                  ;;    64KB of RAM to simulate the way that a C64 makes the top
    41                                  ;;    4KB of Ultimax mode ROMs visible to the VIC-II at these
    42                                  ;;    locations.
    43                                  ;;
    44                                  ;; This means copying from $701Fxxx to $000{3,7,B,F}xxx, as DMA
    45                                  ;; doesn't see mapped ROMs.
    46                                  ;;
    47                                  ;; (We  use one list 4x with different destination, as it uses
    48                                  ;; less bytes than a chained DMA list with all four.)
    49  a9b3 adfcff                     lda reset_vector
    50  a9b6 8d48d6                     sta hypervisor_pcl
    51  a9b9 adfdff                     lda reset_vector+1
    52  a9bc 8d49d6                     sta hypervisor_pch
    53                          
    54                                  ;; Use DMA to quickly do the copy
    55  a9bf a9a9                       lda #>ultimaxsetup_dmalist
    56  a9c1 8d01d7                     sta $d701
    57  a9c4 a90f                       lda #$0f
    58  a9c6 8d02d7                     sta $d702 ;; DMA list is $xxFxxxx
    59  a9c9 a9ff                       lda #$ff
    60  a9cb 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
    61                          
    62                                  ;; Run list 4 times with different destination addresses
    63  a9ce a930                       lda #$30
    64  a9d0 a2e0                       ldx #<ultimaxsetup_dmalist
    65                          ultimax_setup_loop:
    66  a9d2 8deca9                     sta ultimaxsetup_destination+1
    67                          
    68                                  ;; Trigger MEGA65 enhanced DMA
    69  a9d5 8e05d7                     stx $d705
    70  a9d8 18                         clc
    71  a9d9 6940                       adc #$40
    72  a9db c930                       cmp #$30
    73  a9dd d0f3                       bne ultimax_setup_loop
    74                          
    75  a9df 60                         rts
    76                          
    77                          ultimaxsetup_dmalist:
    78                                  ;; MEGA65 Enhanced DMA options
    79  a9e0 8070                       !8 $80,$70   ;; copy from $70xxxxx
    80  a9e2 8100                       !8 $81,$00   ;; copy to $01xxxxx
    81  a9e4 00                         !8 $00       ;; end of options
    82                          
    83                                  ;; F018A dma list
    84  a9e5 00                         !8 $00       ;; COPY, no chain
    85  a9e6 0010                       !16 $1000     ;; 4KB
    86                          
    87                                  ;; source address
    88  a9e8 00f0                       !16 $F000     ;; source is $xxxF000
    89  a9ea 01                         !8 $01       ;; source is $xx1xxxx
    90                          
    91                          ultimaxsetup_destination:
    92  a9eb 0030                       !16 $3000     ;; destination is $xxx3000 (gets changed by routine above)
    93  a9ed 00                         !8 $00       ;; destination is $xx03000
    94  a9ee 0000                       !8 $00,00    ;; Modulo

; ******** Source: src/hyppo/main.asm
  2087                          
  2088                          ;;         ========================
  2089                          
  2090                          ;; BG: the longpeek subroutine does not get called from hyppo,
  2091                          ;;     it gets called only from the hyppo_task file,
  2092                          ;;     so i suggest moving this subroutine to that file.
  2093                          
  2094                          longpeek:
  2095                                  ;; Use DMAgic to read any byte of RAM in 28bit address space.
  2096                                  ;; Value gets read into $BC00 (hyppo_scratchbyte0)
  2097                                  ;; ($FFFBC00 - $FFFBDFF)
  2098                          
  2099                                  ;; Patch DMA list
  2100                                  ;;
  2101  a9f0 8e1aaa                     stx longpeekdmalist_src_lsb
  2102  a9f3 8c1baa                     sty longpeekdmalist_src_2sb
  2103  a9f6 9c1caa                     stz longpeekdmalist_src_msb
  2104  a9f9 8d13aa                     sta longpeekdmalist_src_mb
  2105                          
  2106                                  ;; Set DMA list address
  2107                                  ;;
  2108  a9fc a9aa                       lda #>longpeekdmalist
  2109  a9fe 8d01d7                     sta $d701
  2110  aa01 a90f                       lda #$0f
  2111  aa03 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  2112  aa06 a9ff                       lda #$ff
  2113  aa08 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  2114                          
  2115                                  ;; set bottom bits of DMA list address and trigger enhanced DMA
  2116                                  ;;
  2117  aa0b a911                       lda #<longpeekdmalist
  2118  aa0d 8d05d7                     sta $d705
  2119  aa10 60                         rts
  2120                          
  2121                          longpeekdmalist:
  2122                                  ;; MEGA65 Enhanced DMA options
  2123  aa11 0a                         !8 $0A      ;; Request format is F018A
  2124  aa12 80                         !8 $80
  2125                          longpeekdmalist_src_mb:
  2126  aa13 ff                         !8 $FF
  2127  aa14 81ff                       !8 $81,$FF ;; destination is always $FFxxxxx
  2128  aa16 00                         !8 $00 ;; end of options marker
  2129                                  ;; F018A format request follows
  2130  aa17 00                         !8 $00 ;; COPY, no chain
  2131                                  ;; 1 byte
  2132  aa18 0100                       !16 $0001
  2133                                  ;; source address
  2134                          longpeekdmalist_src_lsb:
  2135  aa1a 00                         !8 $00
  2136                          longpeekdmalist_src_2sb:
  2137  aa1b 00                         !8 $00
  2138                          longpeekdmalist_src_msb:
  2139  aa1c 00                         !8 $00
  2140                                  ;; destination address ($xxFBC00)
  2141  aa1d 00bc                       !16 hyppo_scratchbyte0
  2142  aa1f 0f                         !8 $0F
  2143  aa20 0000                       !8 $00,00 ;; Modulo
  2144                          
  2145                          longpoke:
  2146                                  ;; Use DMAgic to write any byte of RAM in C65 1MB address space.
  2147                                  ;; A = value
  2148                                  ;; X = Address LSB
  2149                                  ;; Y = Address MidB
  2150                                  ;; Z = Address Bank
  2151                          
  2152                                  ;; Patch DMA list
  2153                                  ;;
  2154  aa22 8d57aa                     sta longpokevalue
  2155  aa25 8e5aaa                     stx longpokeaddress+0
  2156  aa28 8c5baa                     sty longpokeaddress+1
  2157  aa2b 9c5caa                     stz longpokeaddress+2
  2158  aa2e 6b                         tza
  2159  aa2f 4a                         lsr
  2160  aa30 4a                         lsr
  2161  aa31 4a                         lsr
  2162  aa32 4a                         lsr
  2163  aa33 8d52aa                     sta longpokedmalist_dest_mb ;; DMAgic destination MB
  2164                                  ;; and enable F108B enhanced mode by default
  2165  aa36 a901                       lda #$01
  2166  aa38 8d03d7                     sta $d703
  2167                          
  2168                                  ;; Set DMA list address
  2169                                  ;;
  2170  aa3b a9aa                       lda #>longpokedmalist
  2171  aa3d 8d01d7                     sta $d701
  2172  aa40 a90f                       lda #$0f
  2173  aa42 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  2174  aa45 a9ff                       lda #$ff
  2175  aa47 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  2176                          
  2177                                  ;; set bottom bits of DMA list address and trigger enhhanced DMA
  2178                                  ;;
  2179                          
  2180  aa4a a950                       lda #<longpokedmalist
  2181  aa4c 8d05d7                     sta $d705
  2182  aa4f 60                         rts
  2183                          
  2184                          longpokedmalist:
  2185                                  ;; MEGA65 Enhanced DMA option list
  2186  aa50 0a                         !8 $0A      ;; Request format is F018A
  2187  aa51 81                         !8 $81
  2188                          longpokedmalist_dest_mb:
  2189  aa52 00                         !8 $00
  2190  aa53 00                         !8 $00 ;; no more enhanced DMA options
  2191                                  ;; F018A dma list
  2192  aa54 03                         !8 $03 ;; FILL, no chain
  2193                                  ;; 1 byte
  2194  aa55 0100                       !16 $0001
  2195                                  ;; source address (LSB = fill value)
  2196                          longpokevalue:
  2197  aa57 00                         !8 $00
  2198  aa58 0000                       !16 $0000
  2199                                  ;; destination address
  2200                          longpokeaddress:
  2201  aa5a 0000                       !16 $0000
  2202  aa5c 0f                         !8 $0F
  2203  aa5d 0000                       !8 $00,00 ;; Modulo
  2204                          
  2205                          
  2206                          ;;         ========================
  2207                          
  2208                          ;; reset memory map to default
  2209                          resetmemmap:
  2210                                  ;; clear memory MAP MB offset register
  2211                                  ;;
  2212  aa5f a900                       lda #$00
  2213  aa61 a20f                       ldx #$0f
  2214  aa63 a000                       ldy #$00   ;; keep hyppo mapped at $8000-$BFFF
  2215  aa65 a33f                       ldz #$3f
  2216                          
  2217  aa67 5c                         map
  2218                          
  2219                                  ;; and clear all mapping
  2220                                  ;;
  2221  aa68 aa                         tax
  2222  aa69 a000                       ldy #$00   ;; keep hyppo mapped at $8000-$BFFF
  2223  aa6b a33f                       ldz #$3f
  2224                          
  2225  aa6d 5c                         map
  2226  aa6e ea                         eom
  2227                          
  2228  aa6f 60                         rts
  2229                          
  2230                          ;;         ========================
  2231                          
  2232                          enhanced_io:
  2233                          
  2234                                  ;; If C=1, enable enhanced IO bank,
  2235                                  ;;   else, return to C64 standard IO map.
  2236                                  ;;
  2237                          
  2238  aa70 b006                       bcs l1
  2239                                  ;; Return to VIC-II / C64 IO
  2240                                  ;;
  2241  aa72 a900                       lda #$00
  2242  aa74 8d2fd0                     sta viciv_magic
  2243  aa77 60                         rts
  2244                          
  2245                          l1:                ;; Enable VIC-IV / MEGA65 IO
  2246                                  ;;
  2247  aa78 a947                       lda #$47
  2248  aa7a 8d2fd0                     sta viciv_magic
  2249  aa7d a953                       lda #$53
  2250  aa7f 8d2fd0                     sta viciv_magic
  2251  aa82 60                         rts
  2252                          
  2253                          
  2254                          ;;         ========================

; ******** Source: keyboard.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          peekkeyboard:
     7                                  ;; We now use hardware-accelerated keyboard reading
     8  aa83 ad10d6                     lda ascii_key_in
     9  aa86 c900                       cmp #$00
    10  aa88 f002                       beq nokey
    11  aa8a 18                         clc
    12  aa8b 60                         rts
    13                          nokey:  ;; no key currently down, so set carry and return
    14  aa8c 38                         sec
    15  aa8d 60                         rts
    16                          
    17                          scankeyboard:
    18  aa8e 2083aa                     jsr peekkeyboard
    19  aa91 c900                       cmp #$00
    20  aa93 f0f7                       beq nokey
    21                                  ;; clear key from buffer
    22  aa95 8d10d6             yeskey: sta ascii_key_in
    23  aa98 18                         clc
    24  aa99 60                         rts

; ******** Source: src/hyppo/main.asm
  2256                          
  2257                          utility_menu_check:
  2258  aa9a ad11d6                     lda buckykey_status
  2259  aa9d c920               	cmp #$20
  2260  aa9f f00c               	beq @startFlashMenu	
  2261  aaa1 c903                       cmp #$03
  2262  aaa3 f005                       beq @startUtilMenu
  2263  aaa5 2910                       and #$10
  2264  aaa7 d001                       bne @startUtilMenu
  2265                          @menuCheckDone:
  2266  aaa9 60                         rts
  2267                          @startUtilMenu:
  2268  aaaa 4c3eab                     jmp utility_menu
  2269                          @startFlashMenu:
  2270                          	;; ... but only if available
  2271  aaad ad19a3             	lda first_boot_flag_instruction
  2272  aab0 c94c               	cmp #$4c
  2273  aab2 f003               	beq @flashMenuNoAvail
  2274  aab4 4c30a3             	jmp launch_flash_menu
  2275                          @flashMenuNoAvail:
  2276  aab7 4c7ea3             	jmp noflash_menu
  2277                          
  2278                          keyboardread:
  2279                          
  2280                          ;; Check for keyboard activity, and change which ROM we intend to read
  2281                          ;; based on that, i.e., holding any key down during boot will load MEGA65<that character>.ROM instead of MEGA65.ROM
  2282                          
  2283  aaba 209aaa                     jsr utility_menu_check
  2284                                  
  2285  aabd a201                       ldx #$01
  2286  aabf ad29d6                     lda $d629
  2287  aac2 2940                       and #$40
  2288  aac4 f002                       beq @startscan
  2289  aac6 a2ff                       ldx #$ff    ;; for nexys-range of boards, repeat check for keyboard input in a short loop
  2290                          
  2291                          @startscan:
  2292  aac8 208eaa                     jsr scankeyboard
  2293  aacb 9006                       bcc @checkkey
  2294                                  
  2295  aacd ca                         dex     ;; no key pressed yet
  2296  aace d0f8                       bne @startscan
  2297  aad0 4ce2aa                     jmp kr2  ;; no key was pressed, despite looping for a while to wait for it
  2298                                  
  2299                          @checkkey:
  2300  aad3 c920                       cmp #$20
  2301  aad5 d003                       bne @notUtilMenu
  2302  aad7 4c3eab                     jmp utility_menu
  2303                          @notUtilMenu:
  2304  aada c930                       cmp #$30
  2305  aadc 9004                       bcc kr2
  2306  aade c939                       cmp #$39
  2307  aae0 9002                       bcc kr1
  2308  aae2 a920               kr2:        lda #$20 ;; default to space
  2309                          kr1:
  2310                                  ;; put character into 6th byte position of ROM file name.
  2311                                  ;; so no key looks for MEGA65.ROM, where as 0-9 will look
  2312                                  ;; for MEGA65x.ROM, where x is the number.
  2313  aae4 a206                       ldx #6
  2314  aae6 c920                       cmp #$20
  2315  aae8 f004                       beq default_rom
  2316  aaea 9d90b2                     sta txt_MEGA65ROM,x
  2317  aaed e8                         inx
  2318                          default_rom:
  2319  aaee a92e                       lda #'.'
  2320  aaf0 9d90b2                     sta txt_MEGA65ROM,x
  2321  aaf3 e8                         inx
  2322  aaf4 a952                       lda #'R'
  2323  aaf6 9d90b2                     sta txt_MEGA65ROM,x
  2324  aaf9 e8                         inx
  2325  aafa a94f                       lda #'O'
  2326  aafc 9d90b2                     sta txt_MEGA65ROM,x
  2327  aaff e8                         inx
  2328  ab00 a94d                       lda #'M'
  2329  ab02 9d90b2                     sta txt_MEGA65ROM,x
  2330  ab05 e8                         inx
  2331  ab06 a900                       lda #0
  2332  ab08 9d90b2                     sta txt_MEGA65ROM,x
  2333                          
  2334  ab0b 60                         rts
  2335                          
  2336                          ;;         ========================
  2337                          
  2338                          hypervisor_nmi:
  2339                          hypervisor_irq:
  2340                                  ;; Default interrupt handlers for hypervisor: for now just mask the
  2341                                  ;; interrupt source.  Later we can have raster splits in the boot
  2342                                  ;; display if we so choose.
  2343  ab0c 78                         sei
  2344  ab0d 40                         rti
  2345                          
  2346                          hypervisor_setup_copy_region:
  2347                                  ;; Hypervisor copy region sit entirely within the first 32KB of
  2348                                  ;; mapped address space. Since we allow a 256 byte copy region,
  2349                                  ;; we limit the start address to the range $0000-$7EFF
  2350                                  ;; XXX - We should also return an error if there is an IO
  2351                                  ;; region mapped there, so that the hypervisor can't be tricked
  2352                                  ;; into doing privileged IO operations as part of the copy-back
  2353                          
  2354  ab0e ad42d6                     lda hypervisor_y
  2355  ab11 300e                       bmi hscr1
  2356  ab13 c97f                       cmp #$7f
  2357  ab15 f00a                       beq hscr1
  2358  ab17 8d07bf                     sta hypervisor_userspace_copy_vector +1
  2359  ab1a a900                       lda #$00
  2360  ab1c 8d06bf                     sta hypervisor_userspace_copy_vector +0
  2361                          
  2362                                  +Checkpoint "hypervisor_setup_copy_region <success>"
  2363                          
  2364  ab1f 38                         sec
  2365  ab20 60                         rts
  2366                          
  2367                          hscr1:
  2368                                  +Checkpoint "hypervisor_setup_copy_region <failure>"
  2369                          
  2370  ab21 a910                       lda #dos_errorcode_invalid_address
  2371  ab23 4c7a92                     jmp dos_return_error
  2372                          
  2373                          ;;         ========================
  2374                          
  2375                          !if DEBUG_HYPPO {
  2376                          
  2377                          checkpoint:
  2378                          
  2379                                  ;; Routine to record the progress of code through the hypervisor for
  2380                                  ;; debugging problems in the hypervisor.
  2381                                  ;; If the JSR checkpoint is followed by $00, then a text string describing the
  2382                                  ;; checkpoint is inserted into the checkpoint log.
  2383                                  ;; Checkpoint data is recorded in the 2nd 16KB of colour RAM.
  2384                          
  2385                                  ;; Save all registers and CPU flags
  2386                                  sta checkpoint_a
  2387                                  stx checkpoint_x
  2388                                  sty checkpoint_y
  2389                                  stz checkpoint_z
  2390                                  php
  2391                                  pla
  2392                                  sta checkpoint_p
  2393                          
  2394                                  ;; pull PC return address from stack
  2395                                  ;; (JSR pushes return_address-1, so add one)
  2396                                  pla
  2397                                  clc
  2398                                  adc #$01
  2399                                  sta checkpoint_pcl
  2400                                  pla
  2401                                  adc #$00
  2402                                  sta checkpoint_pch
  2403                          
  2404                                  ;; Only do checkpoints visibly if shift held during boot
  2405                                  lda buckykey_status
  2406                                  and #$03
  2407                                  beq cp9
  2408                          
  2409                                  ;; Write checkpoint byte values out as hex into message template
  2410                                  ldx checkpoint_a
  2411                                  jsr checkpoint_bytetohex
  2412                                  sty msg_checkpoint_a+0
  2413                                  stx msg_checkpoint_a+1
  2414                          
  2415                                  ldx checkpoint_x
  2416                                  jsr checkpoint_bytetohex
  2417                                  sty msg_checkpoint_x+0
  2418                                  stx msg_checkpoint_x+1
  2419                          
  2420                                  ldx checkpoint_y
  2421                                  jsr checkpoint_bytetohex
  2422                                  sty msg_checkpoint_y+0
  2423                                  stx msg_checkpoint_y+1
  2424                          
  2425                                  ldx checkpoint_z
  2426                                  jsr checkpoint_bytetohex
  2427                                  sty msg_checkpoint_z+0
  2428                                  stx msg_checkpoint_z+1
  2429                          
  2430                                  ldx checkpoint_p
  2431                                  jsr checkpoint_bytetohex
  2432                                  sty msg_checkpoint_p+0
  2433                                  stx msg_checkpoint_p+1
  2434                          
  2435                                  ldx checkpoint_pch
  2436                                  jsr checkpoint_bytetohex
  2437                                  sty msg_checkpoint_pc+0
  2438                                  stx msg_checkpoint_pc+1
  2439                          
  2440                                  ldx checkpoint_pcl
  2441                                  jsr checkpoint_bytetohex
  2442                                  sty msg_checkpoint_pc+2
  2443                                  stx msg_checkpoint_pc+3
  2444                          
  2445                                  ;; Clear out checkpoint message
  2446                                  ldx #59
  2447                                  lda #$20
  2448                          cp4:    sta msg_checkpointmsg,x
  2449                                  dex
  2450                                  bpl cp4
  2451                          cp9:
  2452                                  ;; Read next byte following the return address to see if it is $00,
  2453                                  ;; if so, then also store the $00-terminated text message that follows.
  2454                                  ;; e.g.:
  2455                                  ;;
  2456                                  ;; jsr checkpoint
  2457                                  ;; !8 0,"OPEN DIRECTORY",0
  2458                                  ;;
  2459                                  ;; to record a checkpoint with the string "OPEN DIRECTORY"
  2460                          
  2461                                  ldy #$00
  2462                                  lda (<checkpoint_pcl),y
  2463                          
  2464                                  bne nocheckpointmessage
  2465                          
  2466                                  ;; Copy null-terminated checkpoint string
  2467                                  ldx #$00
  2468                                  iny
  2469                          cp3:    lda (<checkpoint_pcl),y
  2470                                  beq endofcheckpointmessage
  2471                                  sta msg_checkpointmsg,x
  2472                                  inx
  2473                                  iny
  2474                                  cpy #60
  2475                                  bne cp3
  2476                          
  2477                                  ;; flush out any excess bytes at end of message
  2478                          cp44:   lda (<checkpoint_pcl),y
  2479                                  beq endofcheckpointmessage
  2480                                  iny
  2481                                  bra cp44
  2482                          
  2483                          endofcheckpointmessage:
  2484                                  ;; Skip $00 at end of message
  2485                                  iny
  2486                          
  2487                          nocheckpointmessage:
  2488                          
  2489                                  ;; Advance return address following any checkpoint message
  2490                                  tya
  2491                                  clc
  2492                                  adc checkpoint_pcl
  2493                                  sta checkpoint_pcl
  2494                                  lda checkpoint_pch
  2495                                  adc #$00
  2496                                  sta checkpoint_pch
  2497                          
  2498                                  ;; Only do checkpoints visibly if shift key held
  2499                                  lda buckykey_status
  2500                                  and #$03
  2501                                  beq checkpoint_return
  2502                          
  2503                                  ;; output checkpoint message to serial monitor
  2504                                  ldx #0
  2505                                  ;; do not adjust x-reg until label "checkpoint_return"
  2506                          cp5:
  2507                                  ;; wait for uart to be not busy
  2508                                  lda hypervisor_write_char_to_serial_monitor        ;; LSB is busy status
  2509                                  bne cp5                ;; branch if busy (LSB=1)
  2510                          
  2511                                  ;; uart is not busy, so write the char
  2512                                  lda msg_checkpoint,x
  2513                                  sta hypervisor_write_char_to_serial_monitor
  2514                                  inx
  2515                          
  2516                                  cmp #10                ;; compare A-reg with "LineFeed"
  2517                                  bne cp5
  2518                          
  2519                          checkpoint_return:
  2520                                  ;; restore registers
  2521                                  lda checkpoint_p
  2522                                  php
  2523                                  lda checkpoint_a
  2524                                  ldx checkpoint_x
  2525                                  ldy checkpoint_y
  2526                                  ldz checkpoint_z
  2527                                  plp
  2528                          
  2529                                  ;; return by jumping to the
  2530                                  jmp (checkpoint_pcl)
  2531                          
  2532                          ;;         ========================
  2533                          
  2534                          checkpoint_bytetohex:
  2535                          
  2536                                  ;; BG: this is a helper function to convert a HEX-byte to
  2537                                  ;;     its equivalent two-byte char representation
  2538                                  ;;
  2539                                  ;;     input ".X", containing a HEX-byte to convert
  2540                                  ;;   outputs ".X" & ".Y", Y is MSB, X is LSB, print YX
  2541                                  txa
  2542                                  and #$f0
  2543                                  lsr
  2544                                  lsr
  2545                                  lsr
  2546                                  lsr
  2547                                  jsr checkpoint_nybltohex
  2548                                  tay
  2549                                  txa
  2550                                  and #$0f
  2551                                  jsr checkpoint_nybltohex
  2552                                  tax
  2553                                  rts
  2554                          
  2555                          ;;         ========================
  2556                          
  2557                          checkpoint_nybltohex:
  2558                          
  2559                                  and #$0f
  2560                                  ora #$30
  2561                                  cmp #$3a
  2562                                  bcs cpnth1
  2563                                  rts
  2564                          
  2565                          cpnth1: adc #$06
  2566                                  rts
  2567                          
  2568                          } ;; !if DEBUG_HYPPO
  2569                          
  2570                          
  2571                          ;;         ========================
  2572                          ;;       Scan the 32KB colour RAM looking for pre-loaded utilities.
  2573                          ;;       Offer for the user to be able to launch one of them
  2574                          
  2575                          	;; Tell user what to do if they can't access the utility menu
  2576                          noutility_menu:
  2577  ab26 a288                       ldx #<msg_noutilitymenu
  2578  ab28 a0ad                       ldy #>msg_noutilitymenu
  2579  ab2a 2074a8                     jsr printmessage
  2580  ab2d ee20d0             	inc $d020
  2581                          num1:
  2582  ab30 4c30ab             	jmp num1
  2583                          
  2584                          safe_video_mode:
  2585                          	;; No digital audio, just pure DVI
  2586  ab33 a900               	lda #$00
  2587  ab35 8d1ad6             	sta $d61a
  2588                          	;; NTSC
  2589  ab38 a980               	lda #$80
  2590  ab3a 8d6fd0             	sta $d06f
  2591  ab3d 60                 	rts
  2592                          	
  2593                          utility_menu:
  2594                          	;; Gets self-modified to prevent entering utility menu except on first boot
  2595  ab3e 2c26ab             	bit noutility_menu
  2596                          
  2597                          	;; Disable digital audio when utility menu
  2598  ab41 2033ab             	jsr safe_video_mode
  2599                          	
  2600                                  ;; Display GIT commit again, so that it's easy to check commit of a build
  2601  ab44 a258                       ldx #<msg_gitcommit
  2602  ab46 a0b2                       ldy #>msg_gitcommit
  2603  ab48 2074a8                     jsr printmessage
  2604                          
  2605                          	;; Display utility menu message
  2606  ab4b a26f               	ldx #<msg_utilitymenu
  2607  ab4d a0ad                       ldy #>msg_utilitymenu
  2608  ab4f 2074a8                     jsr printmessage
  2609                          
  2610                                  ;; First utility will be number 1
  2611  ab52 a930                       lda #$30
  2612  ab54 8d08bf                     sta zptempv
  2613                          
  2614  ab57 2053ad                     jsr utillist_rewind
  2615                          
  2616                          um1:
  2617  ab5a 201bad                     jsr utillist_validity_check
  2618  ab5d 9030                       bcc utility_end_of_list
  2619                          	
  2620                                  ;; Display utility and assign number
  2621  ab5f a027                       ldy #39
  2622  ab61 a920                       lda #$20
  2623  ab63 99e2ac             um2:    sta msg_utility_item,y
  2624  ab66 88                         dey
  2625  ab67 c002                       cpy #2
  2626  ab69 d0f8                       bne um2
  2627  ab6b c8                         iny
  2628  ab6c ee08bf                     inc zptempv
  2629  ab6f ad08bf                     lda zptempv
  2630  ab72 8de2ac                     sta msg_utility_item
  2631  ab75 a304                       ldz #4
  2632  ab77 eab210             um4:    lda [<zptempv32],z
  2633  ab7a 99e2ac                     sta msg_utility_item,y
  2634  ab7d f004                       beq um3
  2635  ab7f c8                         iny
  2636  ab80 1b                         inz
  2637  ab81 80f4                       bra um4
  2638  ab83 a2e2               um3:    ldx #<msg_utility_item
  2639  ab85 a0ac                       ldy #>msg_utility_item
  2640  ab87 2074a8                     jsr printmessage
  2641                          
  2642  ab8a 200aad                     jsr utillist_next
  2643                          
  2644  ab8d 80cb                       bra um1
  2645                          
  2646                          
  2647                          utility_end_of_list:
  2648                                  ;; XXX Get input from user (accept only numbers 1 - 9)
  2649  ab8f 208eaa                     jsr scankeyboard
  2650  ab92 c9ff                       cmp #$ff
  2651  ab94 f0f9                       beq utility_end_of_list
  2652  ab96 c931                       cmp #$31
  2653  ab98 90f5                       bcc utility_end_of_list
  2654  ab9a c939                       cmp #$39
  2655  ab9c b0f1                       bcs utility_end_of_list
  2656                          
  2657                                  ;; XXX Based on input, find that utility
  2658  ab9e 290f                       and #$f
  2659  aba0 aa                         tax
  2660  aba1 ca                         dex ;; input is 1-9, so subtract one for list beginning at 0
  2661  aba2 2053ad                     jsr utillist_rewind
  2662  aba5 201bad             ueol2:  jsr utillist_validity_check
  2663                                  ;; Select again if first choice invalid
  2664  aba8 90e5                       bcc utility_end_of_list
  2665  abaa ca                         dex
  2666  abab 3005                       bmi ueol1
  2667  abad 200aad                     jsr utillist_next
  2668  abb0 80f3                       bra ueol2
  2669                          ueol1:
  2670                          
  2671  abb2 ee21d0                     inc $d021
  2672                          
  2673                                  ;; XXX - Set hardware protection bits based on utility definition
  2674                                  ;;       (and check that utility memory has not been modified. If modified.
  2675                                  ;;        give an error instead of giving privileges, so that there is no
  2676                                  ;;        privilege escalation vulnerability here.)
  2677                                  ;; XXX - In fact, if the utility memory has been modified, we shouldn't even
  2678                                  ;;       offer the menu at all perhaps?
  2679                          
  2680                                  ;; Load selected utility into memory
  2681                                  ;; length @ offset 36
  2682  abb5 a324                       ldz #36
  2683  abb7 eab210                     lda [<zptempv32],z
  2684  abba 8dd8ac                     sta utility_dmalist_length+0
  2685  abbd 1b                         inz
  2686  abbe eab210                     lda [<zptempv32],z
  2687  abc1 8dd9ac                     sta utility_dmalist_length+1
  2688  abc4 a510                       lda <zptempv32+0
  2689  abc6 18                         clc
  2690  abc7 692c                       adc #44 ;; length of header structure
  2691  abc9 8ddaac                     sta utility_dmalist_srcaddr+0
  2692  abcc a511                       lda <zptempv32+1
  2693  abce 6900                       adc #0
  2694  abd0 8ddbac                     sta utility_dmalist_srcaddr+1
  2695                          
  2696                          	;; We have to call this before initialising OpenROM
  2697  abd3 203cac             	jsr setup_for_openrom
  2698                          	
  2699                                  ;; load address is always $07FF (to skip $0801 header)
  2700                                  ;; start @ zptempv32 + 44
  2701                                  ;; DMA list is from Hypervisor ROM, so DMA list address MB also = $FF
  2702  abd6 a9ff                       lda #$ff
  2703  abd8 8d02d7                     sta $d702
  2704  abdb 8d04d7                     sta $d704
  2705  abde a9ac                       lda #>utility_dmalist
  2706  abe0 8d01d7                     sta $d701
  2707  abe3 a9d1                       lda #<utility_dmalist
  2708  abe5 8d05d7                     sta $d705       ;; Trigger enhanced DMA
  2709                          
  2710                                  ;; clear 16-bit char mode
  2711  abe8 a905                       lda #$05        ;; 0000 0101
  2712  abea 1c54d0                     trb $d054       ;; VIC-IV Control Register C
  2713                          
  2714                                  ;; and 40 bytes (40 8-bit characters) per row.
  2715  abed a928                       lda #<40
  2716  abef 8d58d0                     sta $d058
  2717  abf2 a900                       lda #>40
  2718  abf4 8d59d0                     sta $d059
  2719                          
  2720                                  ;; screen at $0800 for debug
  2721  abf7 a925                       lda #$25
  2722  abf9 8d18d0                     sta $d018
  2723                          
  2724                                  ;; Exit hypervisor, with PC set to entry point of utility
  2725  abfc a326                       ldz #38
  2726  abfe eab210                     lda [<zptempv32],z
  2727  ac01 8d48d6                     sta hypervisor_pcl
  2728  ac04 1b                         inz
  2729  ac05 eab210                     lda [<zptempv32],z
  2730  ac08 8d49d6                     sta hypervisor_pch
  2731                          
  2732  ac0b 20729d                     jsr task_set_c64_memorymap
  2733  ac0e a93f                       lda #$3f
  2734  ac10 8d50d6                     sta hypervisor_cpuport00
  2735  ac13 a936                       lda #$36 ;; IO + Kernel ROM @ $E000 (will be OpenROM KERNAL)
  2736  ac15 8d51d6                     sta hypervisor_cpuport01
  2737                          
  2738                                  ;; Next instruction exits hypervisor to user mode
  2739  ac18 8d7fd6                     sta hypervisor_enterexit_trigger
  2740                          
  2741                          flash_menu:
  2742                          
  2743                          	;; Run the flash menu which is pre-loaded into memory on first boot
  2744                          	;; (in the FPGA BRAM).
  2745                          	;; Also DMA copy our current screen safely somewhere for later restoration	
  2746                          
  2747  ac1b a9ff                       lda #$ff
  2748  ac1d 8d02d7                     sta $d702
  2749                                  ;; lda #$ff
  2750  ac20 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  2751  ac23 a9ac                       lda #>flashmenu_dmalist
  2752  ac25 8d01d7                     sta $d701
  2753                                  ;; Trigger enhanced DMA
  2754  ac28 a981                       lda #<flashmenu_dmalist
  2755  ac2a 8d05d7                     sta $d705
  2756                          
  2757                          	;; FALL THROUGH
  2758                          run_util_in_hypervisor_context:	
  2759                          	;; XXX Move Stack and ZP to normal places, before letting C64 KERNAL loose on
  2760                          	;; Hypervisor memory map!
  2761  ac2d a900               	lda #$00
  2762  ac2f 5b                 	!8 $5B ;; tab
  2763  ac30 a001               	ldy #$01
  2764  ac32 2b                 	!8 $2B ;; tys
  2765                          		
  2766  ac33 203cac             	jsr setup_for_openrom
  2767                          	;; XXX Work around bug in OpenROMs that erases our banner palette when we do this
  2768                          	;; by putting the palette back immediately.
  2769  ac36 202ea8                     jsr setbannerpalette
  2770                          
  2771                          	;; Actually launch freeze menu
  2772  ac39 4c0d08             	jmp $080d
  2773                          	
  2774                          setup_for_openrom:
  2775                          	
  2776                          	;; Bank in KERNAL ROM space so megaflash can run
  2777                          	;; Writing to $01 when ZP is relocated is a bit tricky, as
  2778                          	;; we have to mess about with the Base Register, or force
  2779                          	;; the assembler to do an absolute write.
  2780  ac3c a937               	lda #$37
  2781  ac3e 8d0100             	!8 $8d,$01,$00 ;; ABS STA $0001
  2782                          
  2783                          	;; We should also reset video mode to normal
  2784  ac41 a997               	lda #$97
  2785  ac43 1c54d0             	trb $d054
  2786                          
  2787                          	;; Clear memory map at $4000-5FFF
  2788                          	;; (Why on earth do we even map some of the HyperRAM there, anyway???)
  2789  ac46 a900               	lda #0
  2790  ac48 aa                 	tax
  2791  ac49 a8                 	tay
  2792  ac4a a33f               	ldz #$3f
  2793  ac4c 5c                 	map
  2794  ac4d ea                 	eom
  2795                          	;; And set MB low to $00, so that OpenROM doesn't jump into lala land
  2796  ac4e a900               	lda #0
  2797  ac50 a20f               	ldx #$0f
  2798  ac52 5c                 	map
  2799  ac53 ea                 	eom	
  2800                          
  2801                          	;; Tell KERNAL screen is at $0400
  2802  ac54 a904               	lda #>$0400
  2803  ac56 8d8802             	sta $0288
  2804                          
  2805  ac59 adf9ff             	lda $fff9
  2806  ac5c c9ff               	cmp #$ff
  2807  ac5e f003               	beq @notOpenROM
  2808                          	;; OpenROMs setup (XXX Won't work with Commodore C65 ROMs!)
  2809  ac60 22f8ff             	jsr ($fff8)
  2810                          @notOpenROM:
  2811                          	;; make sure not in quote mode etc
  2812  ac63 a900               	lda #$00
  2813  ac65 85d8               	sta $d8 ;; number of insertions outstanding = 0
  2814  ac67 850f               	sta $0f ;; clear quote mode
  2815                          
  2816                          	;; Clear common interrupt sources
  2817                          
  2818                          	;; CIAs
  2819                          ;;	lda #$ff
  2820                          ;;	sta $dc0d
  2821                          ;;	sta $dd0d
  2822                          ;;	lda $dc0d
  2823                          ;;	lda $dd0d
  2824                          
  2825                          	;; VIC-IV
  2826                          ;;	dec $d019
  2827                          ;;	lda #$00
  2828                          ;;	sta $d01a
  2829                          
  2830                          	;; Ethernet
  2831                          ;;	lda #$00
  2832                          ;;	sta $d6e1
  2833                          
  2834                          	;; C65 UART
  2835                          	;; XXX Actually it can't generate interrupts yet, so nothing to do :)
  2836                          
  2837                          	;; Finally, clear any pending interrupts by using MAP instruction
  2838                          ;;	tax
  2839                          ;;	tay
  2840                          ;;	taz
  2841                          ;;	map
  2842                          ;;	lda #0    ;; to give time to effect clearing irq_pending in CPU
  2843                          ;;	eom
  2844                          	
  2845                          	;; And ignore any queued NMI (these don't get cleared by the MAP trick)
  2846                          
  2847                          	;;  Clear pending NMI flag
  2848  ac69 ad7dd6                     lda hypervisor_feature_enables
  2849  ac6c 297f               	and #$7f
  2850  ac6e 8d7dd6                     sta hypervisor_feature_enables
  2851                          
  2852                          	;; Set safety-net NMI handler
  2853  ac71 a940               	lda #$40
  2854  ac73 8d2004             	sta $0420
  2855  ac76 a920               	lda #<$0420
  2856  ac78 8d1803             	sta $0318
  2857  ac7b a904               	lda #>$0420
  2858  ac7d 8d1903             	sta $0319	
  2859  ac80 60                 	rts
  2860                          
  2861                          flashmenu_dmalist:
  2862                                  ;; copy $50000-$577FF to $00007FF-$0007FFFF
  2863                          
  2864                                  ;; MEGA65 Enhanced DMA options
  2865  ac81 0a                         !8 $0A      ;; Request format is F018A
  2866  ac82 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2867  ac84 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2868                          
  2869                          	;; Copy screen from $0400-$0BFF to $00009000
  2870  ac86 00                         !8 $00 ;; no more options
  2871                                  ;; F018A DMA list
  2872  ac87 04                         !8 $04 ;; copy + chained
  2873  ac88 0008                       !16 $0800 ;; size of copy 
  2874  ac8a 0004                       !16 $0400 ;; starting addr 
  2875  ac8c 00                         !8 $00   ;; of bank $0
  2876  ac8d 0090                       !16 $9000 ;; destination address is $8000
  2877  ac8f 00                         !8 $00   ;; of bank $5
  2878  ac90 0000                       !16 $0000 ;; modulo (unused)
  2879                          
  2880                          	;; Copy program down
  2881  ac92 00                         !8 $00 ;; no more options
  2882                          	;; F018A DMA list
  2883  ac93 00                         !8 $00 ;; copy + not chained request
  2884  ac94 ff77                       !16 $77FF ;; size of copy 
  2885  ac96 0000                       !16 $0000 ;; starting addr 
  2886  ac98 05                         !8 $05   ;; of bank $5
  2887  ac99 ff07                       !16 $07FF ;; destination address is $0801 - 2
  2888  ac9b 00                         !8 $00   ;; of bank $0
  2889  ac9c 0000                       !16 $0000 ;; modulo (unused)
  2890                          
  2891                          screenrestore_dmalist:
  2892  ac9e 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2893  aca0 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2894  aca2 00                         !8 $00 ;; no more options
  2895                                  ;; F018A DMA list
  2896  aca3 00                         !8 $00 ;; copy + last in chain
  2897  aca4 0008                       !16 $0800 ;; size of copy 
  2898  aca6 0090                       !16 $9000 ;; destination address is $0000
  2899  aca8 00                         !8 $00   ;; of bank $0
  2900  aca9 0004                       !16 $0400 ;; starting addr 
  2901  acab 00                         !8 $00   ;; of bank $5
  2902  acac 0000                       !16 $0000 ;; modulo (unused)
  2903                          
  2904                          scroll_screen:
  2905                          	
  2906  acae a9ff                       lda #$ff
  2907  acb0 8d02d7                     sta $d702
  2908  acb3 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  2909                          
  2910                          	;; Don't forget to reset colour RAM also
  2911  acb6 a9ac                       lda #>scrollscreen_dmalist
  2912  acb8 8d01d7                     sta $d701
  2913                                  ;; set bottom 8 bits of address and trigger DMA.
  2914                                  ;;
  2915  acbb a9c1                       lda #<scrollscreen_dmalist
  2916  acbd 8d05d7                     sta $d705
  2917                          
  2918  acc0 60                 	rts
  2919                          	
  2920                          scrollscreen_dmalist:
  2921  acc1 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2922  acc3 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2923  acc5 00                         !8 $00 ;; no more options
  2924                                  ;; F018A DMA list
  2925  acc6 00                         !8 $00 ;; copy + last in chain
  2926  acc7 0005                       !16 1280 ;; size of copy  ( (17-1) * 40 * 2 )
  2927  acc9 d006                       !16 1744 ;; src address is line 9 of screen
  2928  accb 00                         !8 $00   ;; of bank $0
  2929  accc 8006                       !16 1664 ;; starting addr is line 8 of screen
  2930  acce 00                         !8 $00   ;; of bank $0
  2931  accf 0000                       !16 $0000 ;; modulo (unused)
  2932                          	
  2933                          	
  2934                          utility_dmalist:
  2935                                  ;; copy $FF8xxxx-$FF8yyyy to $00007FF-$000xxxx
  2936                          
  2937                                  ;; MEGA65 Enhanced DMA options
  2938  acd1 0a                         !8 $0A      ;; Request format is F018A
  2939  acd2 80ff                       !8 $80,$FF  ;; Copy from $FFxxxxx
  2940  acd4 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2941  acd6 00                         !8 $00 ;; no more options
  2942                                  ;; F018A DMA list
  2943  acd7 00                         !8 $00 ;; copy + last request in chain
  2944                          utility_dmalist_length:
  2945  acd8 ffff                       !16 $FFFF ;; size of copy  (gets overwritten)
  2946                          utility_dmalist_srcaddr:
  2947  acda ffff                       !16 $FFFF ;; starting addr (gets overwritten)
  2948  acdc 08                         !8 $08   ;; of bank $8
  2949  acdd ff07                       !16 $07FF ;; destination address is $0801 - 2
  2950  acdf 00                         !8 $00   ;; of bank $0
  2951  ace0 0000                       !16 $0000 ;; modulo (unused)
  2952                          
  2953                          
  2954                          msg_utility_item:
  2955  ace2 312e203332204348...        !text "1. 32 CHARACTERS OF UTILITY NAME...    "
  2956  ad09 00                         !8 0
  2957                          
  2958                          utillist_next:
  2959                          
  2960                                  ;; Advance pointer to the next pointer
  2961  ad0a a32a                       ldz #42
  2962  ad0c eab210                     lda [<zptempv32],z
  2963  ad0f da                         phx
  2964  ad10 aa                         tax
  2965  ad11 1b                         inz
  2966  ad12 eab210                     lda [<zptempv32],z
  2967                                  ;; XXX - Make sure it can't point earlier into the colour RAM here
  2968                          
  2969  ad15 8511                       sta <zptempv32+1
  2970  ad17 8610                       stx <zptempv32
  2971  ad19 fa                         plx
  2972  ad1a 60                         rts
  2973                          
  2974                          utillist_validity_check:
  2975                                  ;; See if this is a valid utility entry
  2976  ad1b a300                       ldz #0
  2977                          
  2978                                  ;; Check for magic value
  2979  ad1d eab210                     lda [<zptempv32],z
  2980  ad20 c94d                       cmp #'M'
  2981  ad22 d02d                       bne ulvc_fail
  2982  ad24 1b                         inz
  2983  ad25 eab210                     lda [<zptempv32],z
  2984  ad28 c936                       cmp #'6'
  2985  ad2a d025                       bne ulvc_fail
  2986  ad2c 1b                         inz
  2987  ad2d eab210                     lda [<zptempv32],z
  2988  ad30 c935                       cmp #'5'
  2989  ad32 d01d                       bne ulvc_fail
  2990  ad34 1b                         inz
  2991  ad35 eab210                     lda [<zptempv32],z
  2992  ad38 c955                       cmp #'U'
  2993  ad3a d015                       bne ulvc_fail
  2994                          
  2995                                  ;; Check self address
  2996  ad3c a328                       ldz #40
  2997  ad3e eab210                     lda [<zptempv32],z
  2998  ad41 cd10bf                     cmp zptempv32
  2999  ad44 d00b                       bne ulvc_fail
  3000  ad46 1b                         inz
  3001  ad47 eab210                     lda [<zptempv32],z
  3002  ad4a cd11bf                     cmp zptempv32+1
  3003  ad4d d002                       bne ulvc_fail
  3004                          
  3005                                  ;; success
  3006  ad4f 38                         sec
  3007  ad50 60                         rts
  3008                          
  3009                          ulvc_fail:
  3010  ad51 18                         clc
  3011  ad52 60                         rts
  3012                          
  3013                          utillist_rewind:
  3014                          
  3015                                  ;; Set pointer to first entry in colour RAM ($0850)
  3016  ad53 a950                       lda #<$0850
  3017  ad55 8510                       sta <zptempv32
  3018  ad57 a908                       lda #>$0850
  3019  ad59 8511                       sta <(zptempv32+1)
  3020  ad5b a9f8                       lda #<$0FF8
  3021  ad5d 8512                       sta <(zptempv32+2)
  3022  ad5f a90f                       lda #>$0FF8
  3023  ad61 8513                       sta <(zptempv32+3)
  3024                          
  3025  ad63 60                         rts
  3026                          
  3027                          serialwrite:
  3028                                  ;; write character to serial port
  3029                          
  3030                          	;; First wait for it to go ready
  3031  ad64 ae7cd6             	ldx hypervisor_write_char_to_serial_monitor
  3032  ad67 d0fb               	bne serialwrite
  3033                          	
  3034                                  ;; XXX - Have some kind of permission control on this
  3035                                  ;; XXX - $D67C should not work when matrix mode is enabled at all?
  3036  ad69 8d7cd6                     sta hypervisor_write_char_to_serial_monitor
  3037  ad6c 8d7fd6                     sta hypervisor_enterexit_trigger
  3038                          
  3039                          ;;         ========================
  3040                          
  3041                          !if DEBUG_HYPPO {
  3042                          
  3043                          ;; checkpoint message
  3044                          
  3045                          msg_checkpoint:         !text "$"
  3046                          msg_checkpoint_pc:      !text "%%%% A:"
  3047                          msg_checkpoint_a:       !text "%%, X:"
  3048                          msg_checkpoint_x:       !text "%%, Y:"
  3049                          msg_checkpoint_y:       !text "%%, Z:"
  3050                          msg_checkpoint_z:       !text "%%, P:"
  3051                          msg_checkpoint_p:       !text "%% :"
  3052                          msg_checkpointmsg:      !text "                                                             " ;; END_OF_STRING
  3053                                                  !8 13,10  ;; CR/LF
  3054                          
  3055                          }
  3056                          
  3057                          ;;         ========================
  3058                          
  3059                          msg_checkpoint_eom:
  3060                          
  3061                          ;; messages all have to be <=40 bytes long
  3062                          
  3063                          msg_utilitymenu:
  3064  ad6f 53454c4543542055...        !text "SELECT UTILITY TO LAUNCH"
  3065  ad87 00                         !8 0
  3066                          
  3067                          msg_noutilitymenu:	
  3068  ad88 484f4c4420414c54...		        !text "HOLD ALT + POWER CYCLE FOR UTILITY MENU"
  3069  adaf 00                 	                !8 0
  3070                          	
  3071                          msg_noflashmenu:	
  3072  adb0 484f4c44204e4f20...		        !text "HOLD NO SCROLL + POWER CYCLE FOR FLASH"
  3073  add6 00                 	                !8 0
  3074                          	
  3075  add7 52452d545259494e...msg_retryreadmbr:       !text "RE-TRYING TO READ MBR"
  3076  adec 00                                         !8 0
  3077  aded 4d4547413635204d...msg_hyppo:              !text "MEGA65 MEGAOS HYPERVISOR V00.16"
  3078  ae0c 00                                         !8 0
  3079  ae0d 4e4f205343524f4c...msg_hyppohelpfirst:     !text "NO SCROLL=FLASH, ALT=UTILS, CTRL=HOLD"
  3080  ae32 00                                         !8 0
  3081  ae33 504f574552204f46...msg_hyppohelpnotfirst:  !text "POWER OFF/ON FOR FLASH OR UTIL MENU"
  3082  ae56 00                                         !8 0
  3083  ae57 524f4d2043484543...msg_romok:              !text "ROM CHECKSUM OK - BOOTING"
  3084  ae70 00                                         !8 0
  3085                          ;; msg_rombad:          !text "ROM CHECKSUM FAIL - LOADING ROMS"
  3086                          ;;                      !8 0
  3087                          ;; msg_charrombad:      !text "COULD NOT LOAD CHARROM.M65"
  3088                          ;;                      !8 0
  3089  ae71 4c4f414445442043...msg_charromloaded:      !text "LOADED CHARROM.M65 ($$$$ PAGES)"
  3090  ae90 00                                         !8 0
  3091  ae91 4c4f41444544204d...msg_megaromloaded:      !text "LOADED MEGA65.ROM ($$$$ PAGES)"
  3092  aeaf 00                                         !8 0
  3093  aeb0 4c4f4f4b494e4720...msg_tryingsdcard:       !text "LOOKING FOR SDHC CARD >=4GB..."
  3094  aece 00                                         !8 0
  3095  aecf 5344204341524420...msg_foundsdcard:        !text "SD CARD IS NOT SDHC. MUST BE SDHC."
  3096  aef1 00                                         !8 0
  3097  aef2 464f554e4420414e...msg_foundsdhccard:      !text "FOUND AND RESET SDHC CARD"
  3098  af0b 00                                         !8 0
  3099  af0c 4552524f52205245...msg_sdcarderror:        !text "ERROR READING FROM SD CARD"
  3100  af26 00                                         !8 0
  3101  af27 52452d5245414449...msg_sdredoread:         !text "RE-READING SDCARD"
  3102  af38 00                                         !8 0
  3103  af39 4e4f205344434152...msg_nosdcard:           !text "NO SDCARD, TRYING BUILT-IN ROM"
  3104  af57 00                                         !8 0
  3105  af58 424144204d425220...msg_badformat:          !text "BAD MBR OR DOS BOOT SECTOR."
  3106  af73 00                                         !8 0
  3107  af74 5245414420504152...msg_sdcardfound:        !text "READ PARTITION TABLE FROM SDCARD"
  3108  af94 00                                         !8 0
  3109  af95 464f554e4420524f...msg_foundromfile:       !text "FOUND ROM FILE. START CLUSTER = $$$$$$$$"
  3110  afbd 00                                         !8 0
  3111  afbe 4449534b2d434f55...msg_diskcount:          !text "DISK-COUNT=$$, DEFAULT-DISK=$$"
  3112  afdc 00                                         !8 0
  3113                          ;; msg_diskdata0:       !text "DISK-TABLE:"
  3114                          ;;                      !8 0
  3115                          ;; msg_diskdata:        !text "BB$$:$$.$$.$$.$$.$$.$$.$$.$$"
  3116                          ;;                      !8 0
  3117  afdd 4c4f4f4b494e4720...msg_filelengths:        !text "LOOKING FOR $$ BYTES, I SEE $$ BYTES"
  3118  b001 00                                         !8 0
  3119  b002 434f554c44204e4f...msg_fileopenerror:      !text "COULD NOT OPEN ROM FILE FOR READING"
  3120  b025 00                                         !8 0
  3121  b026 52454144494e4720...msg_readingfile:        !text "READING ROM FILE..."
  3122  b039 00                                         !8 0
  3123  b03a 524f4d20544f4f20...msg_romfilelongerror:   !text "ROM TOO LONG: (READ $$$$ PAGES)"
  3124  b059 00                                         !8 0
  3125  b05a 524f4d20544f4f20...msg_romfileshorterror:  !text "ROM TOO SHORT: (READ $$$$ PAGES)"
  3126  b07a 00                                         !8 0
  3127  b07b 43555252454e5420...msg_clusternumber:      !text "CURRENT CLUSTER=$$$$$$$$"
  3128  b093 00                                         !8 0
  3129  b094 43555252454e5420...msg_sectoraddress:      !text "CURRENT SECTOR= $$$$$$$$"
  3130  b0ac 00                                         !8 0
  3131  b0ad 43414e4e4f54204d...msg_nod81:              !text "CANNOT MOUNT D81 - (ERRNO: $$)"
  3132  b0cb 00                                         !8 0
  3133  b0cc 4438312053554343...msg_d81mounted:         !text "D81 SUCCESSFULLY MOUNTED"
  3134  b0e4 00                                         !8 0
  3135  b0e5 52454c4541534520...msg_releasectrl:        !text "RELEASE CONTROL TO CONTINUE BOOTING."
  3136  b109 00                                         !8 0
  3137  b10a 535733204f464620...msg_dipswitch3on:       !text "SW3 OFF OR PRESS RUN/STOP TO CONTINUE."
  3138  b130 00                                         !8 0
  3139  b131 434f554c44204e4f...msg_romnotfound:        !text "COULD NOT FIND ROM MEGA65XXROM"
  3140  b14f 00                                         !8 0
  3141  b150 4c4f4144494e4720...msg_foundhickup:        !text "LOADING HICKUP.M65 INTO HYPERVISOR"
  3142  b172 00                                         !8 0
  3143  b173 434f554c44204e4f...msg_no1541rom:          !text "COULD NOT LOAD 1541ROM.M65"
  3144  b18d 00                                         !8 0
  3145                          ;; msg_nohickup:        !text "NO HICKUP.M65 TO LOAD (OR BROKEN)"
  3146                          ;;                      !8 0
  3147                          ;; msg_hickuploaded:    !text "HICKUP LOADED TO 00004000 - $$$$$$$$"
  3148                          ;;                      !8 0
  3149  b18e 52554e4e494e4720...msg_alreadyhicked:      !text "RUNNING HICKED HYPERVISOR"
  3150  b1a7 00                                         !8 0
  3151                          msg_lookingfornextsector:
  3152  b1a8 4c4f4f4b494e4720...                        !text "LOOKING FOR NEXT SECTOR OF FILE"
  3153  b1c7 00                                         !8 0
  3154  b1c8 434f554c44204e4f...msg_nologo:             !text "COULD NOT LOAD BANNER.M65 (ERRNO:$$)"
  3155  b1ec 00                                         !8 0
  3156  b1ed 434f554c44204e4f...msg_cdrootfailed:       !text "COULD NOT CHDIR TO / (ERRNO:$$)"
  3157  b20c 00                                         !8 0
  3158  b20d 545259494e472053...msg_tryingcard0:        !text "TRYING SDCARD BUS 0"
  3159  b220 00                                         !8 0
  3160  b221 5553494e47205344...msg_usingcard1:         !text "USING SDCARD BUS 1"
  3161  b233 00                                         !8 0
  3162  b234 444d414749432052...msg_dmagica:            !text "DMAGIC REV A MODE"
  3163  b245 00                                         !8 0
  3164  b246 444d414749432052...msg_dmagicb:            !text "DMAGIC REV B MODE"
  3165  b257 00                                         !8 0
  3166                          	
  3167                          ;; Include the GIT Message as a string

; ******** Source: ../version.asm
     1                          msg_gitcommit:
     2  b258 4749543a20687773...	!text "GIT: hwsc,20211221.19,d894bf4~"
     3  b276 00                 	!8 0

; ******** Source: src/hyppo/main.asm
  3169                          
  3170  b277 00                 msg_blankline:          !8 0
  3171                          
  3172                          ;;         ========================
  3173                                      ;; filename of 1541 ROM
  3174  b278 31353431524f4d2e...txt_1541ROM:            !text "1541ROM.M65"
  3175  b283 00                                         !8 0
  3176                          
  3177                                      ;; filename of character ROM
  3178  b284 43484152524f4d2e...txt_CHARROMM65:         !text "CHARROM.M65"
  3179  b28f 00                                         !8 0
  3180                          
  3181                                      ;; filename of ROM we want to load in FAT directory format
  3182                                      ;; (the two zero bytes are so that we can insert an extra digit after
  3183                                      ;; the 5, when a user presses a key, so that they can choose a
  3184                                      ;; different ROM to load).
  3185                                      ;;
  3186  b290 4d45474136352e52...txt_MEGA65ROM:          !text "MEGA65.ROM"
  3187  b29a 0000                                       !8 0,0
  3188                          
  3189                                      ;; filename of 1581 disk image we mount by default
  3190                                      ;;
  3191  b29c 4d45474136352e44...txt_MEGA65D81:          !text "MEGA65.D81"
  3192  b2a6 00000000000000                             !8 0,0,0,0,0,0,0
  3193                          
  3194                                      ;; filename of hyppo update file
  3195                                      ;;
  3196  b2ad 4849434b55502e4d...txt_HICKUPM65:          !text "HICKUP.M65"
  3197  b2b7 00                                         !8 0
  3198                          
  3199                                      ;; filename containing boot logo
  3200                                      ;;
  3201  b2b8 42414e4e45522e4d...txt_BOOTLOGOM65:        !text "BANNER.M65"
  3202  b2c2 00                                         !8 0
  3203                          
  3204                                      ;; filename containing freeze menu
  3205  b2c3 465245455a45522e...txt_FREEZER:            !text "FREEZER.M65"
  3206  b2ce 00                                         !8 0
  3207                          
  3208                                      ;; If this file is present, then machine starts up with video
  3209                                      ;; mode set to NTSC (60Hz), else as PAL (50Hz).
  3210                                      ;; This is to allow us to boot in PAL by default, except for
  3211                                      ;; those who have a monitor that cannot do 50Hz.
  3212  b2cf 4e545343           txt_NTSC:               !text "NTSC"
  3213  b2d3 00                                         !8 0
  3214                          
  3215                          ;;         ========================
  3216                          
  3217                          !if DEBUG_HYPPO {
  3218                                  !src "debug.asm"
  3219                          }
  3220                          
  3221                          ;;         ========================
  3222                          
  3223                                  ;; Table of available disks.
  3224                                  ;; Include native FAT32 disks, as well as (in the future at least)
  3225                                  ;; mounted .D41, .D71, .D81 and .DHD files using Commodore DOS filesystems.
  3226                                  ;; But for now, we are supporting only FAT32 as the filesystem.
  3227                                  ;; See hyppo_dos.asm for information on how the table is used.
  3228                                  ;; Entries are 32 bytes long, so we can have 6 of them.
  3229                                  ;;
  3230                                  dos_max_disks = 6
  3231                          
  3232                                  ;; .segment DOSDiskTable
  3233                                  * = DOSDiskTable_Start
  3234                          dos_disk_table:
  3235                          
  3236                                  ;; .segment SysPartStructure
  3237                                  * = SysPartStructure_Start
  3238                          
  3239                          syspart_structure:
  3240                          
  3241                          syspart_start_sector:
  3242  bbc0 00000000                   !8 0,0,0,0
  3243                          syspart_size_in_sectors:
  3244  bbc4 00000000                   !8 0,0,0,0
  3245                          syspart_reserved:
  3246  bbc8 0000000000000000           !8 0,0,0,0,0,0,0,0
  3247                          
  3248                          ;; For fast freezing/unfreezing, we have a number of contiguous
  3249                          ;; freeze slots that can each store the state of the machine
  3250                          ;; We note where the area begins, how big it is, how many slots
  3251                          ;; it has, and how many sectors are used at the start of the area
  3252                          ;; to hold a directory with 128 bytes per slot, the contains info
  3253                          ;; about the frozen program.
  3254                          syspart_freeze_area_start:
  3255  bbd0 00000000                   !8 0,0,0,0
  3256                          syspart_freeze_area_size_in_sectors:
  3257  bbd4 00000000                   !8 0,0,0,0
  3258                          syspart_freeze_slot_size_in_sectors:
  3259  bbd8 00000000                   !8 0,0,0,0
  3260                          syspart_freeze_slot_count:
  3261  bbdc 0000                       !8 0,0
  3262                          syspart_freeze_directory_sector_count:
  3263  bbde 0000                       !8 0,0
  3264                          
  3265                                  ;; The first 64 freeze slots are reserved for various purposes
  3266                                 syspart_freeze_slots_reserved  = 64
  3267                                  ;; Freeze slot 0 is used when the hypervisor needs to
  3268                                  ;; temporarily shove all or part of the active process out
  3269                                  ;; the way to do something
  3270                                 freeze_slot_temporary = 0
  3271                          
  3272                                  ;; Freeze slots 1 - 63 are currently reserved
  3273                                  ;; They will likely get used for a service call-stack
  3274                                  ;; among other purposes.
  3275                          
  3276                                  ;; We then have a similar area for system services, which are stored
  3277                                  ;; using much the same representation, but are used as helper
  3278                                  ;; programs.
  3279                          syspart_service_area_start:
  3280  bbe0 00000000                   !8 0,0,0,0
  3281                          syspart_service_area_size_in_bytes:
  3282  bbe4 00000000                   !8 0,0,0,0
  3283                          syspart_service_slot_size_in_bytes:
  3284  bbe8 00000000                   !8 0,0,0,0
  3285                          syspart_service_slot_count:
  3286  bbec 0000                       !8 0,0
  3287                          syspart_service_directory_sector_count:
  3288  bbee 0000                       !8 0,0
  3289                          
  3290                          ;; /*  -------------------------------------------------------------------
  3291                          ;;     Hypervisor DOS work area and scratch pad at $BC00-$BCFF
  3292                          ;;     ---------------------------------------------------------------- */
  3293                          
  3294                                  ;; .segment DOSWorkArea
  3295                                  * = DOSWorkArea_Start
  3296                          
  3297                          hyppo_scratchbyte0:
  3298  bc00 00                         !8 $00
  3299                          
  3300                                  ;; The number of disks we have
  3301                                  ;;
  3302                          dos_disk_count:
  3303  bc01 00                         !8 $00
  3304                          
  3305                                  ;; The default disk
  3306                                  ;;
  3307                          dos_default_disk:
  3308  bc02 00                         !8 $00
  3309                          
  3310                                  ;; The current disk
  3311                                  ;;
  3312                          dos_disk_current_disk:
  3313  bc03 00                         !8 $00
  3314                          
  3315                                  ;; Offset of current disk entry in disk table
  3316                                  ;;
  3317                          dos_disk_table_offset:
  3318  bc04 00                         !8 $00
  3319                          
  3320                                  ;; cluster of current directory of current disk
  3321                                  ;;
  3322                          dos_disk_cwd_cluster:
  3323  bc05 00000000                   !8 0,0,0,0
  3324                          
  3325                          ;;         ========================
  3326                          
  3327                                  ;; Current point in open directory
  3328                                  ;;
  3329                          dos_opendir_cluster:
  3330  bc09 00000000                   !8 0,0,0,0
  3331                          dos_opendir_sector:
  3332  bc0d 00                         !8 0
  3333                          dos_opendir_entry:
  3334  bc0e 00                         !8 0
  3335                          
  3336                          ;;         ========================
  3337                          
  3338                                  ;; WARNING: dos_readdir_read_next_entry uses carnal knowledge about the following
  3339                                  ;;          structure, particularly the length as calculated here:
  3340                                  ;;
  3341                                  dos_dirent_structure_length = dos_dirent_struct_end - dos_dirent_struct_start
  3342                          
  3343                                  ;; Current long filename (max 64 bytes)
  3344                                  ;;
  3345                          dos_dirent_struct_start:	
  3346                          dos_dirent_longfilename:
  3347  bc0f 56656e657a75616c...        !text "Venezualen casaba melon productio" ;; 33-chars
  3348  bc30 6e20737461746973...        !text "n statistics (2012-2015).txt  "    ;; 30-chars
  3349  bc4e 00                         !8 0
  3350                          
  3351                          dos_dirent_longfilename_length:
  3352  bc4f 00                         !8 0
  3353                          
  3354                          dos_dirent_shortfilename:
  3355  bc50 46494c454e414d45...        !text "FILENAME.EXT"
  3356  bc5c 00                         !8 0
  3357                          
  3358                          dos_dirent_cluster:
  3359  bc5d 00000000                   !8 0,0,0,0
  3360                          
  3361                          dos_dirent_length:
  3362  bc61 00000000                   !8 0,0,0,0
  3363                          
  3364                          dos_dirent_type_and_attribs:
  3365  bc65 00                         !8 0
  3366                          dos_dirent_struct_end:	
  3367                          
  3368                          ;;         ========================
  3369                          
  3370                                  ;; Requested file name and length
  3371                                  ;;
  3372                          dos_requested_filename_len:
  3373  bc66 00                         !8 0
  3374                          
  3375                          dos_requested_filename:
  3376  bc67 56656e657a75616c...        !text "Venezualen casaba melon productio"
  3377  bc88 6e20737461746973...        !text "n statistics (2007-2011).txt     "
  3378                          
  3379                          ;;         ========================
  3380                          
  3381                                  ;; Details about current DOS request
  3382                                  ;;
  3383  bca9 0000               dos_sectorsread:                !16 0
  3384  bcab 00000000           dos_bytes_remaining:            !16 0,0
  3385  bcaf 00000000           dos_current_sector:             !16 0,0
  3386  bcb3 00000000           dos_current_cluster:            !16 0,0
  3387  bcb7 00                 dos_current_sector_in_cluster:  !8 0
  3388                          
  3389                          ;; Current file descriptors
  3390                          ;; Each descriptor has:
  3391                          ;;   disk id : 1 byte ($00-$07 = file open, $FF = file closed)
  3392                          ;;   access mode : 1 byte ($00 = read only)
  3393                          ;;   start cluster : 4 bytes
  3394                          ;;   current cluster : 4 bytes
  3395                          ;;   current sector in cluster : 1 byte
  3396                          ;;   offset in sector: 2 bytes
  3397                          ;;   file offset / $100 : 3 bytes
  3398                          ;;
  3399                                  dos_filedescriptor_max = 4
  3400                                  dos_filedescriptor_offset_diskid = 0
  3401                                  dos_filedescriptor_offset_mode = 1
  3402                                  dos_filedescriptor_offset_startcluster = 2
  3403                                  dos_filedescriptor_offset_currentcluster = 6
  3404                          ;;
  3405                          ;; These last three fields must be contiguous, as dos_open_current_file
  3406                          ;; relies on it.
  3407                          ;;
  3408                                  dos_filedescriptor_offset_sectorincluster = 10
  3409                                  dos_filedescriptor_offset_offsetinsector = 11
  3410                                  dos_filedescriptor_offset_fileoffset = 13
  3411                          
  3412                          dos_file_descriptors:
  3413  bcb8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        ;; each is 16 bytes
  3414  bcc8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3415  bcd8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3416  bce8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3417                          
  3418                              ;; The current file descriptor
  3419                              ;;
  3420                          dos_current_file_descriptor:
  3421  bcf8 00                         !8 0
  3422                          
  3423                              ;; Offset of current file descriptor
  3424                              ;;
  3425                          dos_current_file_descriptor_offset:
  3426  bcf9 00                         !8 0
  3427                          
  3428                          ;;         ========================
  3429                          
  3430                              ;; For providing feedback on why DOS calls have failed
  3431                              ;; There is a set of error codes defined in hyppo_dos.asm
  3432                          dos_error_code:
  3433  bcfa 00                         !8 $00
  3434                          
  3435                              ;; Similarly for system partition related errors
  3436                          syspart_error_code:
  3437  bcfb 00                         !8 $00
  3438                          
  3439                              ;; Non-zero if there is a valid system partition
  3440                          syspart_present:
  3441  bcfc 00                         !8 $00
  3442                          
  3443                          ;; /*  -------------------------------------------------------------------
  3444                          ;;     Reserved space for Hypervisor Process work area $BD00-$BDFF
  3445                          ;;     ---------------------------------------------------------------- */
  3446                                  ;; .segment ProcessDescriptors
  3447                                  * = ProcessDescriptors_Start
  3448                          

; ******** Source: process_descriptor.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; Process descriptor block (fixed 256 bytes)
     7                                  ;;
     8                                  ;; This needs to have information about the current running task,
     9                                  ;; and also hold information about the current open files, if any.
    10                          
    11                                  ;; Process description (first 128 bytes)
    12                          
    13                          	start = *
    14                          currenttask_block:
    15                          
    16                                  ;; Tasks are idenfied by what amounts to an 8-bit process id.
    17                                  ;; Process ID #$FF is special, and indicates that it is the operating system/hypervisor
    18                                  ;; that is active.  This affects how results are return from system calls, so that they
    19                          
    20                          currenttask_id:
    21  bd00 ff                         !8 $FF
    22                          
    23                                  ;; Name of task (16 characters, unused characters should be null)
    24                          
    25                          currenttask_name:
    26  bd01 4f5045524154494e...        !text "OPERATING SYSTEM"
    27                          
    28                          currenttask_d81_image0_flags:
    29  bd11 00                         !8 0
    30                          currenttask_d81_image1_flags:
    31  bd12 00                         !8 0
    32                          
    33                                  ;; File names of currently mounted disk images (32 character max length)
    34                          currenttask_d81_image0_namelen:
    35  bd13 00                         !8 0
    36                          currenttask_d81_image1_namelen:
    37  bd14 00                         !8 0
    38                          currenttask_d81_image0_name:
    39  bd15 2020202020202020...        !text "                                "
    40                          currenttask_d81_image1_name:
    41  bd35 2020202020202020...        !text "                                "
    42                          
    43                          	;; DOS work area is full, so some things over-flow here:
    44                          	
    45                          	;; Used to temporarily stash the currently read SD card sector.
    46                          	;; (mostly to hide when we have to read a FAT sector during file
    47                          	;; access)
    48                          dos_stashed_sd_sector_number:
    49  bd55 00000000           	!8 0,0,0,0
    50                          	
    51                          	
    52                                  ;; Make sure we don't over-flow the available space
    53                                  * = start + $80
    54                          
    55                                  ;; Now we have file control blocks for the open files/directories.
    56                                  ;; We have only 128 bytes for these, so not many files can be open at a time!
    57                                  ;; This also means that we don't keep much information about a file in here.
    58                                  ;; For example, name, permissions/attributes and so on must be requested seprately
    59                                  ;; using trap_dos_fstat.  As a result, we can fit a few more open files in here, to
    60                                  ;; make life easy for programmers.  128 bytes / 32 bytes = 4 open files, which seems
    61                                  ;; a fairly minimal number.
    62                          
    63                          currenttask_filedescriptor0:
    64                                  ;; Which logical drive the file resides on
    65                                  ;; (or $FF for a free descriptor block = closed file.
    66                                  ;;  we put this in the first byte for convience for checking
    67                                  ;;  if a file descriptor is free).
    68                          currenttask_filedescriptor0_drivenumber:
    69  bd80 00                         !8 $00
    70                          
    71                                  ;; Starting cluster in file system
    72                                  ;; (used so that we can seek around in the file)
    73                          currenttask_filedescriptor0_startcluster:
    74  bd81 00000000                   !8 $00,$00,$00,$00
    75                          
    76                                  ;; Current cluster in file system
    77                          currenttask_filedescriptor0_currentcluster:
    78  bd85 00000000                   !8 $00,$00,$00,$00
    79                          
    80                                  ;; Current sector within current cluster
    81                          currenttask_filedescriptor0_sectorincluster:
    82  bd89 00                         !8 $00
    83                          
    84                                  ;; Length of file
    85                          currenttask_filedescriptor0_filelength:
    86  bd8a 00000000                   !8 $00,$00,$00,$00
    87                          
    88                                  ;; Position in file indicated by the buffer
    89                          currenttask_filedescriptor0_bufferposition:
    90  bd8e 00000000                   !8 $00,$00,$00,$00
    91                          
    92                                  ;; Cluster of the directory in which this file resides
    93                          currenttask_filedescriptor0_directorycluster:
    94  bd92 00000000                   !8 $00,$00,$00,$00
    95                          
    96                                  ;; Which entry this file is within the containing directory
    97                          currenttask_filedescriptor0_entryindirectory:
    98  bd96 0000                       !16 $0000
    99                          
   100                                  ;; Buffer address in target task used for this file
   101                                  ;; (32-bit virtual address, so that the buffer can be paged out)
   102                          currenttask_filedescriptor0_bufferaddress:
   103  bd98 00000000                   !8 $00,$00,$00,$00
   104                          
   105                                  ;; bytes loaded into buffer
   106                          currenttask_filedescriptor0_bytesinbuffer:
   107  bd9c 0000                       !16 $0000
   108                          
   109                                  ;; current offset within buffer
   110                          currenttask_filedescriptor0_offsetinbuffer:
   111  bd9e 0000                       !16 $0000
   112                          
   113                                  ;; The other three file descriptors follow the same format as the first
   114                          
   115                                  * = start + $a0
   116                          currenttask_filedescriptor1:
   117                          
   118                                  * = start + $c0
   119                          currenttask_filedescriptor2:
   120                          
   121                                  * = start + $e0
   122                          currenttask_filedescriptor3:
   123                          
   124                                  * = start + $100
   125                          

; ******** Source: src/hyppo/main.asm
  3450                          
  3451                          
  3452                          
  3453                          ;; /*  -------------------------------------------------------------------
  3454                          ;;     Reserved space for Hyppo ZP at $BF00-$BFFF
  3455                          ;;     ---------------------------------------------------------------- */
  3456                                  ;; .segment HyppoZP
  3457                                  * = HyppoZP_Start
  3458                          
  3459                                  ;; Temporary vector storage for DOS
  3460                                  ;;
  3461                          dos_scratch_vector:
  3462  bf00 00000000                   !16 0,0
  3463                          dos_scratch_byte_1:
  3464  bf04 00                         !8 0
  3465                          dos_scratch_byte_2:
  3466  bf05 00                         !8 0
  3467                          
  3468                                  ;; Vectors for copying data between hypervisor and user-space
  3469                                  ;;
  3470                          hypervisor_userspace_copy_vector:
  3471  bf06 0000                       !16 0
  3472                          
  3473                                  ;; general hyppo temporary variables
  3474                                  ;;
  3475                          zptempv:
  3476  bf08 0000                       !16 0
  3477                          zptempv2:
  3478  bf0a 0000                       !16 0
  3479                          zptempp:
  3480  bf0c 0000                       !16 0
  3481                          zptempp2:
  3482  bf0e 0000                       !16 0
  3483                          zptempv32:
  3484  bf10 00000000                   !16 0,0
  3485                          zptempv32b:
  3486  bf14 00000000                   !16 0,0
  3487                          dos_file_loadaddress:
  3488  bf18 00000000                   !16 0,0
  3489                          
  3490                          !if DEBUG_HYPPO {
  3491                                  ;; Used for checkpoint debug system of hypervisor
  3492                                  ;;
  3493                          checkpoint_a:
  3494                                  !8 0
  3495                          checkpoint_x:
  3496                                  !8 0
  3497                          checkpoint_y:
  3498                                  !8 0
  3499                          checkpoint_z:
  3500                                  !8 0
  3501                          checkpoint_p:
  3502                                  !8 0
  3503                          checkpoint_pcl:
  3504                                  !8 0
  3505                          checkpoint_pch:
  3506                                  !8 0
  3507                          }
  3508                          
  3509                                  ;; SD card timeout handling
  3510                                  ;;
  3511                          sdcounter:
  3512  bf1c 000000                     !8 0,0,0
  3513                          
  3514                          ;; /*  -------------------------------------------------------------------
  3515                          ;;     Scratch space in ZP space usually used by kernel
  3516                          ;;     we try to use address space not normally used by C64 kernel, so
  3517                          ;;     that it is possible to make calls to hyppo after boot. Eventually
  3518                          ;;     the desire is to have an SYS call that brings up a menu that lets
  3519                          ;;     you choose a disk image from a list.
  3520                          ;;     ---------------------------------------------------------------- */
  3521                          
  3522                          romslab:
  3523  bf1f 00                         !8 0
  3524                          screenrow:
  3525  bf20 00                         !8 0
  3526                          checksum:
  3527  bf21 00000000                   !32 0
  3528                          file_pagesread:
  3529  bf25 0000                       !16 0
  3530                          
  3531                                  ;; Variables for testing of D81 boot image
  3532                          d81_clusternumber:
  3533  bf27 00000000                   !32 0
  3534                          d81_clustersneeded:
  3535  bf2b 0000                       !16 0
  3536                          d81_clustercount:
  3537  bf2d 0000                       !16 0
  3538                          
  3539                          	;; Make sure we pad to full size
  3540                          	* = Hyppo_End
  3541  bfff 00                 	!8 0
